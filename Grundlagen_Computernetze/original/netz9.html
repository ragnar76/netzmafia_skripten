<!DOCTYPE HTML PUBLIC "-;W3C;DTD HTML 4.01 Transitional;EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta NAME="robots" CONTENT="all">
<meta NAME="revisit-after" CONTENT="10 days">
<meta NAME="Reply-To" CONTENT="webmaster@netzmafia.de">

<meta NAME="keywords" CONTENT="LAN WAN TCP/IP Computernetze Ethernet Vernetzung Router Hub Switch Protokolle">
<meta NAME="description" CONTENT="Praxisorientierte Einf&uuml;hrung in den Aufbau und die Funktionsweise von Computernetzen.">
<title>Grundlagen Computernetze</title>
</head>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" ALINK="#FF0000" VLINK="#FF00FF">
<CENTER><TABLE BORDER=0 WIDTH="90%" >
<TR><TD VALIGN=TOP ALIGN=LEFT><IMG SRC="eyes.gif"></TD>
<TD VALIGN=TOP ALIGN=RIGHT><H2>Grundlagen Computernetze</H2> 
<BR><B><I>Prof. J&uuml;rgen Plate</I></B></TD></TR>
</TABLE></CENTER>
<HR>

<h1 align=center>H&ouml;here Protokolle</h1>

In diesem Abschnitt werden beispielhaft einige h&ouml;here Protokolle f&uuml;r 
Internet-Dienste skizziert. Bemerkenswert ist, da&szlig; viele dieser Protokolle
aus wenigen Anweisungen in lesbarem Klartext bestehen. Der Grund hierf&uuml;r ist
unter anderem, da&szlig; man diese Protokolle zum Testen einer Verbindung
durch eine Telnet-Verbindung auf einem bestimmten Port (z. B. 80 f&uuml;r HTTP)
von Hand nachvollziehen kann. Durch den Klartext ist auch die Fehlersuche
bei einer Verbindung ohne gro&szlig;en Aufwand und ohne spezielle Tools
m&ouml;glich. Die vorgestellten Protokolle werden hier nicht bis ins Detail
ausgebreitet, es soll Ihnen nur eine Vorstellung &uuml;ber die Arbeitsweise
der Internet-Protokolle vermittelt werden.
<P>

<A NAME="9.1"></A>
<H2>DHCP</H2>
Um in einem IP-basierten Netzwerk Kontakt mit anderen Rechnern aufnehmen zu
k&ouml;nnen, ben&ouml;tigt jeder Computer eine eigene, eindeutige IP-Nummer.
Je gr&ouml;&szlig;er das Netzwerk wird und je mehr verschiedene Rechnerplattformen darin
vereint sind, desto h&ouml;her ist der Aufwand f&uuml;r den Administrator:
Wann immer ein neuer Rechner in das Netzwerk integriert wird, mu&szlig; er 
zuerst konfiguriert werden. &Auml;ndert einer der zentralen Server seine
Adresse oder wird er auf eine andere Maschine verlegt, m&uuml;ssen alle
Netzwerk-Client umkonfiguriert werden. Einen zweiter Aspekt bringen sogenannte
"nomadische" Systeme, z. B. Laptops, die irgendwo ins Netz eingebunden werden
sollen. Dabei bieten sich verschiedene Zugangsm&ouml;glichkeiten f&uuml;r
Rechner in das Intranet:
<UL>
<LI>Anschlu&szlig; &uuml;ber einen Ethernet-Switch
<LI>Zugang durch drahtlose Netze (und evtl. einen Router zum drahtlosen Subnetz)
<LI>Zugang vom Internet &uuml;ber eine Firewall
<LI>Modemzugang &uuml;ber einen Modemserver
</UL>
<P>
G&uuml;nstig w&auml;re es, wenn der Zugang eines Rechners zum Netz folgenden Anforderungen 
gen&uuml;gen w&uuml;rde:
<UL>
<LI>automatisiert, d. h. ohne manuellen Eingriff
<LI>authentifiziert, d. h. nur zugelassene Systeme erhalten Zugriff
<LI>vollst&auml;ndig (Netz-, System- und Anwendungskonfiguration)
<LI>standardisiert, d. h. f&uuml;r alle Systeme in einheitlicher Form
</UL>
<P>
Eine L&ouml;sung f&uuml;r dieses Problem bietet <B>DHCP</B> (Dynamic Host Configuration
Protocol). Dieser Dienst erm&ouml;glicht es, einem Client dynamisch eine
IP-Nummer und andere Netzwerkparameter, wie den Netzwerknamen, die 
Gatewayadresse, etc., zuzuweisen, ohne da&szlig; der Administrator den Rechner 
&uuml;berhaupt zu Gesicht bekommt. DHCP ist dabei v&ouml;llig unabh&auml;ngig von der 
eingesetzten Plattform. Das hei&szlig;t, es kann sowohl Windows-Maschinen wie 
auch zum Beispiel Unix-Rechner mit den Netzwerkeinstellungen versorgen. 
Um ein Mindestma&szlig; an Verf&uuml;gbarkeitsanforderungen zu erf&uuml;llen, 
sollte nat&uuml;rlich mehr als nur ein DHCP-Server vorhanden sein, da sonst 
dessen Ausfall die Funktion s&auml;mtlicher Clienten beeintr&auml;chtigt. 
Im Heimnetzwerk übernimmt in der Regel schon der DSL-ROuter die Funktionen
eine DHCP-Servers. Auch WLAN-Accesspoints können als DHCP-Server arbeiten.
<p>
<b>Hinweis:</b> Die Adressverteilung mittels DHCP wird nur für Endgeräte
empfohlen. Hosts, die das Netz eigentlich bilden, wie Router,
Switches, Server etc. sollten unbedingt feste IP-Adressen erhalten.
<P>
Das in RFC 2131 definierte Protokoll DHCP arbeitet nach dem Client-Server-Modell. 
Als Server wird ein Programm bezeichnet, das den Pool der zu vergebenden Nummern 
verwaltet und sich darum k&uuml;mmert, da&szlig; eine Nummer nicht zweimal vergeben wird. 
Der Client ist ein Programm auf dem lokalen Rechner, das zun&auml;chst den 
Server selbstt&auml;tig im Netz suchen mu&szlig; und ihn anschlie&szlig;end darum bittet, eine 
IP-Nummer zuzuteilen.
Die Grundfunktion des Servers ist recht einfach aufgebaut: &uuml;ber eine 
Konfigurationsdatei teilt der Administrator ihm mit, welche Adre&szlig;bereiche
er f&uuml;r die Weitergabe an Client zur Verf&uuml;gung hat. Fragt ein Client nach 
einer IP-Adresse, dann mu&szlig; der Server zun&auml;chst nachsehen, ob noch eine Adresse frei
ist. Diese freie IP-Nummer liefert er an den Client aus. Gleichzeitig
mu&szlig; er eine Datei (Leases-File) f&uuml;hren, in der er protokolliert, welche Adresse 
bereits an wen vergeben ist. Bei der Adre&szlig;vergabe sind drei verschiedene 
Modi einstellbar:
<UL>
<LI> <B> Automatic Allocation</B>: Fordert ein Client eine IP-Nummer
an, wird sie ihm auf unbegrenzte Zeit zugeteilt, solange noch Adressen 
zur Verf&uuml;gung stehen. Sind alle Adressen verbraucht, kann kein neuer Client
mehr konfiguriert werden, auch wenn ein Teil der zuvor bedienten 
Rechner im Moment gar nicht eingeschaltet ist. 
<LI> <B> Manual Allocation</B>: In dieser Betriebsart geht es nur darum,
Verwaltungsaufwand zu minimieren. In der Konfigurationsdatei ist
f&uuml;r jeden Client im Netzwerk eine IP-Nummer fest zugeordnet. Der
Server ist lediglich f&uuml;r die Auslieferung der Adresse an den Client
verantwortlich.
<LI> <B> Dynamic Allocation</B>: Jeder Client bekommt auf Anfrage eine
IP-Nummer, solange im definierten Pool noch Eintr&auml;ge frei sind. Der Unterschied 
gegen&uuml;ber der <I>Automatic Allocation</I> besteht darin, da&szlig; die IP-Nummer
nur f&uuml;r eine bestimmte, maximale Zeitspanne (<I>Lease-Time</I>) 
g&uuml;ltig ist und vom Client innerhalb dieser Zeit zur&uuml;ckgegeben werden kann, 
wenn sie nicht mehr ben&ouml;tigt wird.  Als einzige der drei Betriebsarten
erlaubt <I>Dynamic Allocation</I>, kleine IP-Nummern-Pools mit einer
gro&szlig;en Anzahl von Rechnern zu teilen. Einzige Voraussetzung:
nicht alle Maschinen d&uuml;rfen gleichzeitg laufen. Damit lassen sich auch
Computer, die eher selten ins Netzwerk integriert werden, wie Laptops,
zuverl&auml;ssig mit einer IP-Nummer versorgen. Wird der Rechner vom Netz 
getrennt, kann die Adresse f&uuml;r eine andere Station verwendet werden.
In dieser Betriebsart werden die meisten DHCP-Server betrieben.
</UL>
<P>
DHCP ist eine Erweiterung des BOOTP-Protokolls und konkurriert in seiner
Basisfunktionalit&auml;t mit RARP. Gegen&uuml;ber BOOTP zeichnet es sich vor 
allem durch die Flexibilit&auml;t bez&uuml;glich der abfragbaren Konfigurationsparameter 
und durch das Konzept der <I>Lease</I> aus, d. h. die M&ouml;glichkeit eine 
Information dem Client gegen&uuml;ber als nur begrenzt g&uuml;ltig zu markieren. 
Damit wird die Flexibilit&auml;t bei Ver&auml;nderungen der Netztopologie und weiterer
Konfigurationsparameter gewahrt. Ferner ist die Unterst&uuml;tzung von gro&szlig;en
Netzen, in denen nichts stets alle Systeme zugleich aktiv sind, mit limitierten
Pools von Adressen m&ouml;glich. Durch die R&uuml;ckw&auml;rtskompatibilit&auml;t 
zum PDU-Format von BOOTP ist die Verwendung existierender BOOTP-Relay-Agents in 
Subnetzen ohne DHCP-Server gewahrt.
<P>
<UL>
<LI>Der DHCP-Client, der eine IP-Adresse braucht, sendet ein
DHCPDISCOVER-Paket an einen DHCP-Server. Da die Adresse des Servers noch nicht
bekannt ist, wird dieses IP-Paket an die Broadcast-Adresse 255.255.255.255 
mit der Absender-Adresse 0.0.0.0 geschickt (Phase 1). 
<LI>Anhand der Identifikation des Client im Paket k&ouml;nnen sich einige (oder ein 
einzelner) DHCP-Server entscheiden, dem Client die gew&uuml;nschte IP-Adresse sowie
andere Konfigurationsinformation in Form eines DHCPOFFER-Pakets
zuzuteilen. (Vor der Vergabe k&ouml;nnen und sollten die Server die
Konfliktfreiheit bzgl. der Adresse mittels ICMP-Ping oder ARP pr&uuml;fen.)
Der DHCP-Server antwortet ebenfalls mittels Broadcast. In diesem Angebot
werden dem Client eine gültige IP-Adresse und weitere IP-Netzinformationen
mitgeteilt (Phase 2).
<LI>Der Client kann sich nun aus den Antworten eine f&uuml;r ihn geeignete
aussuchen und best&auml;tigt dies gegen&uuml;ber dem Server durch ein
DHCPREQUEST-Paket (Phase 3). Entscheidungsparameter k&ouml;nnen z. B. die
Leasedauer (t<SUB>l</SUB>) oder die Menge der angebotenen Konfigurationsinformation.
<LI>Bei korrekter Information im DHCPREQUEST best&auml;tigt der Server die Lease
durch ein DHCPACK-Paket (Acknowledge), womit die Konfiguration abgeschlossen ist (Phase 4).
</UL>
<P>
<CENTER><IMG SRC="dhcp.gif"></CENTER>
<P>
Neben den Adressinformationen wird auch noch ein "Transaction Identifier" übertragen. 
Diese zufällig erstellte ID ist eine Art Bearbeitungsnummer, die eine bestimmte 
Transaktion (d. h. DHCP-Adressvergabe) eindeutig kennzeichnet. Insbesondere, wenn
viele Clients gleichzeitig eine IP-Adresse anfordern, müssen diese Anfragen unterschieden 
werden können. Da noch gar keine individuellen Adressen bekannt sind, ist zu diesem
Zeitpunkt eine Unterscheidung nur mittels dieser Bearbeitungsnummer
möglich. Auch können neben der IP-Adresse weitere Informationen übermittelt
werden, beispielsweise die Subnetzmaske, der Name der eigenen Domain, die Adresse 
eines Routers (Default Gateway) und die Adresse eiens Nameservers.
<P>
Bevor die IP-Adresse verwendet wird, sollte der Client ihre Einzigartigkeit
durch ein <I>Gratuitious ARP</I> pr&uuml;fen. Sollte der Client die angebotene 
Adresse ablehnen wollen, teilt er dies durch DHCPDECLINE-Paket dem Server und
beginnt nach einer kurzen Wartefrist erneut mit Phase 1. Sobald der Client die 
Best&auml;tigung durch DHCPACK erhalten hat, ist er f&uuml;r die &Uuml;berwachung 
der Lease-Dauer selbst verantwortlich. Insbesondere kennt das Protokoll auch keine
Methode, einem Client die Lease zu entziehen.
<P>
Nach welchen Kriterien (IP-Adressbereich, Subnetzmaske) die DHCP-Clients Adressen 
erhalten, muss der Netzwerkadministrator festlegen und im DHCP-Server konfigurieren. 
Die Adressinformationen sind zudem nicht unbegrenzt gültig, sondern müssen
in regelmäßigen Abständen erneuert oder bestätigt werden. Die durch die Administratoren 
festgelegte Zeitdauer der Gültigkeit wird als "Lease Time" bezeichnet. Sie beträgt 
mehrere Stunden bis mehrere Tage.
<P>
Vor Ablauf der Lease-Dauer (meist nach der H&auml;lfte der Zeit = 0,5 * t<SUB>l</SUB>) 
sollte der Client durch einen erneuten Durchgang durch Phase 3 versuchen, die
Lease vom selben DHCP-Server verl&auml;ngert zu bekommen. Gelingt ihm das
nicht, kann er vor endg&uuml;ltigem Ablauf der Lease-Dauer (meist nach ca. 0,8 *
t<SUB>l</SUB>) die Phase 1 nochmals durchlaufen, um eine Verl&auml;ngerung bzw.
Neuausstellung der Lease (eventuell von einem anderen Server) zu erhalten.
Die vorzeitige Aufgabe einer Lease sollte der Client dem Server durch ein
DHCPRELEASE mitteilen, um den Pool freier Adressen m&ouml;glichst gro&szlig; und
den Vergabestand im Server m&ouml;glichst akkurat zu halten.
Alle Zustands&uuml;berg&auml;nge im Client sind in folgender Abbildung
zusammengefa&szlig;t. Die Komplexit&auml;t hat in der Vergangenheit zu einigen
Fehlimplementierungen mancher Client-Software gef&uuml;hrt, die jedoch aufgrund
der gro&szlig;en "Toleranz" im Protokoll meist keine kritischen Auswirkungen
hatten.
<P>
<CENTER><IMG SRC="dhcpablauf.gif"></CENTER>
<P>
Der Vorgang "Lease erneuen" kann beliebig oft wiederholt werden, solange der 
Client die Adresse noch braucht und der Server nichts dagegen hat. Unter 
Umst&auml;nden verweigert der DHCP-Server die Erneuerung. Falls die 
gew&uuml;nschte Adresse f&uuml;r den DHCP-Server inakzeptabel ist, schickt 
er dem Client ein ablehnendes DHCPNAK. Der Client beginnt dann von Neuem.
<p>
Was passiert, wenn der Client den DHCP-Server nicht mehr erreichen kann, 
der ihm seine IP-Adresse zugeteilt hat? Bevor sein Lease verf&auml;llt, 
soll der Client den DHCPREQUEST nicht mehr direkt an den DHCP-Server 
schicken, sondern es broadcasten. Somit h&ouml;ren alle DHCP-Server 
wieder mit. Wenn Failover richtig funktioniert, wird der Backup-Server 
jetzt das Lease erneuen. Kommt hingegen keine Antwort oder nur ein 
DHCPNAK, mu&szlig; der Client wieder von vorne beginnen, und ein 
DHCPDISCOVER broadcasten usw. Das ist insofern schlecht, als er nun 
h&ouml;chstwahrscheinlich eine ganz andere IP-Adresse bekommt. Bestehende 
Verbindungen, die noch die alte IP-Adresse verwenden, m&uuml;ssen abgebaut werden.
<P>
Beim Einsatz spezieller IP-Geräte, z. B. für KNX, für Kopplung mit SPS-Systemen,
für das Ansprechen von Sensoren/Messinterfaces oder für VoIP-Systeme ist jedoch 
die manuelle Konfiguration des DHCP-Servers oft unvermeidbar. Hier gilt es, sicher 
die Adressinformationen zu managen, einzuteilen und den Geräten zuzuweisen. Daher 
sind diese grundlegenden Kenntnisse Voraussetzung für die sichere Arbeit im IP-Netz.
Deshalb kann der DHCP-Server auch eingeschr&auml;nkt werden - bis hin zu einer Liste von
"erlaubten" MAC-Adressen. Man kann auch eine gemischte Versorgung der Rechner
im Netz vorsehen, teils mit festen IP-Adresse (z. B. Server mit "Au&szlig;enwirkung"),
teils mit dynamisch zugewiesenen Adressen. Teilweise sind viele der o. g. Geräte auch
standardmäßig auf DHCP konfiguriert und nicht immer ist der Bediener vor Ort in
der Lage, eine IP-Adresse nebst Netzmaske usw. zu konfigurieren. In solchen Fällen
ist es sinnvoll, die Konfiguration auf den DHCP-Server zu verlagern.
<P>

<A NAME="9.2"></A>
<H2>SMTP - Simple Mail Transfer Protocol</H2>
Der ursp&uuml;ngliche Standard f&uuml;r SMTP - niedergelegt im RFC 821 -
stammt aus dem Jahr 1982 und gilt, abgesehen von einigen
Erweiterungen, nach wie vor. Dieser RFC 821 legte ein Minimum an
Schl&uuml;sselworten fest, die jede Implementation von SMTP (d. h. die
Verk&ouml;rperung von SMTP in einem Programm) beherrschen mu&szlig;. Dies
sind:
<P>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADING=3>
<TD VALIGN=TOP>Kommando</TD><TD VALIGN=TOP>Argument</TD><TD VALIGN=TOP>Beschreibung</TD></TR>
<TR>
<TD VALIGN=TOP>HELO</TD><TD VALIGN=TOP>Systemname</TD>
<TD VALIGN=TOP>Beginn, Name des sendenden Systems</TD>
</TR>
<TR><TD VALIGN=TOP>MAIL</TD><TD VALIGN=TOP>From: Absenderadresse</TD>
<TD VALIGN=TOP>Beginn der &Uuml;bermittlung</TD></TR>
<TR><TD VALIGN=TOP>RCPT</TD><TD VALIGN=TOP>To: Empf&auml;ngeradresse</TD>
<TD VALIGN=TOP>Adressat der E-Mail</TD></TR>
<TR><TD VALIGN=TOP>DATA</TD><TD VALIGN=TOP>&nbsp;</TD>
<TD VALIGN=TOP>Brieftext, Ende durch eine Zeile mit "."</TD></TR>
<TR><TD VALIGN=TOP>HELP</TD><TD VALIGN=TOP>Topic</TD>
<TD VALIGN=TOP>Hilfestellung</TD></TR>
<TR><TD VALIGN=TOP>VRFY</TD><TD VALIGN=TOP>Mailadresse</TD>
<TD VALIGN=TOP>Mailadresse verifizieren</TD></TR>
<TR><TD VALIGN=TOP>EXPN</TD><TD VALIGN=TOP>Mailadresse</TD>
<TD VALIGN=TOP>Mailadresse expandieren (z. B. Liste)</TD></TR>
<TR><TD VALIGN=TOP>RSET</TD><TD VALIGN=TOP>&nbsp;</TD>
<TD VALIGN=TOP>Senden abbrechen, Zur&uuml;cksetzen</TD></TR>
<TR><TD VALIGN=TOP>NOOP</TD><TD VALIGN=TOP>&nbsp;</TD>
<TD VALIGN=TOP>nichts tun</TD></TR>
<TR><TD VALIGN=TOP>QUIT</TD><TD VALIGN=TOP>&nbsp;</TD>
<TD VALIGN=TOP>Verbindung beenden</TD></TR>
</TABLE>
<P>
Die Verbindung eines MTA zu einem anderen l&auml;&szlig;t sich nachstellen:
<P>
<PRE>
	telnet lx-lbs.e-technik.fh-muenchen.de smtp
	Trying 129.187.106.196...
	Connected to lx-lbs.e-technik.fh-muenchen.de.
	Escape character is '^]'.
	220 lx-lbs.e-technik.fh-muenchen.de Smail3.1.28.1 #1 ready at Sun, 25 Feb 96 23:15 MET
	helo www.netzmafia.de
	250 lx-lbs.e-technik.fh-muenchen.de Hello www.netzmafia.de
	mail from: paulsen@fitug.de
	250 <paulsen@fitug.de> ... Sender Okay
	rcpt to: holm@lx-lbs.e-technik.fh-muenchen.de
	250 <holm@lx-lbs.e-technik.fh-muenchen.de> ... Recipient Okay
	data
	354 Enter mail, end with "." on a line by itself
	Hallo Holm,
	
	zu Deiner Frage bezeglich der Reinigung von Morgensternen
	wollte ich Dir nur den Tip geben, dazu reine Kernseife zu
	verwenden.
	Damit ist die Drecksarbeit im Handumdrehen erledigt.
	
	Beste Gruesse, Paulsen
	.
	250 Mail accepted
	quit
	221 lx-lbs.e-technik.fh-muenchen.de closing connection
	Connection closed by foreign host.
</PRE>
<P>
Beim Verbindungsaufbau meldet sich der lokale MTA mit einer
"Begr&uuml;&szlig;ungszeile". 
Der lokale empfangende MTA wird mit "HELO"
angesprochen und als sendender MTA der des Systems
www.netzmafia.de angegeben.  Der lokale MTA antwortet mit
einem Zahlencode, der dem Sender-MTA signalisiert, da&szlig; seine
geforderte Aktion in Ordnung geht. Die Klarschrift nach dem
Zahlencode dient nur der besseren Lesbarkeit f&uuml;r den Menschen
(z. B. f&uuml;r den, der Fehler suchen mu&szlig;). 
Auf "MAIL FROM:" folgt die Adresse des Absenders, und 
auf "RCPT TO:" die des Empf&auml;ngers. Auf
das Schl&uuml;sselwort "DATA" folgt schlie&szlig;lich der 
ganze Brief, also sowohl die Kopfzeilen, als auch der Text. Der 
Empf&auml;nger-MTA wird
solange Text erwarten, bis ihm der Sender-MTA &uuml;ber eine Zeile,
die nur einen Punkt enth&auml;lt, signalisiert, da&szlig; der Brief zu Ende
ist. Nach der letzten Best&auml;tigung des Empf&auml;nger-MTAs k&ouml;nnte der
Sender den n&auml;chsten Brief &uuml;bermitteln, wiederum beginnend mit
"MAIL FROM:". Nach dem Empfang des Briefes kopiert der lokale MTA
den Brief in die Postfach-Datei des Empf&auml;ngers.
<P>
Der RFC 821 legte noch einige weitere Schl&uuml;sselworte fest, z. B.
"EXPN" f&uuml;r expand, welches eine Unterst&uuml;tzung von Mailing-Listen
erlaubt, oder "VRFY" f&uuml;r verify, mittels dessen eine Best&auml;tigung
der Empf&auml;nger-Adresse gefordert werden kann. Eine ganze Reihe von
RFCs haben den Standard f&uuml;r SMTP erweitert. Die erweiterte
Version hei&szlig;t nun offiziell ESMTP (f&uuml;r Extended SMTP).
Hinzugekommen sind beispielsweise Schl&uuml;sselworte f&uuml;r die
Unterst&uuml;tzung von 8bit-Briefen (z. B. solche mit Umlauten), und
die M&ouml;glichkeit eine maximale Gr&ouml;&szlig;e f&uuml;r Briefe, die empfangen
werden, festzulegen.
<P>
Auf Arbeitsplatzrechnern, die normalerweise nicht st&auml;ndig eingeschaltet 
sind, erfordert E-Mail spezielle Betriebsweisen. Falls der Rechner in ein 
lokales Netz integriert ist, bietet sich eine L&ouml;sung &uuml;ber den
Netzwerkserver oder einen speziellen Mail-Server an. Es gibt auch die
M&ouml;glichkeit, direkt vom PC-Kompatiblen oder Macintosh auf eine
Unix-Mailbox zuzugreifen. Voraussetzung daf&uuml;r ist, da&szlig; der
Arbeitsplatzrechner direkt mit TCP/IP am Ethernet angeschlossen ist
oder &uuml;ber eine Modem-Verbindung per PPP-Protokoll angebunden
ist. Die Mailer sind lokale Programme am PC oder Mac. Der Vorteil
ist, da&szlig; man in der PC-Umgebung bleibt, und Dateien direkt aus
dem PC-Directory-System versandt werden k&ouml;nnen. Die Mailbox des
Benutzers liegt dabei selbst auf einem Mail-Server (Postfach). Der
Zugriff vom PC auf das Mailsystem des Servers wird &uuml;ber
den Client/Server-Mechanismus realisiert. Protokolle, die dieses
erlaubt, sind POP ('Post Office Protocol') und IMAP ('Internet Message 
Access Protocol').
<P>

<A NAME="9.3"></A>
<H2>POP</H2>
POP, genauer POP 3, ist die bisher noch gebr&auml;uchlichste Methode, um E-Mails 
von einem Provider zu empfangen, wenn der eigene Rechner nicht st&auml;ndig mit dem
Internet verbunden ist. Das Prinzip und der Funktionsumfang von POP sind einfach:
<UL>
<LI> Die f&uuml;r den Empf&auml;nger bestimmten E-Mails landen beim
Provider im Spool-Verzeichnis und m&uuml;ssen dort vom
Empf&auml;nger abgeholt werden.
<LI> Der Provider stellt einen POP-Server zur Verf&uuml;gung, welcher die
Schnittstelle des POP-Clients auf dem Empf&auml;nger-Rechner
darstellt. Der lokale POP-Client kommuniziert mit dem POP-Server
beim Provider. &Uuml;ber ihn werden die vorhandenen E-Mails
angeboten.
</UL>
<P> 
Eine Kommunikation zwischen dem POP-Client und dem POP-Server beim
Provider kann schematisch beispielsweise so aussehen :
<P> 
<I>Client:</I>  Hast Du neue E-Mails f&uuml;r mich?<BR>
<I>Server:</I>  Ja, insgesamt f&uuml;nf St&uuml;ck!<BR>
<I>Client:</I>  Liste mir die Absender auf!<BR>
<I>Server:</I>  Meier, Mueller, Huber, Schulze<BR>
<I>Client:</I>  Zeige die E-Mails an!<BR>
<I>Server:</I>  ((Zeigt E-Mails an))<BR>
<I>Client:</I>  ((Speichert E-Mails ab))<BR>
<I>Client:</I>  L&ouml;sche alle angezeigten E-Mails<BR>
<I>Server:</I>  ((L&ouml;scht alle angezeigten E-Mails))<BR>
<P> 
Wenn ein Client &uuml;ber POP3 Nachrichten abrufen m&ouml;chte, baut er eine
TCP-Verbindung &uuml;ber Port 110 auf. Ist die Verbindung zustande gekommen, sendet 
der Server eine Begr&uuml;&szlig;ungsmeldung. Die weitere Kommunikation zwischen 
beiden Rechnern erfolgt &uuml;ber Kommandos, die aus drei oder vier Zeichen langen 
W&ouml;rtern (mit einem oder mehreren Argumenten mit bis zu je 40 Zeichen) bestehen.
Antworten enthalten einen Status-Indikator und ein Statuswort sowie optionale 
Informationen. Es gibt zwei Status-Indikatoren:
<UL>
<LI>Positiv: +OK 
<LI>Negativ: -ERR
</UL>
Eine POP3-Verbindung durchl&auml;uft mehrere Stufen. Nach der 
Server-Begr&uuml;&szlig;ung beginnt der "Authorization State". Der Client mu&szlig; sich 
gegen&uuml;ber dem Server identifizieren. Nach erfolgreicher Authorisierung beginnt 
der "Transaction State". Es werden alle Operationen zum Bearbeiten von Mails 
ausgef&uuml;hrt. Sendet der Client das Kommando QUIT, beginnt der "Update State". 
Der Server beendet die TCP-Verbindung und f&uuml;hrt die vom Client im 
"Transaction State" angeforderten &Auml;nderungen durch.
<P>
Viele POP3-Server haben zus&auml;tzlich einen Inaktivit&auml;ts-Timer. Laut 
Spezifikation mu&szlig; dieser auf mindestens zehn Minuten eingestellt sein. 
Jedes Kommando des Clients setzt den Timer zur&uuml;ck. Ist der Timer abgelaufen, 
wird die TCP-Verbindung beendet, ohne in den "Update State" zu wechseln - eventuelle
&Auml;nderungen werden auf dem Server nicht gespeichert.

<P>Nachdem der POP3-Client eine Verbindung zum Server aufgebaut hat, sendet dieser 
eine einzeilige Begr&uuml;&szlig;ungsmeldung beliebigenInhalts, z. B.:
<PRE>
<I>Server:</I> +OK POPEL-3 server ready
</PRE>
Dabei handelt es sich bereits um eine Antwort des Servers, daher beginnt die 
Meldung immer mit einer positiven Best&auml;tigung (+OK). Die Verbindung befindet 
sich nun im Zustand "Authorization". Der Client mu&szlig; sich jetzt gegen&uuml;ber 
dem Server identifizieren. Dies erfolgt &uuml;ber die beiden Kommandos USER und PASS.
<P>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADING=3>
<TR><TH COLSPAN=3>Kommandos im "Authorization State"</TD></TR>
<TR>
<TD VALIGN=TOP>Kommando</TD><TD VALIGN=TOP>Argument</TD><TD VALIGN=TOP>Beschreibung</TD></TR>
<TR>
<TD VALIGN=TOP>USER</TD><TD VALIGN=TOP>Name</TD>
<TD VALIGN=TOP>Das Argument identifiziert eine Mailbox.</TD>
</TR>
<TR>
<TD VALIGN=TOP>PASS</TD><TD VALIGN=TOP>String</TD>
<TD VALIGN=TOP>Der String enth&auml;lt ein Mailbox-spezifisches Passwort.</TD>
</TR>
<TR>
<TD VALIGN=TOP>QUIT</TD><TD VALIGN=TOP>-</TD>
<TD VALIGN=TOP>Beendet die Verbindung.</TD>
</TR>
</TABLE>
<P>
Die Kombination aus den Kommandos USER und PASS ist am gebr&auml;uchlichsten.
Dabei werden die jeweiligen Parameter im Klartext an den Server gesendet. 
Ein Beispiel: Der Username f&uuml;r das Postfach soll "plate", das Passwort 
"XYZ1230" hei&szlig;en. In diesem Fall wird folgender Authentifizierungsdialog ablaufen: 
<PRE>
<I>Client:</I> USER plate
<I>Server:</I> +OK name is a valid mailbox 
<I>Client:</I> PASS YXZ1230
<I>Server:</I> +OK plates's maildrop has 9 messages (1600 octets)
</PRE>
Bei falschen Angaben verweigert der Server den Zugang und gibt eine
Fehlermeldung aus. M&ouml;gliche Dialoge bei falschem Usernamen:
<PRE>
<I>Client:</I> USER plat<B>o</B>
<I>Server:</I> -ERR sorry, no mailbox for plato here
</PRE>
Oder bei einem falschen Passwort:
<PRE>
<I>Client:</I> USER plate
<I>Server:</I> +OK name is a valid mailbox 
<I>Client:</I> PASS tralala
<I>Server:</I> -ERR invalid password
</PRE>
Die Tatsache, da&szlig; alle Dialoge im Klartext &uuml;ber das Netz abgewickelt
werden, birgt ein hohes Sicherheitsrisiko. Mit dem Kommando APOP sieht die 
aktuelle POP3-Definition eine wesentlich sicherere Option zur Authentifizierung 
vor. Diese beschreibt in einem Kommando den User und identifiziert ihn mit einer
Einweg-Hash-Funktion. 
<P>
Hat sich der Client beim Server identifiziert, wechselt die Verbindung in den 
"Transaction State". Dem Client stehen nun eine Reihe von Kommandos zur 
Behandlung der Mails zur Verf&uuml;gung:
<P>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADING=3>
<TR><TH COLSPAN=3>Kommandos im "Transaction State"</TH></TR>
<TR><TD VALIGN=TOP>Kommando</TD><TD VALIGN=TOP>Argument</TD><TD VALIGN=TOP>Beschreibung</TD></TR>
<TR>
<TD VALIGN=TOP>STAT</TD><TD VALIGN=TOP>-</TD>
<TD VALIGN=TOP>Liefert die Anzahl der gespeicherten Mails und die Gr&ouml;&szlig;e der 
Mailbox zur&uuml;ck (in Byte).</TD>
</TR>
<TR>
<TD VALIGN=TOP>LIST</TD><TD VALIGN=TOP>Nummer</TD>
<TD VALIGN=TOP>Liefert die Nummer und Gr&ouml;&szlig;e (in Bytes) aller Mails zur&uuml;ck. 
Wird als Argument eine Mail-Nummer angegeben, wird nur die Gr&ouml;&szlig;e 
dieser Mail ausgegeben.</TD>
</TR>
<TR>
<TD VALIGN=TOP>RETR</TD><TD VALIGN=TOP>Nummer</TD>
<TD VALIGN=TOP>Gibt die Mail mit der als Argument &uuml;bergebenen Nummer aus.</TD>
</TR>
<TR>
<TD VALIGN=TOP>DELE</TD><TD VALIGN=TOP>Nummer</TD>
<TD VALIGN=TOP>L&ouml;scht die Mail mit der &uuml;bergebenen Nummer.</TD>
</TR>
<TR>
<TD VALIGN=TOP>NOOP</TD><TD VALIGN=TOP>-</TD>
<TD VALIGN=TOP>Bewirkt die Antwort "+OK". Dient zur Aufrechterhaltung der 
Verbindung, ohne da&szlig; ein Time-Out auftritt.</TD>
</TR>
<TR>
<TD VALIGN=TOP>RSET</TD><TD VALIGN=TOP>-</TD>
<TD VALIGN=TOP>Setzt die aktive Verbindung zur&uuml;ck. Noch nicht ausgef&uuml;hrte 
&Auml;nderungen werden verworfen.</TD>
</TR>
<TR>
<TD VALIGN=TOP>QUIT</TD><TD VALIGN=TOP>-</TD>
<TD VALIGN=TOP>Beendet die Verbindung und f&uuml;hrt alle gespeicherten &Auml;nderungen aus.</TD>
</TR>
</TABLE>
<P>
Der Server f&uuml;hrt das Kommando DELE nicht unmittelbar aus. Die entsprechenden 
E-Mails werden als gel&ouml;scht markiert und erst bei Beenden der Verbindung 
endg&uuml;ltig vom Server gel&ouml;scht. Hat man eine Nachricht zum L&ouml;schen 
gekennzeichnet, m&ouml;chte dies jedoch r&uuml;ckg&auml;ngig machen, f&uuml;hrt 
man das Kommando RSET aus. Der Server verwirft alle noch nicht ausgef&uuml;hrten 
Operationen.<BR>
Sendet der Client das QUIT-Kommando, wechselt die Verbindung in den "Update State". 
Der Server trennt die TCP-Verbindung und f&uuml;hrt alle gespeicherten 
&Auml;nderungen aus.
<P>
Neben den hier vorgestellten, f&uuml;r eine minimale Implementation ausreichenden 
Kommandos gibt es noch weitere, die von den meisten Clients und Servern unterst&uuml;tzt 
werden. Details hierzu finden Sie in RFC1725.
<P>
Im folgenden Beispiel sehen Sie den Ablauf einer POP3-Verbindung. Der Client 
identifiziert sich gegen&uuml;ber dem Server und ruft eine Liste der gespeicherten 
E-Mails ab. Danach werden die Nachrichten einzeln heruntergeladen, auf dem Server 
zum L&ouml;schen gekennzeichnet, und die Verbindung wird beendet.
<PRE>
<I>Server:</I> +OK POP3 server ready
<I>Client:</I> user plate
<I>Server:</I> +OK
<I>Client:</I> pass xyz1230
<I>Server:</I> +OK
<I>Client:</I> LIST
<I>Server:</I> +OK 3 messages (520 octets)
<I>Server:</I> 1 120
<I>Server:</I> 2 190
<I>Server:</I> 3 210
<I>Server:</I> .
<I>Client:</I> RETR 1
<I>Server:</I> +OK 120 octets
<I>Server:</I> &lt;<I>... sendet Nachricht 1</I>&gt;
<I>Server:</I> .
<I>Client:</I> DELE 1
<I>Server:</I> +OK message 1 deleted
<I>Client:</I> RETR 2
<I>Server:</I> +OK 190 octets
<I>Server:</I> &lt;<I>... sendet Nachricht 2</I>&gt;
<I>Server:</I> .
<I>Client:</I> DELE 2
<I>Server:</I> +OK message 2 deleted
<I>Client:</I> RETR 4
<I>Server:</I> -ERR no such message
<I>Client:</I> QUIT
<I>Server:</I> +OK
</PRE>
<P>

<A NAME="9.4"></A>
<H2>IMAP: Internet Message Access Protocol</H2>
IMAP (genauer: IMAP, Version 4) l&ouml;st das POP-Verfahren zunehmend ab 
und wird zum neuen Standard. Der Unterschied liegt unter anderem in der 
Funktionalit&auml;t des IMAP-Verfahrens.
Das Prinzip ist dem POP-Verfahren jedoch sehr &auml;hnlich. Die E-Mails
werden wie beim POP-Verfahren beim Provider zwischengespeichert und
k&ouml;nnen mit einem IMAP-Client auf den eigenen Rechner kopiert werden.
IMAP bietet jedoch zus&auml;tzliche Funktionalit&auml;ten, die von POP noch
nicht angeboten werden, z. B. kann der Mail-Body getrennt geladen werden, 
und auch die Attachments lassen sich getrennt abrufen.<BR>
E-Mail-Client und Server tauschen bei IMAP ihre Daten &uuml;ber den TCP-Port 143 aus. 
Im Gegensatz zu den Protokollen SMTP und POP mu&szlig; der Client bei IMAP nicht nach 
jedem gesendeten Kommando auf die unmittelbare Antwort des Servers warten. Es 
k&ouml;nnen mehrere Befehle hintereinander versendet werden, die jeweilige R&uuml;ckmeldung 
vom Server kann sp&auml;ter erfolgen. Dazu wird jedem Kommando seitens des Client eine 
Kennung vorangestellt, auch "Tag" genannt, zum Beispiel "X001" f&uuml;r den ersten 
Befehl und "X002" f&uuml;r den zweiten. Der Server kann dem Client auf mehrere Arten 
antworten: Mit einem Plus-Zeichen am Anfang der Zeile antwortet der Server, 
wenn er weitere Informationen zu dem vorangegangenen Kommando erwartet. Er 
signalisiert dem Client gleichzeitig seine Empfangsbereitschaft. Steht dagegen 
ein Sternchen am Anfang der Zeile, sendet der Server weitere Informationen 
an den Client zur&uuml;ck.
<P>
Die Antwort eines Servers kennzeichnet den Erfolg oder Fehler eines Kommandos: 
<UL>
<LI>OK (Kommando erfolgreich ausgef&uuml;hrt), 
<LI>NO (Fehler beim Ausf&uuml;hren) oder 
<LI>BAD (Protokoll-Fehler: Kommando unbekannt oder Syntax-Fehler). 
</UL>
Die Antwort enth&auml;lt denselben Tag wie das zugeh&ouml;rige Kommando, damit der Client
erkennt, welcher Response welchem Befehl gilt. Wie bei POP durchl&auml;uft eine 
IMAP-Verbindung mehrere Sitzungsstufen:
<UL>
<LI>Non-Authenticated State: Unmittelbar nach dem Aufbau der Verbindung. 
Der User mu&szlig; sich gegen&uuml;ber dem Server identifizieren.
<LI>Authenticated State: Der User hat sich erfolgreich identifiziert und 
mu&szlig; nun eine Mailbox ausw&auml;hlen.
<LI>Selected State: Eine Mailbox wurde ausgew&auml;hlt. Mailbox und Mails lassen 
sich bearbeiten.
<LI>Logout State: Die Verbindung wird beendet; der Server f&uuml;hrt noch 
anstehende T&auml;tigkeiten aus.
</UL>
<P>
Der "Non-Authenticated State" stellt mehrere M&ouml;glichkeiten zur Identifizierung 
des Anwenders zur Verf&uuml;gung. Es gibt in diesem Zusatand folgende Kommandos:
<P>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 cellpadding=3>
<TR><TH COLSPAN=3>Kommandos im "Non-Authenticated State"</TH></TR>
<TR>
<TD VALIGN=TOP>Kommando</TD><TD VALIGN=TOP>Argument</TD><TD VALIGN=TOP>Beschreibung</TD></TR>
<TR>
<TD VALIGN=TOP>AUTHENTICATE</TD><TD VALIGN=TOP>Authentifizierungs-Mechanismus</TD>
<TD VALIGN=TOP>Das Kommando bestimmt den Authentifizierungs-Mechanismus, zum Beispiel 
"Kerberos" oder "S/Key". Details zu den Authentifizierungs-Mechanismen finden 
Sie in RFC1731.</TD>
</TR>
<TR>
<TD VALIGN=TOP>LOGIN</TD><TD VALIGN=TOP>Name/Passwort</TD>
<TD VALIGN=TOP>Identifiziert den Anwender &uuml;ber Benutzername und Passwort.</TD>
</TR>
</TABLE>
<P>
Beispiel f&uuml;r eine Authentifizierung mit dem LOGIN-Kommando:
<PRE>
<I>Client:</I> X001 LOGIN PLATE XYZ1230
<I>Server:</I> X001 OK LOGIN completed
</PRE>
<P>
Im "Authenticated State" hat sich der User authentifiziert und mu&szlig; nun eine 
Mailbox ausw&auml;hlen, welche in dieser Sitzung bearbeitet werden soll. Dazu 
stehen unter anderem folgende Kommandos zur Verf&uuml;gung:
<P>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 Cellpadding=3>
<TR><TH COLSPAN=4>Wichtige Kommandos im "Authenticated State"</TH></TR>
<TR>
<TD VALIGN=TOP>Kommando</TD><TD VALIGN=TOP>Argument</TD><TD VALIGN=TOP>Beschreibung</TD></TR>
<TR>
<TD VALIGN=TOP>SELECT</TD><TD VALIGN=TOP>Mailbox-Name</TD>
<TD VALIGN=TOP>W&auml;hlt eine Mailbox zur weiteren Bearbeitung aus. Als erfolgreiche Antwort 
sendet der Client Informationen zur gew&auml;hlten Mailbox, wie beispielweise die 
Anzahl der gespeicherten Nachrichten.</TD>
</TR>
<TR>
<TD VALIGN=TOP>EXAMINE</TD><TD VALIGN=TOP>Mailbox-Name</TD>
<TD VALIGN=TOP>Identisch mit dem Kommando SELECT. Jedoch wird die Mailbox als 
"read-only" ausgew&auml;hlt, es sind keine dauerhaften &Auml;nderungen m&ouml;glich.</TD>
</TR>
<TR>
<TD VALIGN=TOP>CREATE</TD><TD VALIGN=TOP>Mailbox-Name</TD>
<TD VALIGN=TOP>Erstellt eine Mailbox mit dem als Argument &uuml;bergebenen Namen.</TD>
</TR>
<TR>
<TD VALIGN=TOP>DELETE</TD><TD VALIGN=TOP>Mailbox-Name</TD>
<TD VALIGN=TOP>L&ouml;scht die als Argument &uuml;bergebene Mailbox.</TD>
</TR>
<TR>
<TD VALIGN=TOP>RENAME</TD><TD VALIGN=TOP>Bestehender Mailbox-Name / Neuer Mailbox-Name</TD>
<TD VALIGN=TOP>&Auml;ndert den Namen einer Mailbox.</TD>
</TR>
</TABLE>
<P>

Beispiel: L&ouml;schen einer Mailbox:
<PRE>
<I>Client:</I> X324 DELETE TRALALA
<I>Server:</I> X234 OK DELETE completed
</PRE>
<P>
Im "Selected State" gibt es viele Kommandos zum Bearbeiten einer Mailbox:
<P>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADDING=3>
<TR><TH COLSPAN=4>Wichtige Kommandos im "Selected State"</TH></TR>
<TR><TD>Kommando</TD><TD VALIGN=TOP>Argument</TD><TD VALIGN=TOP>Beschreibung</TD></TR>
<TR>
<TD VALIGN=TOP>CLOSE</TD><TD VALIGN=TOP>-</TD>
<TD VALIGN=TOP>Entfernt alle zum L&ouml;schen gekennzeichneten Mails und setzt die Verbindung 
in den Authenticated State zur&uuml;ck.</TD>
</TR>
<TR>
<TD VALIGN=TOP>EXPUNGE</TD><TD VALIGN=TOP>-</TD>
<TD VALIGN=TOP>Entfernt alle zum L&ouml;schen gekennzeichneten Mails, die Verbindung bleibt 
im Selected State.</TD>
</TR>
<TR>
<TD VALIGN=TOP>SEARCH</TD><TD VALIGN=TOP>ein oder mehrere Suchkriterien</TD>
<TD VALIGN=TOP>Erlaubt die Suche nach bestimmten Nachrichten in der aktuellen Mailbox. Das 
Kommando unterst&uuml;tzt logische Verkn&uuml;pfungen.</TD>
</TR>
<TR>
<TD VALIGN=TOP>FETCH</TD><TD VALIGN=TOP>Gew&uuml;nschte Daten einer Nachricht</TD>
<TD VALIGN=TOP>Bewirkt das Senden von Daten einer Nachricht vom Server zum Client.</TD>
</TR>
</TABLE>
<P>

Beispiel: Suchen einer Nachricht. Ergebnis sind die Nummern der entsprechenden Mails:
<PRE>
<I>Client:</I> X246 SEARCH SINCE 1-NOV-2001 FROM "ADAM"
<I>Server:</I> * SEARCH 2 84 882
<I>Server:</I> X246 OK SEARCH completed</font>
</PRE>
<P>

Beendet der Client mit dem Kommando LOGOUT die Verbindung, wechselt der Server in 
den "Update State" und f&uuml;hrt noch anstehende Arbeiten aus.<BR>
Es gibt eine Reihe weiterer Befehle im "Authenticated State" und "Selected State",
die in RFC2060 nachzulesen sind.
<P>
Im abschlie&szlig;enden Beispiel sehen Sie den Ablauf einer IMAP4-Verbindung. 
Der Client identifiziert sich gegen&uuml;ber dem Server, w&auml;hlt eine Mailbox aus und 
l&auml;dt den Header einer Nachricht herunter.
<PRE>
<I>Server:</I> * OK IMAP4 Service Ready
<I>Client:</I> X001 login plate XYZ1230
<I>Server:</I> X001 OK LOGIN completed
<I>Client:</I> X002 select inbox
<I>Server:</I> * 12 EXISTS
<I>Server:</I> * FLAGS (\Answered \Flagged \Deleted \Seen \Draft)
<I>Server:</I> * 2 RECENT
<I>Server:</I> * OK [UNSEEN 11] Message 11 is first new message
<I>Server:</I> * OK [UIDVALIDITY 2905753845] is first new message
<I>Server:</I> X002 OK [READ-WRITE] SELECT completed
<I>Client:</I> X003 fetch 9 rfc822.header
<I>Server:</I> * 9 FETCH (RFC822.HEADER {346}
<I>Server:</I> Date: mon, 11 Mar 2002 09:23:25 -0100 (MET)
<I>Server:</I> From: plate &lt;plate@netzmafia.de&gt;
<I>Server:</I> Subject: Schulung Netzwerke am Donnerstag
<I>Server:</I> To:  &lt;schulung@ee.fhm.edu&gt;
<I>Server:</I> Message-Id: &lt;20020311104452.GH1474.plate@netzmafia.de&gt;
<I>Server:</I> Mime-Version: 1.0
<I>Server:</I> Content-Type: TEXT/PLAIN; CHARSET=iso-8859-1
<I>Server:</I> )
<I>Server:</I> X003 OK FETCH completed
<I>Client:</I> X004 LOGOUT
<I>Server:</I> * BYE IMAP4 server terminating connection
<I>Server:</I> X004 OK LOGOUT completed
</PRE>
<P>
Nachdem der Mail-Client &uuml;ber TCP eine Verbindung zum SMTP-Server aufgebaut hat, 
wartet er auf einen Begr&uuml;&szlig;ungstext des Servers. Im n&auml;chsten Schritt identifiziert 
sich der Client mit dem Kommando LOGIN, als Argument &uuml;bergibt er den Benutzernamen 
und das Passwort. Nach dem Ausw&auml;hlen der Mailbox sendet der Server einige Informationen, 
z. B. die Anzahl der ungelesenen Nachrichten. Mit dem Kommando FETCH fordert der 
Client den Header der Nachricht 9 an. LOGOUT beendet die Verbindung.
<P> 
Bei Inbetriebnahme eines POP- bzw. IMAP-Clients (Outlook, Pegasus Mail, Netscape)
mu&szlig; dieser zun&auml;chst konfiguriert werden. Wichtige Angaben sind:
<UL>
<LI> Domainname des POP- bzw. IMAP-Servers, d.h. Systems, auf 
dem die eigentliche Mailbox liegt.
<LI>Benutzernummer auf diesem System
<LI>Pa&szlig;wort f&uuml;r diese Benutzernummer
<LI>f&uuml;r den Versand: Angabe des SMTP-Mail-Relayhosts
</UL>
<P>
POP/IMAP dient nur zum Abholen der Post vom Mail-Server. Der Versand 
von E-Mail vom PC oder Mac aus geschieht ganz normal mit SMTP 
(Simple Mail Transfer Protocol).
<P>

<A NAME="9.5"></A>
<H2>FTP</H2>
Ein weiterer zentraler Dienst in einem Intranet, der besonders dem Transport 
von Dateien auf andere Systeme dient, ist das File-Transfer-Protokoll.
Die Besonderheit des Protokolls liegt in den getrennten Kan&auml;len f&uuml;r 
die Daten und die Steuerung.
Im RFC 959 ist f&uuml;r FTP TCP-Port 20 als Steuerungskanal und TCP-Port 21
als Datenkanal festgelegt. FTP verwendet als Transportprotokoll immer TCP, 
da dieses bereits einen sicheren Datentransfer garantiert und die FTP-Software 
sich nicht darum zu k&uuml;mmern braucht. FTP besitzt eine eigene 
Kommandooberfl&auml;che, die interaktiv bedient wird. Der Aufruf dieses 
Filetransferprogrammes erfolgt durch das Kommando <TT>ftp</TT>.<BR>
Die Vorteile von FTP liegen in den effizienten Verfahren zur &Uuml;bertragung
von Dateien beliebigen Formats und der Tatsache, da&szlig; der Zugriff seitens
beliebiger Internet-Teilnehmern m&ouml;glich ist. Andererseits
kann bei gr&ouml;&szlig;eren Archiven schnell die &uuml;bersicht verlorengehen, wenn
die Datenbest&auml;nde nicht vern&uuml;nftig sortiert sind. Bei umfangreichen
Dateib&auml;umen ist hingegen die Navigation durch die Verzeichnisse eine
zeitraubende Angelegenheit. Es werden weiterhin zwei Betriebsmodi unterschieden:
<UL>
<LI> Benutzerspezifisches FTP
<LI> Anonymous-FTP
</UL>
In beiden F&auml;llen ist es m&ouml;glich, Verzeichnisse einzusehen und
zu wechseln, sowie Dateien zu empfangen und zu senden. Der Unterschied
liegt in den Privilegien, die ein Benutzer besitzt. W&auml;hrend im ersten
Fall der User eine Zugangsberechtigung zum System ben&ouml;tigt, so verf&uuml;gt
ein Gastzugang nur &uuml;ber eine eingeschr&auml;nkte Sicht auf den Datenbereich
des Servers, was als einfacher Sicherheitsmechanismus anzusehen ist.
<P>
<CENTER><IMG SRC="ftp.gif"></CENTER>
<P>
Der Kommandoaufruf des FTP-Kommandos lautet
<P>
<TT><B>ftp</B> [ -v ] [ -d ] [ -i ] [ -n ] [ -g ] [ host ]</TT>
<P>
Wird beim Programmaufruf der gew&uuml;nschte Kommunikationspartner (host) mit
angegeben, so wird sofort versucht, eine Verbindung zu diesem Rechensystem aufzubauen.
Ist der Versuch erfolglos, so wird in den Kommandomodus umgeschaltet. Der Prompt
"<TT>ftp&gt;</TT>" erscheint immer auf dem Bildschirm, wenn ftp-Kommandos eingegeben
werden k&ouml;nnen. <TT>ftp</TT> verf&uuml;gt &uuml;ber einen help-Mechanismus,
&uuml;ber den s&auml;mtliche auf dem jeweiligen System verf&uuml;gbare Kommandos mit
Kurzerkl&auml;rungen abfragbar sind. <BR>
Nachfolgend werden wesentliche Kommandos nach Funktionalit&auml;t gruppiert vorgestellt.
Kommandos k&ouml;nnen soweit verk&uuml;rzt eingegeben werden, als sie noch eindeutig
erkennbar sind. Enthalten Kommandoargumente "Blanks", so sind die Argumente beidseitig mit
Hochkommas eingeschlossen einzugeben. Nicht alle <B>ftp</B>-Implementierungen 
unterst&uuml;tzen alle <B>ftp</B>-Kommandos.
<UL>
<LI><TT>help [ kommando ]</TT><BR>
      zeigt kurze Informationen zu dem angegebenen Kommando. Wird das Kommando
      weggelassen, zeigt dieser Aufruf eine Liste der zul&auml;ssigen Kommandos.

<LI><TT>open</TT> host<BR>
      &Ouml;ffne einer Verbindung zu einem fernen Host. Je nach angew&auml;hltem 
      System werden Benutzerkennung und Passwort abgefragt.

<LI><TT>user</TT> user-name [ password ]<BR>
      Eingabe von Benutzerkennung und Passwort.

<LI><TT>!</TT><BR>
      Aufruf einer (eingeschr&auml;nkten) Shell auf dem lokalen System. F&uuml;r 
      Datei&uuml;bertragung relevante Kommandos wie <TT>mkdir</TT>, <TT>mv</TT>, 
      <TT>cp</TT>, etc sind absetzbar. Verlassen wird diese Shell mit "exit".

<LI><TT>lcd</TT> [directory ]<BR>
      Wahl des lokalen Directories f&uuml;r die Datei&uuml;bertragung. 

<LI><TT>pwd</TT><BR>
      Anzeige des aktuellen Directories auf dem entfernten System.

<LI><TT>cd</TT> remote-directory<BR>
      Wahl des aktuellen Directories auf dem entfernten System.

<LI><TT>cdup</TT><BR>
      Wechsel in das n&auml;chsth&ouml;here Directory auf dem entfernten System.

<LI><TT>dir</TT> [ remote-directory [ local-file ] ]<BR>
<TT>ls</TT> [ remote-directory [ local-file ] ]<BR>
      Ohne Optionen erfolgt eine Anzeige der Eintr&auml;ge des entfernten aktuellen 
      Directories. Dabei liefert <TT>dir</TT> ausf&uuml;hrliche und <TT>ls</TT> 
      eine knappe Information bez&uuml;glich des Directory-Inhalts.<BR>
      Bei Angabe des<TT> remote-directory </TT> erfolgt die Anzeige der Eintr&auml;ge 
      des entfernten Directories. Wird <TT>local-file</TT> angegeben, erfolgt eine
      Umlenkung der Directory-Anzeige in die Datei <TT>local-file</TT> auf dem lokalen
      System.

<LI><TT>mdir</TT> remote-files [ local-file ]<BR>
<TT>mls</TT> remote-files [ local-file ]<BR>
      Anzeige von Dateien aus dem entfernten aktuellen Directory und Abspeicherung in eine
      lokale Datei.

<LI><TT>mkdir</TT> directory-name<BR>
      Einrichten eines neuen Directories <TT>directory-name</TT> auf dem entfernten
      System.

<LI><TT>rmdir</TT> directory-name<BR>
      l&ouml;scht das Directory <TT>directory-name</TT> auf dem entfernten System.

<LI><TT>rename</TT> [ from ] [ to ]<BR>
      Umbenennen einer Datei auf dem entfernten System von <TT>from</TT> nach
      <TT>to</TT>.

<LI><TT>delete</TT> remote-file<BR>
      L&ouml;schen der Datei <TT>remote-file</TT> auf dem entfernten System.

<LI><TT>mdelete</TT> remote-files<BR>
      L&ouml;schen mehrerer Dateien <TT>remote-files</TT> auf dem entfernten System.

<LI><TT>put</TT> local-file [ remote-file ]<BR>
<TT>send</TT> local-file [ remote-file ]<BR>
      Datei&uuml;bertragung der Datei <TT>local-file</TT> vom lokalen zum entfernten 
      System. Wird <TT>remote-file</TT> nicht angegeben, so wird auch auf dem 
      Zielsystem der Dateiname <TT>local-file</TT> verwendet. 

<LI><TT>append </TT>local-file [ remote-file ]<BR>
      &uuml;bertr&auml;gt die Datei <TT>local-file</TT> vom lokalen System an das entfernte
      System und h&auml;ngt diese am Ende der Datei <TT>remote-file</TT> an. Wurde 
      <TT>remote-file</TT> nicht angegeben, wird die Datei ans Ende der Datei 
      <TT>local-file</TT> auf dem entfernten System angeh&auml;ngt.

<LI><TT>mput</TT> local-files<BR>
      Datei&uuml;bertragung einer Dateigruppe namensgleich vom lokalen zum entfernten
      System. 

<LI><TT>get</TT> remote-file [ local-file ]<BR>
     <TT>recv</TT> remote-file [ local-file ]<BR>
      Datei&uuml;bertragung einer Datei <TT>remote-file</TT> vom entfernten System zum
      lokalen System. Wird <TT>local-file</TT> nicht mitangegeben, so erh&auml;lt die Datei
      auch auf dem lokalen System den Dateiname <TT>remote-file</TT>.

<LI><TT>mget</TT> remote-files<BR>
      Datei&uuml;bertragung einer Dateigruppe namensgleich vom entfernten zum lokalen
      System. 

<LI><TT>ascii</TT><BR>
     <TT>type ascii</TT><BR>
      Die Datei&uuml;bertragung findet im ASCII-Code statt. Gegebenfalls werden
      bei Bin&auml;rdateien Zeichen ver&auml;ndert (z. B. die Zeilenendedarstellung
      ans Zielsystem angepa&szlig;t) oder Zeichen verf&auml;lscht.

<LI><TT>binary</TT><BR>
     <TT>type image</TT><BR>
     <TT>type binary</TT><BR>
      Die Datei&uuml;bertragung findet transparent statt.

<LI><TT>case</TT><BR>
      Mit diesem Schalter l&auml;&szlig;t sich einstellen, ob Dateinamen beim Empfangen
      (<TT>get</TT>, <TT>recv</TT>, <TT>mget</TT>) von Gro&szlig;buchstaben 
      nach Kleinbuchstaben &uuml;bersetzt werden sollen.

<LI><TT>glob</TT><BR>
      Mit diesem Schalter l&auml;&szlig;t sich einstellen, ob bei den Kommandos 
      <TT>mdelete</TT>, <TT>mget</TT> und <TT>mput</TT> bei Dateinamen, die 
      Metazeichen (<TT>*?[]~{}</TT>) enthalten, diese Metazeichen &uuml;bertragen 
      werden oder nicht. ("off" = keine Metazeichenbehandlung). 

<LI><TT>ntrans</TT> [ inchars [ outchars ] ]<BR>
      Definition und Aktivierung einer &Uuml;bersetzungstabelle f&uuml;r Dateinamen, wenn
      beim Datei&uuml;bertragungsauftrag (Senden und Empfangen) keine Zieldateinamen 
      angegeben werden. Zeichen eines Dateinamens, die in <TT>inchars</TT> zu finden 
      sind, werden durch das positionsgleiche Zeichen in <TT>outchars</TT> 
      &uuml;bersetzt. Ist <TT>inchars</TT> l&auml;nger als <TT>outchars</TT>, so 
      werden die korrespondenzlosen Zeichen von <TT>inchars</TT> aus
      dem Zieldateinamen entfernt.

<LI><TT>prompt</TT><BR>
      Mit diesem Zeichen wird bei Mehrdateien&uuml;bertragung gesteuert, ob jede zu
      &uuml;bertragende Datei extra quittiert werden mu&szlig; oder nicht.

<LI><TT>verbose</TT><BR>
      Wenn der "verbose"-Modus eingeschaltet ist, erh&auml;lt man f&uuml;r jede 
      &uuml;bertragene Datei den Dateinamen auf dem lokalen und entfernten Rechner, 
      sowie die Datenmenge und die daf&uuml;r ben&ouml;tigte &Uuml;bertragungszeit 
      angezeigt.

<LI><TT>bell</TT><BR>
      Dieser Schalter bewirkt, da&szlig; je nach Stellung am Ende jedes 
      Datei&uuml;bertragungsauftrages ein akustisches Signal ert&ouml;nt oder nicht.

<LI><TT>status</TT><BR>
      Anzeige der aktuellen logischen Schalterstellungen sowie des Verbindungszustandes.

<LI><TT>close</TT><BR>
     <TT>disconnect</TT><BR>
      Beendigung einer aktiven Verbindung.

<LI><TT>quit</TT><BR>
      Beendigung des Programmes <TT>ftp</TT>.

<LI><TT>bye</TT><BR>
      Beendigung einer aktiven Sitzung und des Programmes <TT>ftp</TT>.
</UL>
<P>

Die optionalen Parameter beim <TT>ftp</TT>-Kommando setzen logische
Schalter f&uuml;r den ftp-Programmlauf. Im Kommandomodus sind die 
Einstellungen jederzeit wieder &auml;nderbar.<P>
<UL>
<LI><TT>-v</TT> verbose-Schalter einschalten.
<LI><TT>-d</TT> debug-Schalter einschalten.
<LI><TT>-i</TT> interactive-Modus f&uuml;r Mehrdatei&uuml;bertragung einschalten.
<LI><TT>-n</TT> verhindert, da&szlig; <TT>FTP</TT> zum Beginn der Sitzung 
                   einen Login-Versuch unternimmt.
<LI><TT>-g</TT> glob-Schalter einschalten.
</UL>
<P>
Die Datei-&Uuml;bertragung wird durch die Terminal "<TT>interrupt</TT>"-Taste
(&uuml;blicherweise Ctrl-C) abgebrochen, was einen sofortigen Abbruch zur Folge haben soll.
Nicht alle Kommunikationspartner verstehen die Abbruchaufforderung, wodurch dennoch
die gesamte Datei &uuml;bertragen wird.
<P>
Dateinamen, die als Argumente von FTP-Kommandos Verwendung finden, werden wie folgt
bearbeitet:
Ist "file globbing" eingeschaltet, werden bei den Kommandos <TT>mget</TT>,
<TT>mput</TT> und <TT>mdelete</TT> die Namen lokaler Dateien folgenderma&szlig;
behandelt:
<UL>
<LI>Der <TT>*</TT> steht f&uuml;r eine beliebige Anzahl (auch Null) von Zeichen.
<LI>Das <TT>?</TT>steht f&uuml;r ein einziges beliebiges Zeichen.
<LI>Wird im Dateinamen eine Zeichenfolge angetroffen, die zwischen eckigen Klammern
oder zwischen geschweiften Klammern steht, so sind alle Dateinamen zutreffend, die an
dieser Stelle ein einziges beliebiges Zeichen aus der Zeichenfolge innerhalb der
Klammern enthalten.
<LI>Steht die Zeichenfolge <TT>~/</TT> (Tilde, Schr&auml;gstrich) am Beginn des 
Dateinamens, so wird sie durch den Home-Directory-Pfad ersetzt. 
Das Zeichen <TT>~</TT>, dem eine Benutzerkennung folgt, wird durch den 
Home-Directory-Pfad dieser Benutzerkennung ersetzt.
</UL>
<P>
Kommandos und Protokoll-Anweisungen:
<P>
<TABLE WIDTH="80%" ALIGN=CENTER BORDER=1 CELLPADDING=3>
<TR><TD>ftp-Client</TD><TD>FTP-Protokoll</TD><TD>Aufgabe</TD></TR>
<TR><TD>login</TD><TD>USER username<BR>PASS password</TD><TD>anmelden</TD></TR>
<TR><TD>help<BR>help command</TD><TD>HELP<BR>HELP command</TD><TD>Hilfe</TD></TR>
<TR><TD>&nbsp;</TD><TD>SYST</TD><TD>Server-Identifikation</TD></TR>
<TR><TD>status</TD><TD>STAT</TD><TD>Transfer-Status
<TR><TD>&nbsp;</TD><TD>STAT path</TD><TD>wie LIST, &uuml;ber control-Verbindung</TD></TR>
<TR><TD>dir path</TD><TD>LIST path</TD><TD>Kataloginhalt zeigen, ausf&uuml;hrlich</TD></TR>
<TR><TD>ls path</TD><TD>NLST path</TD><TD>Dateinamen zeigen</TD></TR>
<TR><TD>delete path</TD><TD>DELE path</TD><TD>Datei l&ouml;schen</TD></TR>
<TR><TD>rename from to</TD><TD>RNFR from-path<BR>RNTO to-path</TD><TD>Datei umbenennen</TD></TR>
<TR><TD>pwd</TD><TD>PWD</TD><TD>Arbeitskatalog zeigen</TD></TR>
<TR><TD>cd path</TD><TD>CWD path</TD><TD>Katalog wechseln</TD></TR>
<TR><TD>mkdir path</TD><TD>MKD path</TD><TD>Katalog erzeugen</TD></TR>
<TR><TD>rmdir path</TD><TD>RMD path</TD><TD>Katalog l&ouml;schen</TD></TR>
<TR><TD>ascii</TD><TD>TYPE A N</TD><TD>Text&uuml;bertragung (Voreinstellung)</TD></TR>
<TR><TD>binary</TD><TD>TYPE I</TD><TD>Daten&uuml;bertragung</TD></TR>
<TR><TD>&nbsp;</TD><TD>PORT h,h,h,h,p,p</TD><TD>Port des Klienten f&uuml;r data-Verbindung</TD></TR>
<TR><TD>get remote-path</TD><TD>RETR path</TD><TD>Datei zum Klienten &uuml;bertragen</TD></TR>
<TR><TD>put local-path</TD><TD>STOR path</TD><TD>Datei zum Server &uuml;bertragen</TD></TR>
<TR><TD>append local-path</TD><TD>APPE path</TD><TD>an Datei auf Server anf&uuml;gen</TD></TR>
<TR><TD><I>interrupt</I></TD><TD>ABOR</TD><TD>_bertragung abbrechen</TD></TR>
<TR><TD>quit</TD><TD>QUIT</TD><TD>Verbindung beenden</TD></TR>
</TABLE>
<P>
<H3>Beispiel</H3>
Benutzereingaben sind <B>fett</B> gedruckt.
<PRE>
<B>ftp multimedia.ee.fhm.edu</B>
Verbindung mit multimedia.ee.fhm.edu.
220 ProFTPD 1.2.2rc2 Server [multimedia.e-technik.fh-muenchen.de]
Benutzer (multimedia.ee.fhm.edu:(none)): <B>plate</B>
331 Password required for plate.
Kennwort:
230 User plate logged in.
Ftp> <B>ls</B>
200 PORT command successful.
150 Opening ASCII mode data connection for file list.
tmp
Mail
bin
226 Transfer complete.
Ftp: 36 Bytes empfangen in 0.00Sekunden 36000.00KB/Sek.
Ftp> <B>cd tmp</B>
250 CWD command successful.
Ftp> <B>lcd E:\www-netzmafia\skripten\perl</B>
Lokales Verzeichnis jetzt E:\www-netzmafia\skripten\perl.
Ftp> <B>cd /opt/www/skripten/perl</B>
250 CWD command successful.
Ftp> <B>put perl3.html</B>
200 PORT command successful.
150 Opening ASCII mode data connection for perl3.html.
226 Transfer complete.
Ftp: 77604 Bytes gesendet in 9.17Sekunden 8.46KB/Sek.
Ftp> <B>put perl4.html</B>
200 PORT command successful.
150 Opening ASCII mode data connection for perl4.html.
226 Transfer complete.
Ftp: 30930 Bytes gesendet in 3.24Sekunden 9.55KB/Sek.
Ftp> <B>quit</B>
</PRE>
<P>
<H3>Active und Passive FTP</H3>
Beim FTP-Zugriff werden zwei Modi unterschieden, active und passive FTP.
Beim <b>active mode FTP</b> &ouml;ffnet der Client eine Verbindung von einem
unprivilegierten Port (Portnummer N > 1023) zum Kommandoport 21 des
FTP-Servers. Dann spezifiziert der Client den Port N+1 als Datenport
(PORT-Kommando). Der Server schickt seine Daten an den spezifizierten 
Port des Client von seinem Port 20 aus.
Aus Sicht eines vorgeschalteten Firewall-Systems m&uuml;ssen demnach folgende
Ports offen sein:
<UL>
<LI>FTP Serverport 21 von allen Ports ausserhalb (Client initiert die Verbindung)
<LI>FTP Serverport 21 an Ports > 1023 (Server-Antwort auf Kommandos)
<LI>FTP Serverport 20 an Ports > 1023 (Datenverbindung, Aufbau von Serverseite)
<LI>FTP Serverport 20 von Ports > 1023 (Datenverbindung, Best&auml;tigung vom Client)
</UL>
Sperrt ein Firewall im Netz des Client den Verbindungsaufbau von au&szlig;en, ist keine 
Daten&uuml;bertragung m&ouml;glich (wohl aber die Kommandoverbindung).
<P>
<IMG SRC="akt_pas_ftp.gif" aling="center">
<P>

Zur L&ouml;sung dieses Problems kann der FTP-Client mit dem Befehl PASV
in das <b>passive mode FTP</b> umgeschaltet werden. Der Client initiert
nun Kommando- und Datenverbindung. Nach dem Umschalten in den passiven
Modus, bietet der Server einen unprivilegierten Port > 1023 an, den
der Client dann f&uuml;r den Datentransfer ansprechen kann.
Aus Sicht eines vorgeschalteten Firewall-Systems m&uuml;ssen demnach folgende
Ports offen sein:
<UL>
<LI>FTP Serverport 21 von allen Ports ausserhalb (Client initiert die Verbindung)
<LI>FTP Serverport 21 an Ports > 1023 (Server-Antwort auf Kommandos)
<LI>FTP Serverport > 1023 von &uuml;berall (Datenverbindung, Aufbau von Clientseite)
<LI>FTP Serverport > 1023 an Ports > 1023 (Datenverbindung, Best&auml;tigung vom Server)
</UL>
Wenn auch nun die Probleme auf der Cleintseite gel&ouml;st sind, sind sie nun auf
der Serverseite vorhanden. Der FTP-Server mu&szlig; im Passivmodus alle Verbindungen
von anderen Systemen auf Ports > 1023 zulassen. Um hier die Sicherheit zu
verbessern, kann man bei etlichen Serverprogrammen den Portbereich per
Konfiguration einschr&auml;nken.
<P>
Manche FTP-Clients k&ouml;nnen nicht in den Passivmodus schalten, es bleibt dann nur 
die Wahl eines anderen Programms. Dagegen k&ouml;nnen die Webbrowser im Passivmodus
arbeiten (und tun dies meist per Default).


<A NAME="9.6"></A>
<H2>HTTP - Hypertext Transfer Protocol</H2>

HTTP ist ein Protokoll der Applikationsschicht, das alle M&ouml;glichkeiten
der &Uuml;bertragung von Hypermedia-Informationen bietet. HTTP ist nicht 
Hardware- oder Betriebssystemabh&auml;ngig. Seit 1990 ist dieses Protokoll 
im Einsatz und wird derzeit meist in der Version 'HTTP/1.1' (seltener 1.0)
verwendet.
<P>
Heutige Informationssysteme ben&ouml;tigen weit mehr Funktionen als 
das einfache Senden und Empfangen von Nachrichten. Die Entwicklung von 
HTTP ist nicht abgeschlossen. Es bietet die M&ouml;glichkeit, 
weitere Funktionalit&auml;t zu entwickeln.  Die Adressierung von Ressourcen 
erfolgt dabei mittels URls, die zum einen Orte (URL) oder Bezeichner (URN) 
sein k&ouml;nnen. Diese zeigen gleichzeitig den gew&uuml;nschten 
&Uuml;bertragungsmechanismus an. Nachrichten werden in der gleichen Form 
&uuml;bertragen, wie sie auch bei normalem Mail-Transport verwandt 
werden. Dabei kommt oft MIME zum Einsatz. HTTP/1.1 ist auch f&uuml;r 
den Zugriff auf Server mit anderen Protokollen geeignet. 
<P>

<H3>Hauptfunktionen des HTTP</H3>
Die grundlegende Funktionsweise des HTTP folgt dem alten Frage-Antwort-Spiel. 
Ein fragendes Programm (WWW-Browser) &ouml;ffnet eine Verbindung zu einem 
Programm, welches auf Fragen wartet (WWW-Server) und sendet ihm die Anfrage 
zu. Die Anfrage enth&auml;lt, die Fragemethode, die URL, die Protokollversion, 
Informationen &uuml;ber den Dienst und m&ouml;glicherweise etwas Inhalt in Form 
einer Nachricht. Der Server antwortet auf diese Frage mit einer Statusmeldung, 
auf die eine MIME-artige Nachricht folgt, die Informationen &uuml;ber den Server 
und eventuell schon das gefragte Dokument enth&auml;lt. 
<P>
<center><IMG SRC="http.gif" ALT=""></center>
<P>
Direkt nach Beantwortung der Frage wird die Verbindung wieder abgebaut. So 
soll erreicht werden, da&szlig; die Leitungskapazit&auml;ten geschont werden. 
Derzeit finden HTTP-Verbindungen meist per TCP/IP statt. Das soll aber nicht
 hei&szlig;en, da&szlig; HTTP nicht auch auf anderen Netzwerkprotokollen aufsetzen kann.
Beide Seiten m&uuml;ssen auch dazu in der Lage sein, auf den vorzeitigen Abbruch 
der Kommunikation durch die andere Seite zu reagieren. Vorzeitiger Abbruch 
kann durch Aktionen von Benutzern, Programmfehler oder &Uuml;berschreiten der 
Antwortzeiten ausgel&ouml;st werden. Durch den Abbruch der Verbindung durch eine 
der beiden Seiten wird der gesamte Vorgang abgebrochen.
<P>

<H3>Struktur der HTTP-Botschaften</H3>
Jede Kommunikation zwischen zwei WWW-Programmen besteht aus HTTP-Botschaften, 
die in Form von Anfragen und Antworten zwischen Client und Server ausgetauscht
werden. Eine HTTP-Botschaft (HTTP-Message) kann entweder ein 
<I>Simple-Request</I>, eine <I>Simple-Response</I>, ein <I>Full-Request</I> 
oder eine <I>Full-Response</I> sein. Die beiden zuerst genannten Botschaftstypen 
geh&ouml;ren zum HTTP/0.9-Standard. Die beiden letzten Typen geh&ouml;ren schon 
zum HTTP/1.0.
<P>

<H3>Allgemeinfelder des Botschaftskopfes</H3>
Jedes der Felder eines HTTP-Botschaftenkopfes weist die gleiche Struktur 
auf. Im RFC 822 wurde definiert, da&szlig; jedes Feld mit einem Feldnamen und 
dem Feldinhalt erscheint.
Auf den Feldnamen mu&szlig; unbedingt ein Doppelpunkt folgen. Der Feldname kann 
alle Zeichen au&szlig;er dem Doppelpunkt und der Escape-Sequenzen enthalten.
Allgemeinfelder enthalten Informationen wie das Datum, die Message-ID, 
die verwendete MIME-Version und ein 'forwarded'-Feld, das angibt, ob das 
Dokument eigentlich von einer anderen Adresse stammt.
<P>

<H3>Anfragen</H3>
Bei Anfragen wird zwischen einfachen und komplexen Anfragen unterschieden. 
Eine einfache Anfrage besteht nur aus einer Zeile, die angibt, welche 
Information gew&uuml;nscht wird. Ein Beispiel:
<P><PRE>
     GET http://www.netzmafia.de/index.html
</PRE><P>
Dabei wird nur die Methode (GET) und die URL des Dokumentes angegeben. Es 
werden keine weiteren Felder erwartet und vom adressierten Server wird 
auch nur ein ganz einfacher Antwortkopf zur&uuml;ckgesendet.
Es kann aber auch eine komplexere Anfrage erzeugt werden. Dabei mu&szlig; die 
Zeile aus dem obigen Beispiel noch die Version des HTT-Protokolls 
angeh&auml;ngt werden. In einem Beispiel w&uuml;rde das folgenderma&szlig;en aussehen:
<P><PRE>
     GET http://www.netzmafia.de/index.html HTTP/1.0
</PRE><P>
Die Anf&uuml;gung der HTTP-Version ist also der ganze Unterschied zwischen 
einer einfachen und einer komplexen HTTP-Anfrage. Der Unterschied zwischen 
einfacher und komplexer Anfrage wird aus Gr&uuml;nden der Kompatibilit&auml;t 
gemacht. Ein Browser, der noch das alte HTTP/0.9 implementiert hat, wird 
nur eine einfache Anfrage losschicken k&ouml;nnen. Ein neuer Server mu&szlig; 
dann eine Antwort, auch im Format des HTTP/0.9 zur&uuml;cksenden.
<P>

<H3>Felder einer komplexen Anfrage</H3>
Um die Anfrage n&auml;her zu spezifizieren, wurden weitere Felder eingef&uuml;hrt. 
In den Anfragefeldern stellen z. B. Informationen &uuml;ber den Server und 
den benutzten Browser. Weiterhin kann man dort Informationen &uuml;ber den 
Gegenstand der &Uuml;bertragung bekommen. In der folgenden kurzen &Uuml;bersicht 
sind alle m&ouml;glichen Felder einer Anfrage aufgef&uuml;hrt.
<UL>
<LI>Anfragezeile (Request-Line)<BR> 
Informationsanfrage wie oben geschildert. Die zugeh&ouml;rigen Methoden 
folgen im n&auml;chsten Abschnitt.
<LI>Allgemeiner Kopf (General-Header)<BR>
Im allgemeinen Kopf werden allgemeine Informationen &uuml;ber die Nachricht 
&uuml;bermittelt.
<LI>Anfragekopf (Request-Header)<BR>
In diesen Feldern kann der Browser weitere Informationen &uuml;ber die 
Anfrage und &uuml;ber den Browser selbst absetzen. Diese Felder sind optional 
und m&uuml;ssen nicht erscheinen. 
<LI>Gegenstandskopf (Entity-Header)<BR>
In diesem Feld werden Eintr&auml;ge &uuml;bermittelt, welche den Inhalt der 
Nachricht n&auml;her beschreiben.
<LI>Gegenstand der Nachricht (Entity-Body)<BR> 
Vor dem eigentlichen Inhalt mu&szlig; definitionsgem&auml;&szlig; eine Leerzeile stehen. 
Der Inhalt ist dann in dem Format codiert, das in den Gegenstandsfeldern 
definiert wurde (meist HTML).
</UL>
<P>

<H3>Fragemethoden</H3>
Das an erster Stelle in einer Anfragezeile (Request-Line) stehende Wort 
beschreibt die Methode, die mit der nachfolgenden URL angewendet werden 
soll. Die Methodennamen m&uuml;ssen dabei immer gro&szlig; geschrieben werden. 
Der Entwurf des HTTP-Standards erlaubt leicht eine Erweiterung. 
Kommen wir nun zur Bedeutung der einzelnen Methoden.
<UL>
<LI>GET<BR> 
Diese Methode gibt an, da&szlig; alle Informationen, die mit der nachfolgenden 
URL beschrieben werden, zum rufenden Client geholt werden sollen. Zeigt 
die URL auf ein Programm (CGI-Script), dann soll dieses Programm gestartet 
werden und die produzierten Daten liefern. Handelt es sich bei dem 
referenzierten Datum um eine Datei, dann soll diese &uuml;bertragen werden.
Beispiel:
<P><PRE>
     GET http://www.netzmafia.de/index.html
</PRE><P>
<LI>HEAD<BR> 
Diese Methode ist identisch zur Methode GET. Die Antworten unterscheiden 
sich nur darin, da&szlig; bei der Methode GET ein komplettes Dokument &uuml;bertragen 
wird und bei HEAD nur die Meta-Informationen gesendet werden. Dies ist 
n&uuml;tzlich, um Links auszuprobieren oder um die Erreichbarkeit von 
Dokumenten zu testen. Bei Anwendung der Methode HEAD wird der Kopf des 
referenzierten HTML-Dokuments nach 'link' und 'meta' Elementen durchsucht.
<P>
<LI>POST<BR> 
Diese Methode wird haupts&auml;chlich f&uuml;r gr&ouml;&szlig;ere Datenmengen verwandt. Man 
stelle sich vor, ein HTML-Dokument enth&auml;lt ein komplexes Formular. Per 
POST wird dem Server angezeigt, da&szlig; er auch die Daten im K&ouml;rper der 
Botschaft bearbeiten soll.<BR>
Verwendet, wird es haupts&auml;chlich bei Datenbl&ouml;cken, die zu einem 
verarbeitenden Programm &uuml;bertragen werden. Die wirkliche Funktion, die 
durch POST auf dem adressierten Rechner angesto&szlig;en wird, wird durch die 
URL bestimmt. Meist, sind es CGI-Scripte, die den Inhalt der Nachricht 
verarbeiten. 
<P>
<LI>PUT<BR> 
Die mit der Methode PUT &uuml;bertragenen Daten sollen unter der angegeben 
URL gespeichert werden. Das soll erm&ouml;glichen, da&szlig; WWW-Seiten auch ohne 
direkten Zugriff auf den anbietenden Rechner erstellt und angeboten 
werden k&ouml;nnen. Wird ein Dokument mit der Methode PUT &uuml;bertragen, dann 
wird unter dieser Adresse ein Dokument mit dem &uuml;bertragenen Inhalt 
angelegt. War die Aktion erfolgreich, wird die Meldung '200 created' 
zur&uuml;ckgegeben. Existiert unter dieser Adresse schon ein Dokument, dann 
wird dieses &uuml;berschrieben. War auch diese Aktion erfolgreich, dann wird 
nur '200 OK' zur&uuml;ckgemeldet.<BR>
Der Hauptunterschied zwischen POST und PUT besteht darin, da&szlig; bei POST 
die URL eine Adresse eines Programmes referenziert, das mit den Daten 
umgehen kann. Bei PUT hingegen wird die URL als neue Adresse des 
Dokumentes gesehen, das gerade &uuml;bertragen wurde. Meist jedoch ist die 
Methode PUT ausgeschaltet, weil Server-Betreiber bef&uuml;rchten, da&szlig; die 
Sicherheit, des Systems dadurch nicht mehr gew&auml;hrleistet ist.
<P>
<LI>DELETE<BR> 
Mit dieser Methode kann der Inhalt einer URI (Unified Resource Identifier) gel&ouml;scht 
werden. Diese  Methode ist neben der Methode PUT eine der gef&auml;hrlichsten. Wenn Server 
nicht richtig konfiguriert wurden, dann kann es mitunter vorkommen, da&szlig; 
alle Welt die Berechtigung zum L&ouml;schen von Ressourcen hat.
<P>
<LI>LINK<BR> 
Mit dieser Methode k&ouml;nnen eine oder mehrere Verbindungen zwischen 
verschiedenen Dokumenten erzeugt werden. Es werden dabei keine 
Dokumente erstellt, sondern nur schon bestehende miteinander verbunden.
<P>
<LI>UNLINK<BR> 
entfernt Verbindungen zwischen verschieden Ressourcen. Dabei wird nur 
die Verbindung gel&ouml;scht. Die Dokumente existieren trotzdem weiter.
Mit diesen Methoden kann man alle m&ouml;glichen Ressourcen erreichen, 
welche die verschiedenen Server zur Verf&uuml;gung stellen. Die folgenden 
Felder beschreiben nun die Fragen etwas genauer. Es kann zum Beispiel 
verhindert werden, da&szlig; ungewollt umfangreiche Bilder &uuml;bermittelt werden, 
wenn dies nicht gew&uuml;nscht wird.
</UL>
<P>

<H3>Beispiel einer Konversation</H3>
Benutzereingaben werden kursiv geschrieben. Das lokale System ist eine Windows-Kiste.
<P>
<PRE> 
<I>plate@lx3-lbs:~ > telnet www.netzmafia.de 80</I>
Trying 141.39.253.210...
Connected to www.netzmafia.de.
Escape character is '^]'.
<I>GET /index.html HTTP/1.0</I>

HTTP/1.1 200 OK
Date: Mon, 18 Sep 2000 13:59:58 GMT
Server: Apache/1.3.6 (Unix)  (SuSE/Linux)
Last-Modified: Tue, 29 Aug 2000 08:08:58 GMT
ETag: "134015-8e8-39ab6f9a"
Accept-Ranges: bytes
Content-Length: 2280
Connection: close
Content-Type: text/html

&lt;HTML&gt;
&lt;HEAD&gt;
&lt;TITLE&gt;Netzmafia&lt;/TITLE&gt;
&lt;/HEAD&gt;

&lt;body bgcolor="#000000" text="#FFFFCC" link="#FFCC00" 
       alink="#FF0000" vlink="#FF9900"&gt;

       ...


&lt;/BODY&gt;
&lt;/HTML&gt;
Connection closed by foreign host.
</PRE>
<P>

<CENTER><TABLE BORDER=0 WIDTH="100%">
<TR>
<TD VALIGN=TOP ALIGN=LEFT VALIGN=BOTTOM><IMG SRC="left.gif" BORDER=0> <A HREF="netz8.html">Zum vorhergehenden Abschnitt</A></TD>
<TD VALIGN=TOP ALIGN=CENTER VALIGN=BOTTOM><IMG SRC="up.gif" BORDER=0> <A HREF="index.html">Zum Inhaltsverzeichnis</A></TD>
<TD VALIGN=TOP ALIGN=RIGHT VALIGN=BOTTOM><IMG SRC="right.gif" BORDER=0> <A HREF="netz10.html">Zum n&auml;chsten Abschnitt</A></TD>
</TR></TABLE></CENTER>
<P><HR>
<h6><i>Copyright &copy; Hochschule M&uuml;nchen, FK 04, Prof. J&uuml;rgen Plate</i><br>
Letzte Aktualisierung: <SCRIPT LANGUAGE="JavaScript">document.write(document.lastModified);</SCRIPT></I></H6>
</BODY>
</HTML>
