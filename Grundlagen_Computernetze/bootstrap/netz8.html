<!DOCTYPE HTML PUBLIC "-;W3C;DTD HTML 4.01 Transitional;EN">
<html>
<head>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<meta NAME="robots" CONTENT="all">
<meta NAME="revisit-after" CONTENT="10 days">
<meta NAME="Reply-To" CONTENT="webmaster@netzmafia.de">

<meta NAME="keywords" CONTENT="LAN WAN TCP/IP Computernetze Ethernet Vernetzung Router Hub Switch Protokolle">
<meta NAME="description" CONTENT="Praxisorientierte Einf&uuml;hrung in den Aufbau und die Funktionsweise von Computernetzen.">
<title>Grundlagen Computernetze</title>
</head>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" ALINK="#FF0000" VLINK="#FF00FF">
<CENTER><TABLE BORDER=0 WIDTH="90%" >
<TR><TD ALIGN=LEFT><IMG SRC="eyes.gif"></TD>
<TD ALIGN=RIGHT><H3>Grundlagen Computernetze</H3>
<BR><B><I>Prof. J&uuml;rgen Plate</I></B></TD></TR>
</TABLE></CENTER>
<HR>

<A NAME="8.1"></A>
<h1 align=center>TCP/IP</h1>

Die Protokolle der TCP/IP-Familie wurden in den 70-er Jahren f&uuml;r den
Datenaustausch in heterogenen Rechnernetzen (d. h. Rechner verschiedener
Hersteller mit unterschiedlichen Betriebssystemen) entwickelt. TCP steht
f&uuml;r 'Transmission Control Protocol' (Schicht 4) und IP f&uuml;r 'Internet
Protocol' (Schicht 3).  Die Protokollspezifikationen sind in sogenannten
RFC-Dokumenten (RFC - Request for Comment) festgeschrieben und ver&ouml;ffentlicht.
Aufgrund ihrer Durchsetzung stellen sie Quasi-Standards dar.
<P>
<CENTER><IMG SRC="tcpipiso.gif"></CENTER>
<P>
Die Schichten 5 - 7 des OSI-Standards werden hier in einer Anwendungsschicht
zusammengefa&szlig;t, da die Anwendungsprogramme alle direkt mit der
Transportschicht kommunizieren.
<P>
In Schicht 4 befindet sich au&szlig;er TCP, welches gesicherten Datentransport
(<B>verbindungsorientiert</B>, mit Flu&szlig;kontrolle (d. h.
Empfangsbest&auml;tigung, etc.)  durch Windowing erm&ouml;glicht,
auch UDP (User Datagram Protocol), in welchem verbindungsloser und ungesicherter
Transport festgelegt ist. Beide Protokolle erlauben durch die Einf&uuml;hrung
von sogenannten Ports den Zugriff mehrerer Anwendungsprogramme gleichzeitig
auf ein- und dieselbe Maschine.
<P>
In Schicht 3 ist das <B>verbindungslose</B> Internet-Protokoll (IP) angesiedelt.
Datenpakete werden auf den Weg geschickt, ohne da&szlig; auf eine
Empfangsbest&auml;tigung gewartet werden mu&szlig;. IP-Pakete d&uuml;rfen unter
bestimmten Bedingungen (TTL=0, siehe unten) sogar vernichtet werden.
In Schicht 3 werden damit auch die IP-Adressen festgelegt. Hier findet auch das Routing,
das hei&szlig;t die Wegsteuerung eines Paketes von einem Netz ins andere
statt. Ebenfalls in diese Ebene integriert sind die ARP-Protokolle (ARP
- Address Resolution Protocol), die zur Aufl&ouml;sung (= Umwandlung) einer
logischen IP-Adresse in eine physikalische (z. B. Ethernet-) Adresse dienen
und dazu sogenannte Broadcasts (Datenpakete, durch die alle angeschlo&szlig;enen
Stationen angesprochen werden) verwenden. ICMP, ein Protokoll, welches den
Austausch von Kontroll- und Fehlerpaketen im Netz erm&ouml;glicht, ist ebenfalls
in dieser Schicht realisiert. <BR>
<P>
Die Schichten 1 und 2 sind gegen&uuml;ber Schicht 3 protokolltransparent.
 Sie k&ouml;nnen durch standardisierte Protokolle (z. B. Ethernet (CSMA/CD),
FDDI, SLIP (Serial Line IP), PPP (Point-to-Point Protocol)) oder andere
&Uuml;bertragungsverfahren realisiert werden.
<P>
<CENTER><IMG SRC="tcpstac.gif"></CENTER>
<P>
Zur TCP/IP-Familie geh&ouml;ren mehrere Dienstprogramme der h&ouml;heren
OSI-Schichten (5 - 7), z. B.: <BR>
<UL>
<LI>Telnet (RFC 854)<BR>
Ein virtuelles Terminal-Protokoll, um vom eigenen Rechensystem einen interaktiven
Zugang zu einem anderen System zu realisieren. <BR>
<LI>FTP (RFC 959)<BR>
Dieses (File-Transfer-) Protokoll erm&ouml;glicht, die Dateidienste eines
Fremdsystems interaktiv zu benutzen sowie die Dateien zwischen den Systemen
hin und her zu kopieren. <BR>
<LI>NFS (RFC 1094)<BR>
Das Network File System erm&ouml;glicht den Zugriff auf Dateien an einem
entfernten System so, als w&auml;ren sie auf dem eigenen.  Man nennt dies
auch einen transparenten Dateizugriff.  NFS basiert auf den zur TCP/IP-Familie
geh&ouml;renden UDP- (User- Datagramm-) Protokollen (ebenfalls Schicht 4),
RFC 768. Im Unterschied zu TCP baut UDP keine gesicherten virtuellen Verbindungen
zwischen kommunizierenden Hosts auf. Aufgrund dieser Eigenschaft ist es
f&uuml;r den Einsatz in lokalen Netzen vorgesehen. <BR>
<LI>NNTP (RFC 977)<BR>
Das Network News Transfer Protocol spezifiziert Verteilung, Abfrage, Wiederauffinden
und das Absetzen von  News-Artikeln innerhalb eines Teils oder der gesamten
Internet-Gemeinschaft. Die Artikel werden in regional zentralen Datenbasen
gehalten. Einem Benutzer ist es m&ouml;glich, aus dem gesamten Angebot nur
einzelne Themen zu abonnieren. <BR>
<LI>SMTP (RFC 821/822)<BR>
Das Simple-Mail-Transfer-Protokoll (RFC 821) ist ein auf der IP-Adressierung
sowie auf der durch den RFC 822 festgelegten Namensstruktur basierendes
Mail-Protokoll. <BR>
<LI>DNS (RFC 920)<BR>
Der Domain Name Service unterst&uuml;tzt die Zuordnung von Netz- und Host-Adressen
zu Rechnernamen. Dieser Service ist z. B. erforderlich f&uuml;r die Anwendung
von SMTP sowie in zunehmendem Ma&szlig;e auch f&uuml;r Telnet und FTP.
Aus Sicherheitsgr&uuml;nden wendet sich der fremde Host an den DNS, um zu
pr&uuml;fen, ob der IP-Adresse des ihn rufenden Rechners auch ein (Domain-)Name
zugeordnet werden kann.  Falls nicht, wird der Verbindungsaufbau abgelehnt.
</UL>
<P>

<H2><A NAME="8.1">Die TCP/IP-Protokolle</A></H2>
Der gro&szlig;e Vorteil der TCP/IP-Protokollfamilie ist die einfache Realisierung
von Netzwerkverbunden. Einzelne Lokale Netze werden &uuml;ber Router oder
Gateways verbunden. Einzelne Hosts k&ouml;nnen daher &uuml;ber mehrere Teilnetze
hinweg miteinander kommunizieren.<BR>
IP als Protokoll der Ebene 3 ist die unterste Ebene, die darunter liegenden
Netzebenen k&ouml;nnen sehr unterschiedlich sein:
<UL>
<LI>LANs (Ethernet, Token-Ring, usw.)<BR>
<LI>WANs (X.25, usw.)<BR>
<LI>Punkt-zu-Punkt-Verbindungen (SLIP, PPP)<BR>
</UL>
<P>
<table border=1 CELLPADDING=3>
<tr>
   <th colspan="9">Internet-Protokolle</th>
</tr><tr>
   <td align="center" colspan="2" width="16%"><small><i>OSI-Schicht</i></small></td>
   <td align="center" colspan="6" width="72%"><small><i>Internet Protokoll Suite</i></small></td>
   <td align="center" width="12%"><small><i>DOD Schicht</i></small></td>
</tr><tr>
   <td align="center" width="4%"><small>7</small></td>
   <td align="center" width="12%"><small>Anwendung</small></td>
   <td align="center" width="12%"><small>File Transfer</small></td>
   <td align="center" width="12%"><small>Electronic<BR>Mail</small></td>
   <td align="center" width="12%"><small>Terminal Emulation</small></td>
   <td align="center" width="12%"><small>Usenet News</small></td>
   <td align="center" width="12%"><small>World Wide Web</small></td>
   <td align="center" width="12%"><small>Domain Name Service</small></td>
   <td align="center" width="12%"><small>Art der<BR>Kommuni-<BR>kation</small></td>
</tr><tr>
   <td align="center"><small>6</small></td>
   <td align="center"><small>Darstellung</small></td>
   <td align="center" rowspan="2"><small>File Transfer Protocol (FTP)<br>RFC 959</small></td>
   <td align="center" rowspan="2"><small>Simple Mail Transfer Protocol (SMTP)<br>RFC 821</small></td>
   <td align="center" rowspan="2"><small>Telnet Protocol (Telnet)<br>RFC 854</small></td>
   <td align="center" rowspan="2"><small>Usenet News Transfer Protocol (NNTP)<br>RFC 977</small></td>
   <td align="center" rowspan="2"><small>Hypertext Transfer Protocol (HTTP)<br>RFC 2616</small></td>
   <td align="center" rowspan="2"><small>Domain Name Service (DNS)<br>RFC 1034</small></td>
   <td align="center" rowspan="2"><small>Applikation</small></td>
</tr><tr>
   <td align="center"><small>5</small></td>
   <td align="center"><small>Sitzung</small></td>
</tr><tr>
   <td align="center"><small>4</small></td>
   <td align="center"><small>Transport</small></td>
   <td align="center" colspan="5"><small>Transmission Control Protocol (TCP)<br>RFC 793</small></td>
   <td align="center"><small>User Datagram Protocol (UDP)<br>RFC 768</small></td>
   <td align="center"><small>Host to Host Kommunikation</small></td>
</tr><tr>
   <td align="center"><small>3</small></td>
   <td align="center"><small>Netzwerk</small></td>
   <td align="center"><small>Address Resolution Protocol (ARP)<br>RFC 826</small></td>
   <td align="center" colspan="4"><small>Internet Protocol (IP)<br>RFC 791</small></td>
   <td align="center"><small>Internet Control Messsage Protocol<br>RFC 792</small></td>
   <td align="center"><small>Internet</small></td>
</tr><tr>
   <td align="center"><small>2</small></td>
   <td align="center"><small>Sicherung</small></td>
   <td align="center" colspan="2"><small>Ethernet</small></td>
   <td align="center"><small>Token Ring</small></td>
   <td align="center"><small>DQDB</small></td>
   <td align="center"><small>FDDI</small></td>
   <td align="center"><small>ATM</small></td>
   <td align="center"><small>lokales Netzwerk</small></td>
</tr><tr>
   <td align="center"><small>1</small></td>
   <td align="center"><small>Physikalische Übertragung</small></td>
   <td align="center"><small>Twisted Pair</small></td>
   <td align="center"><small>Lichtwellenleiter</small></td>
   <td align="center" colspan="2"><small>Coaxkabel</small></td>
   <td align="center"><small>Funk</small></td>
   <td align="center"><small>Laser</small></td>
   <td align="center"><small>Netzzugriff</small></td>
</tr></table>
<P>
Es ist offensichtlich, da&szlig; die Gateways neben dem Routing weitere
nichttriviale Funktionen haben, wenn sie zwischen den unterschiedlichsten
Teilnetzen vermitteln (z. B. unterschiedliche Protokolle auf Ebene 2, unterschiedliche
Datenpaketgr&ouml;&szlig;e, usw.).<BR>
<P>
Aus diesem Grund existieren in einem Internet drei unabh&auml;ngige Namens-
bzw. Adressierungsebenen:
<UL>
<LI>Physikalische Adressen (z. B. Ethernet-Adresse)<BR>
<LI>Internet-Adressen (Internet-Nummer, IP-Adresse)<BR>
<LI>Domain-Namen<BR>
</UL>
<P>
Die Ethernet-Adresse wurde bereits behandelt, auf die anderen beiden Ebenen
wird in den folgenden Abschnitten eingegangen. Die Umsetzung der h&ouml;chsten
Ebene (Domain-Namen) in IP-Adressen erfolgt durch das oben erw&auml;hnte
DNS, worauf die Dienstprogramme der Schichten 5-7 zur&uuml;ckgreifen.
<P>

<H2><A NAME="8.2">ARP</A></H2>
Die Umsetzung einer IP-Adresse in eine Hardware-Adresse erfolgt durch
Tabellen und auf Hardware-Ebene (z. B. Ethernet) automatisch &uuml;ber
ARP (Adress Resolution Protocol). Dazu ein Beispiel:
<P>
Die Station A will Daten an eine Station B mit der Internetadresse I(B)
senden, deren physikalische Adresse P(B) sie noch nicht kennt. Sie sendet
einem ARP-Request an alle Stationen im Netz, der die eigene physikalische
Adresse und die IP-Adresse von B enth&auml;lt.
<P>
<CENTER><IMG SRC="arp1.gif"></CENTER>
<P>
Alle Stationen erhalten und &uuml;berpr&uuml;fen den ARP-Request und die
angesprochene Station B antwortet, indem sie einen ARP-Reply mit ihrer
eigenen physikalischen Adresse an die Station A sendet. Letztere speichert
die Zuordnung in einer Tabelle (Address Resolution Cache).
<P>
<CENTER><IMG SRC="arp2.gif"></CENTER>
<P>
Auch f&uuml;r die Umkehrfunktion gibt es eine standardisierte Vorgehensweise,
den RARP (Reverse ARP). Hier sendet die Station A unter Angabe ihrer physikalischen
Adresse P(A) einen RARP-Request. Wenn im Netz nur eine Station als RARP-Server
eingerichtet ist (eine Station, die alle Zuordnungen von P(x) &lt;--&gt;
I(x) "kennt"), antwortet diese mit einem RARP-Reply an die anfragende
Station, der I(A) enth&auml;lt. Diese Funktion ist z. B. f&uuml;r sogenannte
"Diskless Workstations" wichtig, die ihre gesamte Software von
einem Server laden.<BR>
<P>
<center><IMG SRC="arp.gif" ALT=""></center>
<P>
ARP ist für den Benutzer unsichtbar, so dass das Vorhandensein dieses Protokolls  
meist nur bemerkt wird, wenn seltene Fehler auftreten. Die Dauer der Gültigkeit 
eines ARP-Eintrags (normalerweise wenige Minuten) kann ein Problem darstellen,  
wenn falsche Einträge vorhanden sind. Solange ein fehlerhafter Eintrag existiert, 
kann mit dem betreffenden Host nicht kommuniziert werden. Die Fehlfunktion wird 
häufig nicht dem ARP-Protokoll zugeschrieben, sondern dem Netz oder einem Fehler 
in der Netzwerkimplementierung. Darüber hinaus ermöglicht nicht jedes 
Betriebssystem das Erzeugen eines korrigierten Eintrags oder einer Anforderung.
Mit ARP-Spoofing ist es möglich, absichtlich eine falsche Hardwareadresse in 
einem Netz zu verteilen. Dadurch kann der Datenverkehr für einen Rechner auf 
einen anderen umgelenkt und eventuell von diesem sogar verändert werden.
<P>
<h4>Proxy ARP</h4>
Proxy ARP erlaubt es einem Router, ARP-Anforderungen für Hosts zu beantworten.
Die Hosts befinden sich dabei in durch einen Router getrennten Netzen, verwenden 
jedoch den gleichen IP-Adressenbereich. Bei der Kommunikation ist für die Hosts 
der Router <i>transparent</i>, das heißt, er braucht nicht speziell angesprochen 
zu werden, sondern die Hosts können wie gewöhnlich Pakete über verschiedene Netze 
hinweg versenden.
<p>
Sendet Computer 1 eine ARP-Anforderung an Computer 2, reagiert der dazwischen 
liegende Router anstelle des Computers 2 mit einer ARP-Antwort und der MAC-Adresse
des Ports am Router, auf dem die Anfrage empfangen wurde. Der anfragende Computer 1 
sendet dann seine Daten an den Router, der sie dann an Computer 2 weiterleitet.
<P>

<h4>Gratuitous ARP</h4>
Gratuitous ARP (engl. "unaufgefordertes ARP") bezeichnet eine spezielle 
Verwendung von ARP. Dabei sendet ein Host ein ARP-Anforderungs-Broadcast, bei dem 
er seine eigene IP-Adresse als Quell- und Ziel-IP-Adresse einträgt. Damit teilt 
er seine ggf. neue MAC-Adresse unaufgefordert mit. Das kann mehreren Zwecken dienen:
<P>
<ul>
<li>Normalerweise darf keine Antwort kommen, denn eine IP-Adresse muss in einem 
Netz eindeutig sein. Bekommt er trotzdem eine Antwort, ist das für den Administrator 
ein Hinweis darauf, dass ein Host nicht richtig konfiguriert ist.</li>
<li>Jeder Host aktualisiert seinen ARP-Cache. Das ist beispielsweise dann nützlich, 
wenn die Netzwerkkarte eines Rechners ausgetauscht wurde und die anderen Hosts 
über die neue MAC-Adresse informiert werden sollen. Gratuitous ARP geschieht deshalb 
normalerweise beim Booten eines Computers.</li>
<li>Wenn zwei Server aus Gründen der Ausfallsicherheit als Server und Ersatzserver 
aufgebaut sind (Hochverfügbarkeit, HA-Server) und sich daher eine IP-Adresse teilen.
Wird der aktive Verkehr vom einem auf den anderen Server umgeschaltet, ist 
die IP-Adresse über eine andere MAC-Adresse erreichbar. Diese neue MAC-IP-Adresskombination
muss bekannt gemacht werden. Sonst bekommt niemand den Wechsel mit.</li>
<li>In einem Mobile IP-Szenario sendet der <i>Home Agent</i> einen <i>Gratuitous ARP</i>, 
wenn sich der <i>Mobile Host</i> aus dem Heimatnetz entfernt, um die Pakete stellvertretend 
für diesen zu empfangen. Analog sendet der <i>Mobile Host</i> einen <i>Gratuitous ARP</i>, 
sobald er sich wieder im Netz befindet.</li>
</ul>
<P>

<H2><A NAME="8.3">IP - Internet Protocol</A></H2>
Auf der Netzwerkschicht aufbauend liegt die Internet-Schicht, die die erste
Abstraktionsschicht vom Transportmechanismus darstellt. Auf dieser Schicht 3 stellt
das Internet-Protokoll (IP) den grundlegenden Netzdienst zur Verf&uuml;gung,
den Versand von Datenpaketen, sogenannten Datagrammen, &uuml;ber verschiedene Netze
hinweg. Die Netzwerkschicht hat keine Information dar&uuml;ber, von welcher Art
die Daten sind, die sie bef&ouml;rdert. Nehmen wir als Beispiel das Ethernet:
Von der Ethernet-Karte werden die vom Netz kommenden Daten an die Treibersoftware
f&uuml;r die Karte weitergereicht. Diese interpretiert einen Teil dieser Daten als
IP-Header und den Rest als Datenteil eines IP-Paketes. Auf diese Weise ist der
IP-Header innerhalb eines Ethernet-Paketes eingekapselt. Aber auch das IP-Paket
selbst enth&auml;lt wieder ein Datenpaket f&uuml;r eine h&ouml;here Protokollebene
(TCP), dessen Header auf der IP-Ebene als Bestandteil der Daten erscheint. Man kann
sich das so vorstellen, wie die russischen Puppen, die ineinandergeschachtelt sind.
Die kleinste Puppe ganz innen repr&auml;sentiert die Nutzdaten, alle au&szlig;en herum
geschachtelten Puppen sind 'Protokoll-Verpackung'.
<P>
<center><img src="schichten.gif"></center>
<P>
IP ist ein <B>verbindungsloses Protokoll</B>. Es ist also nicht notwendig, eine
IP-Verbindung zu einem Rechner zu '&ouml;ffnen', bevor man Daten zu diesem Rechner
senden kann, sondern es gen&uuml;gt, das IP-Paket einfach abzusenden und darauf zu
vertrauen, da&szlig; es schon ankommen wird. Bei einem verbindungsorientierten
Protokoll wird beim &Ouml;ffnen einer Verbindung getestet, ob der Zielrechner
&uuml;berhaupt erreichbar ist. Ein verbindungsloses Protokoll macht das nicht und
kann demnach auch nicht garantieren, da&szlig; ein Datenpaket &uuml;berhaupt beim
Empf&auml;nger ankommt. IP garantiert auch nicht, da&szlig; von einem einmal
abgeschickten Datenpaket nur eine Kopie beim Empf&auml;nger ankommt oder da&szlig;
in einer bestimmten Reihenfolge abgeschickte Datenpakete auch wieder in dieser
Reihenfolge empfangen werden.<BR>
Normalerweise laufen die IP-Pakete &uuml;ber mehrere Zwischenstationen, bis sie
am Zielrechner ankommen. Bricht irgendwann w&auml;hrend der &Uuml;bertragung ein
&Uuml;bertragungsweg zusammen, so wird ein neuer Weg zum Ziel gesucht und benutzt.
Da der neue Weg zeitlich l&auml;nger oder k&uuml;rzer sein kann als der alte, kann
man keine allgemeing&uuml;ltigen Aussagen dar&uuml;ber machen, in welcher Reihenfolge
IP-Pakete beim Empf&auml;nger eintreffen. Es kann auch sein, da&szlig; bei dieser
Umschalterei IP-Pakete verlorengehen oder sich verdoppeln. Das Beheben der so
entstehenden Probleme &uuml;berl&auml;&szlig;t das IP-Protokoll anderen,
h&ouml;herliegenden Schichten.
<P>
Das Internet-Protokoll ist somit ein <B>verbindungsloser</B> Dienst
mit einem 'Unreliable Datagram Service', d. h. es wird auf der IP-Ebene
weder die Richtigkeit der der Daten noch die Einhaltung von Sequenz, Vollst&auml;ndigkeit
und Eindeutigkeit der Datagramme &uuml;berpr&uuml;ft. Ein zuverl&auml;ssiger
verbindungsorientierter Dienst wird in der dar&uuml;berliegenden TCP-Ebene
realisiert.
<P>
Ein IP-Datagramm besteht aus einem Header und einem nachfolgenden Datenblock,
der seinerseits dann z. B. in einem Ethernet-Frame "verpackt"
wird. Die maximale Datenl&auml;nge wird auf die maximale Rahmenl&auml;nge
des physikalischen Netzes abgestimmt. Da nicht ausgeschlossen werden kann,
da&szlig; ein Datagramm auf seinem Weg ein Teilnetz passieren mu&szlig;,
dessen Rahmenl&auml;nge niedriger ist, m&uuml;ssen zum Weitertransport mehrere
(Teil-)Datagramme erzeugt werden. Dazu wird der Header im Wesentlichen repliziert
und die Daten in kleinere Bl&ouml;cke unterteilt. Jedes Teil-Datagramm hat
also wieder einen Header. Diesen Vorgang nennt man Fragmentierung. Es handelt
sich um eine rein netztechnische Ma&szlig;nahme, von der Quell- und Zielknoten
nichts wissen m&uuml;ssen. Es gibt nat&uuml;rlich auch eine umgekehrte Funktion,
"Reassembly", die kleine Datagramme wieder zu einem gr&ouml;&szlig;eren
packt. Geht auf dem &Uuml;bertragungsweg nur ein Fragment verloren, mu&szlig;
das gesamte Datagramm wiederholt werden. Es gilt die Empfehlung, da&szlig;
Datagramme bis zu einer L&auml;nge von 576 Bytes unfragmentiert &uuml;bertragen
werden sollten.<BR>
<P>

<H4>Format des IP-Headers</H4>
<P>
<center><IMG SRC="ip.gif" ALT=""></center>
<P>
<DL>
<DT>Version
<DD>Kennzeichnet die IP-Protokollversion

<DT>IHL (Internet Header Length)
<DD>Die Angabe der L&auml;nge des IP-Headers erfolgt
in 32-Bit-Worten (normalerweise 5). Da die Optionen nicht unbedingt auf
Wortl&auml;nge enden, wird der Header gegebenenfalls aufgef&uuml;llt.

<DT>Type of Service
<DD>Alle Bits haben nur "empfehlenden" Charakter. 'Precedence' bietet
die M&ouml;glichkeit, Steuerinformationen vorrangig zu bef&ouml;rdern.

<DT>Total Length
<DD>Gesamtl&auml;nge des Datagramms in Bytes (max. 64 KByte).

<DT>Identification
<DD>Dieses und die beiden folgenden Felder steuern die Reassembly. Eindeutige
Kennung eines Datagramms. Anhand dieses Feldes und der 'Source Address'
ist die Zusammengeh&ouml;rigkeit von Fragmenten zu detektieren.

<DT>Flags
<DD>Die beiden niederwertigen Bits haben folgende Bedeutung:
<UL>
<LI>Don't fragment: F&uuml;r Hosts, die keine Fragmentierung unterst&uuml;tzen
<LI>More fragments: Zum Erkennen, ob alle Fragmente eines Datagramms empfangen wurden
</UL>

<DT>Fragment Offset
<DD>Die Daten-Bytes eines Datagramms werden numeriert und auf die Fragmente
verteilt. Das erst Fragment hat Offset 0, f&uuml;r alle weiteren erh&ouml;ht
sich der Wert um die L&auml;nge des Datenfeldes eines Fragments. Anhand
dieses Wertes kann der Empf&auml;nger feststellen, ob Fragmente fehlen.
Beispiel siehe unten.

<DT>Time-to-live (TTL)
<DD>Jedes Datagramm hat eine vorgegebene maximale Lebensdauer, die hier angegeben
wird. Auch bei Routing-Fehlern (z. B. Schleifen) wird das Datagramm irgendwann
aus dem Netz entfernt. Da Zeitmessung im Netz problematisch ist, und keine
Startzeit im Header vermerkt ist, decrementiert jeder Gateway dieses Feld
--&gt; de-facto ein 'Hop Count'.

<DT>Protocol
<DD>Da sich unterschiedliche Protokolle auf IP st&uuml;tzen, mu&szlig; das &uuml;bergeordnete
Protokoll (ULP, Upper Layer Protocol) angegeben werden. Wichtige ULPs sind
<UL>
<LI>1:   ICMP Internet Control Message P.
<LI>3:   GGP  Gateway-to-Gateway P.
<LI>6:   TCP  Transmission Control P.
<LI>8:   EGP  Exterior Gateway P.
<LI>17:   UDP  User Datagram P.
</UL>

<DT>Header Checksum
<DD>16-Bit-L&auml;ngsparit&auml;t &uuml;ber den IP-Header (nicht die Daten)

<DT>Source Address
<DD>Internet-Adresse der Quellstation

<DT>Destinantion Address
<DD>Internet-Adresse der Zielstation

<DT>Options
<DD>Optionales Feld f&uuml;r weitere Informationen (deshalb gibt es auch die
Header-L&auml;nge). Viele Codes sind f&uuml;r zuk&uuml;nftige Erweiterungen
vorgesehen. Die Optionen dienen vor allem der Netzsteuerung, der Fehlersuche
und f&uuml;r Messungen. Die wichtigsten sind:
<UL>
<LI>Record Route: Weg des Datagramms mitprotokollieren
<LI>Loose Source Routing: Die sendende Station schreibt einige Zwischenstationen
vor (aber nicht alle)
<LI>Strict Source Routing: Die sendende Station schreibt alle Zwischenstationen
vor.
<LI>Timestamp Option: Statt seiner IP-Adresse (wie bei Record Route) tr&auml;gt
jeder Gateway den Bearbeitungszeitpunkt ein (Universal Time).
</UL>

<DT>Padding
<DD>F&uuml;llbits
</DL>
<P>
Die Hauptaufgabe von IP ist es also, die Unterschiede zwischen den verschiedenen,
darunterliegenden Netzwerkschichten zu verbergen und eine einheitliche Sicht auf die
verschiedensten Netztechniken zu pr&auml;sentieren. So gibt es IP nicht nur in Netzen,
sondern auch als SLIP (Serial Line IP) oder PPP (Point to Point Protocol) f&uuml;r
Modem- oder ISDN-Verbindungen. Zur Vereinheitlichung geh&ouml;ren auch die
Einf&uuml;hrung eines einheitlichen Adressierungsschemas und eines
Fragmentierungsmechanismus, der es erm&ouml;glicht, gro&szlig;e
Datenpakete durch Netze mit kleiner maximaler Paketgr&ouml;&szlig;e
zu senden: Normalerweise existiert bei allen Netzwerken eine maximale
Gr&ouml;&szlig;e f&uuml;r ein Datenpaket. Im IP-Jargon nennt man
diese Grenze die 'Maximum Transmisson Unit' (MTU). Nat&uuml;rlich ist
diese Obergrenze je nach verwendeter Hardware bzw. &Uuml;bertragungstechnik
unterschiedlich. Die Internet-Schicht teilt IP-Pakete, die gr&ouml;&szlig;er
als die MTU des verwendeten Netzwerks sind, in kleinere St&uuml;cke,
sogenannte Fragmente, auf. Der Zielrechner setzt diese Fragmente dann wieder zu
vollst&auml;ndigen IP-Paketen zusammen, bevor er sie an die dar&uuml;berliegenden
Schichten weitergibt. Der Fragement Offset gibt an, an welcher Stelle in Bezug auf
den IP-Datagramm-Anfang das Paket in das Datagramm einzuordnen ist. Aufgrund des
Offset werden die Pakete in die richtige Reihenfolge gebracht. Dazu ein Beispiel:
<P>
Es soll ein <B>TCP</B>-Paket mit einer L&auml;nge von 250 Byte &uuml;ber
<B>IP</B> versandt werden. Es wird angenommen, da&szlig; ein IP-Header eine L&auml;nge von
20 Byte hat und eine maximale L&auml;nge von 128 Byte pro Paket nicht &uuml;berschritten
werden darf Der Identifikator des Datagramms betr&auml;gt 43 und der Fragmentabstand wird
in 8-Byte-Schritten gez&auml;hlt. Das Datenfragment mu&szlig; also durch 8 dividierbar
sein.
<P>
<CENTER><IMG SRC="fragment.gif"></CENTER>
<P>
Da alle Fragmente demselben Datagramm angeh&ouml;ren, wird der Identifikator f&uuml;r alle
Fragmente beibehalten. Im ersten Fragment ist das Fragment Offset nat&uuml;rlich noch
Null, das MF-Bit jedoch auf 1 gesetzt, um zu zeigen, da&szlig; noch Fragmente
folgen. Im IP-Header des zweiten Fragments betr&auml;gt das Fragment Offset 13
(104/8 = 13) und zeigt die Position des Fragments im Datagramm an. Das MF-Bit ist
noch immer 1, da noch ein Datenpaket folgt. Der Header des dritten Fragments
enth&auml;lt dann ein MF-Bit mit dem Wert 0, denn es handelt sich um das letzte
Datenpaket zum Datagramm 43. Das Fragment Offset ist auf 26 gesetzt, da vorher schon
208 Daten-Bytes (8 * 26 = 208) &uuml;bertragen wurden.<BR>
Sobald das erste Fragment (gleich welches) im Empf&auml;nger ankommt,
wird ein Timer gesetzt. Sind innerhalb der dort gesetzten Zeit nicht alle Pakete zu einem
Datagramm eingetroffen, wird angenommen, da&szlig; Fragmente verlorengingen. Der
Empf&auml;nger verwirft dann alle Datenpakete mit diesem Identifikator.
<P>
Was geschieht aber, wenn der Kommunikationspartner nicht erreichbar ist? Wie schon
erw&auml;hnt, durchl&auml;uft ein Datagramm mehrere Stationen. Diese Stationen sind in
der Regel Router oder Rechner, die gleichzeitig als Router arbeiten. Ohne
Gegenma&szlig;nahme w&uuml;rde das Datenpaket f&uuml;r alle Zeiten durch das Netze
der Netze irren. Dazu gibt es im IP-Header neben anderer Verwaltungsinfo auch ein
Feld mit dem Namen TTL (Time To Live). Der Wert von TTL kann zwischen 0 und 255
liegen. Jeder Router, der das Datagramm transportiert, vermindert den Wert dieses
Feldes um 1. Ist der Wert von TTL bei Null angelangt, wird das Datagramm vernichtet.
<P>
Die Adressen, die im Internet verwendet werden, bestehen aus einer 32 Bit langen Zahl.
Damit sich die Zahl leichter darstellen l&auml;&szlig;t, unterteilt man sie in 4 Bytes
(zu je 8 Bit). Diese Bytes werden dezimal notiert und durch Punkte getrennt (a.b.c.d).
Zum Beispiel:
<pre>
    141.84.101.2
    129.187.10.25
</pre>
Bei dieser Adresse werden zwei Teile unterscheiden, die Netzwerkadresse und die
Rechneradresse, wobei unterschiedlich viele Bytes f&uuml;r beide Adressen verwendet
werden:<br>
Die Bereiche f&uuml;r die Netzwerkadresse ergeben sich durch die Zuordnung der
ersten Bits der ersten Zahl (a), die eine Erkennung der Netz-Klassen
m&ouml;glich machen.
<p>
<H4>Netzklassen</H4>
<P>
<CENTER><IMG SRC="netzklassen.gif"></CENTER>
<P>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADDING=4>
<TR><TD VALIGN="TOP" >&nbsp;</TD>
<TD VALIGN="TOP" ><b>Klasse A</b> - Netz</TD>
<TD VALIGN="TOP" ><b>Klasse B</b> - Netz</TD>
<TD VALIGN="TOP" ><b>Klasse C</b> - Netz</TD>
</TR>
<TR><TD VALIGN="TOP" >Netz-ID</TD>
<TD VALIGN="TOP">8 Bit = 1 Byte</TD>
<TD VALIGN="TOP">16 Bit = 2 Byte</TD>
<TD VALIGN="TOP">24 Bit = 3 Byte</TD>
</TR>
<TR><TD VALIGN="TOP" >Host-ID</TD>
<TD VALIGN="TOP">24 Bit = 3 Byte</TD>
<TD VALIGN="TOP">16 Bit = 2 Byte</TD>
<TD VALIGN="TOP">8 Bit = 1 Byte</TD>
</TR>
<TR><TD VALIGN="TOP" >Netzmaske</TD>
<TD VALIGN="TOP">255.0.0.0</TD>
<TD VALIGN="TOP">255.255.0.0</TD>
<TD VALIGN="TOP">255.255.255.0</TD>
</TR>
<TR><TD VALIGN="TOP" >Adressklassen-ID<BR>
(= Feste Bits im 1. Byte, 1. Quad)</TD>
<TD VALIGN="TOP">0</TD>
<TD VALIGN="TOP">10</TD>
<TD VALIGN="TOP">110</TD>
</TR>
<TR><TD VALIGN="TOP" >Wertebereich (theoretisch)</TD>
<TD VALIGN="TOP">0.0.0.0 bis 127.255.255.255</TD>
<TD VALIGN="TOP">128.0.0.0 bis 191.255.255.255</TD>
<TD VALIGN="TOP">192.0.0.0 bis 223.255.255.255</TD>
</TR>
<TR><TD VALIGN="TOP" >Anzahl der Netze</TD>
<TD VALIGN="TOP">128 (= 2<B><SUP>7</B></SUP>)</TD>
<TD VALIGN="TOP">16384 (= 2<B><SUP>6</B></SUP>*256 <BR>= 64*256)</TD>
<TD VALIGN="TOP">2097152 (= 2<B><SUP>5</B></SUP>*256*256 <BR>= 32*256*256)</TD>
</TR>
<TR><TD VALIGN="TOP" >Anzahl der Rechner <BR>im Netz</TD>
<TD VALIGN="TOP">16777216 (= 256<B><SUP>3</B></SUP>)</TD>
<TD VALIGN="TOP">65536 (= 256<B><SUP>2</B></SUP>)</TD>
<TD VALIGN="TOP">256 (= 256<B><SUP>1</B></SUP>)</TD>
</TR>
</TABLE>
<p>

<H4>Besondere Adre&szlig;klassen</H4>
<P>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADDING=4>
<TR><TD VALIGN="TOP" >&nbsp;</TD>
<TD VALIGN="TOP" ><B>Klasse D</B></TD>
<TD VALIGN="TOP" ><B>Klasse E</B></TD>
</TR>
<TR><TD VALIGN="TOP" >Adressklassen-ID</TD>
<TD VALIGN="TOP">4 Bit = "1110"</TD>
<TD VALIGN="TOP">5 Bit = "11110"</TD>
</TR>
<TR><TD VALIGN="TOP" >keine Netz-ID, sondern:</TD>
<TD VALIGN="TOP">28 Bit-Identifikator</TD>
<TD VALIGN="TOP">27 Bit-Identifikator</TD>
</TR>
<TR><TD VALIGN="TOP" >Wertebereich</TD>
<TD VALIGN="TOP">224.0.0.0 bis 239.255.255.255</TD>
<TD VALIGN="TOP">240.0.0.0 bis 247.255.255.255</TD>
</TR>
<TR><TD VALIGN="TOP" >Anwendungen</TD>
<TD VALIGN="TOP">f&uuml;r Multicast-Gruppen</TD>
<TD VALIGN="TOP">reservierte Adressen f&uuml;r Zuk&uuml;nftiges</TD>
</TR>
</TABLE>
<p>
Grunds&auml;tzlich gilt:
<UL>
<LI>Alle Rechner mit der gleichen Netzwerkadresse geh&ouml;ren zu einem
Netz und sind untereinander erreichbar.
<LI>Zur Koppelung von Netzen unterschiedlicher Adresse wird eine spezielle Hardware-
oder Softwarekomponente, ein sogenannter Router, ben&ouml;tigt.
<LI>Je nach Zahl der zu koppelnden Rechner wird die Netzwerkklasse gew&auml;hlt.
</UL>
In einem Netz der Klasse C k&ouml;nnen z. B. 254 verschiedene Rechner gekoppelt
werden (Rechneradresse 1 bis 254). Die Hostadresse 0 wird f&uuml;r die Identifikation
des Netzes ben&ouml;tigt und die Adresse 255 f&uuml;r Broadcast-(Rundruf-)Meldungen.
<P>
<CENTER><IMG SRC="aufteilung.gif"></CENTER>
<P>
<UL>
<LI>Die Netzwerkadresse 127.0.0.1 bezeichnet jeweils den lokalen Rechner (loopback address).
Sie dient der Konsistenz der Netzwerksoftware (jeder Rechner ist &uuml;ber
seine Adresse ansprechbar) und dem Test (eigentlich wird hier ein ganzes C-Netz
belegt, n&auml;mlich 127.0.0.x).
</UL>
<P>
Damit man nun lokale Netze ohne Internetanbindung mit TCP/IP betreiben kann, ohne
IP-Nummern beantragen zu m&uuml;ssen und um auch einzelne Rechnerverbindungen
testen zu k&ouml;nnen, gibt es einen ausgesuchten Nummernkreis, der von keinem
Router nach au&szlig;en gegeben wird. Diese "privaten" Adressen sind im RFC 1597
festgelegt. Es gibt ein Class-A-Netz, 16 Class-B-Netze und 255 Class-C-Netze:
<UL>
<LI>Class-A-Netz: 10.0.0.0 - 10.255.255.255
<LI>Class-B-Netze: 172.16.0.0 - 172.31.255.255
<LI>Class-C-Netze: 192.168.0.0 - 192.168.255.255
</UL>
<P>
Zus&auml;tzlich hat die IANA auch das folgende Class-B-Netz f&uuml;r private
Netze reserviert, das schon von Apple- und Microsoft-Clients verwendet wird, sofern
kein DHCP-Server zur Verf&uuml;gung steht. Das Verfahren hei&szlig;t APIPA (Automatic 
Private IP Addressing):
<UL>
<LI>169.254.0.0 - 169.254.255.255
</UL>
<P>
Weitere Adressen mit speziellen Aufgaben sind:
<UL>
<LI>100.64.0.0 - 100.127.255.255: Adressbereich für Carrier Grade NAT (CGN, RFC 6264). Aus diesem 
Bereich teilen Internet-Provider ihren Kunden Adressen zu, wenn ihnen die &ouml;ffentlichen 
IP-Adressen ausgegangen sind.
<LI>192.0.0.0 - 192.0.0.255 sind reserviert. Das Netz wird bei Bedarf 
in das Vergabeverfahren übernommen. 
<LI>192.0.2.0 - 192.0.2.255, 198.51.100.0 - 198.51.100.255 und 203.0.113.0 - 203.0.113.255 
sind reserviert als Beispieladressen in Dokumentationen (wie die Domain-Namen "example.com" 
und "example.net"). Adressen aus diesem Bereich dürfen nicht im &ouml;ffentlichen Internet
auftauchen.
<LI>192.88.99.0 - 192.88.99.255 sind Adressen für die Verbindung von IPv6-Netzwerken 
über IPv4 ("6to4 anycast address").
<LI>198.18.0.0 - 198.19.255.255 sind Adressen für den Test von Netzwerkkomponenten.
</UL
<P>
Der f&uuml;r IP reservierte Adressraum reicht nicht mehr aus, um alle
Endger&auml;te anzusteuern. M&ouml;gliche Abhilfen:
<ul>
<li>Dynamische Vergabe von IP-Adressen: Dieses Verfahren wird beim Dial-In beim
Provider verwendet. Es eignet sich auch im lokalen Netz, wenn davon auszugehen ist,
da&szlig; immer nur ein Teil der Rechner in Betrieb ist. Der Benutzer bekommt f&uuml;r
die Dauer einer Verbindung eine IP-Adresse zugeteilt. Das bekannteste Verfahren
hei&szlig;t DHCP (dynamic host configuration protocol).
<li>Weiterentwicklung des IP-Protokolls: Mit IP Version 6 wird ein auf 128 Bit
erweiterter Adressraum geschaffen. Damit stehen gen&uuml;gend Adressen zur Vef&uuml;gung.
<li>Network Address Translation (NAT): &Uuml;ber ein Gateway wird im Internet
eine andere IP-Adresse verwendet als im lokalen Netz (private Adressr&auml;ume).
Die Umsetzung erlaubt sogar, ein komplettes privates Netz (siehe oben) mit einer
einzigen externen IP-Adresse zu betreiben.
</ul>
<P>

<H3>Network Address Translation (NAT) und IP-Masquerading</H3>
Die begrenzte Verf&uuml;gbarkeit von IP-Adressen hat dazu gef&uuml;hrt, da&szlig;
man sich Gedanken &uuml;ber verschiedene M&ouml;glichkeiten machen mu&szlig;te,
wie man mit den existierenden Adressen ein gr&ouml;&szlig;eres Umfeld abdecken
kann.
Eine M&ouml;glichkeit, um private Netze (und dazu geh&ouml;rt letztendlich auch
ein privater Anschlu&szlig; mit mehr als einem PC) unter Verwendung m&ouml;glichst
weniger Adressen an das Internet anzukoppeln stellen <B>NAT</B>, <B>PAT</B>
und <B>IP Masquerading</B>. Alle Verfahren bilden private Adressen gem&auml;&szlig;
RFC 1918 oder einen propriet&auml;ren (nicht registrierten) Adre&szlig;raum eines
Netzes auf &ouml;ffentliche registrierte IP-Adressen ab.
<UL>
<LI>NAT (Network Address Translation)<BR>
Beim NAT (Network Address Translation) werden die Adressen eines privaten Netzes
&uuml;ber Tabellen &ouml;ffentlich registrierten IP-Adressen zugeordnet. Der
Vorteil besteht darin, da&szlig; Rechner, die in einem privaten Netz miteinander
kommunizieren, keine &ouml;ffentlichen IP-Adressen ben&ouml;tigen.
IP-Adressen interner Rechner, die eine Kommunikation mit Zielen im Internet aufbauen,
erhalten in dem Router, der zwischen dem Internet Service Provider (ISP) und dem
privaten Netzwerk steht, einen Tabelleneintrag. Durch diese Eins-zu-Eins-Zuordnung
sind diese Rechner nicht nur in der Lage, eine Verbindung zu Zielen im Internet
aufzubauen, sondern sie sind auch aus dem Internet erreichbar. Die interne Struktur
des Firmennetzwerkes bleibt jedoch nach au&szlig;en verborgen.
<P>
<CENTER><IMG SRC="nat.gif"></CENTER>
<P>

<LI>IP Masquerading<BR>
IP Masquerading, das manchmal auch als PAT (Port and Address Translation) bezeichnet
wird, bildet <B>alle</B> Adressen eines privaten Netzwerkes auf <B>eine</B> einzelne
&ouml;ffentliche IP-Adresse ab. Dies geschieht dadurch, da&szlig; bei einer existierenden
Verbindung zus&auml;tzlich zu den Adressen auch die Portnummern ausgetauscht werden.
Auf diese Weise ben&ouml;tigt ein gesamtes privates Netz nur eine einzige registrierte
&ouml;ffentliche IP-Adresse.
Der Nachteil dieser L&ouml;sung besteht darin, da&szlig; die Rechner im privaten Netzwerk
<B>nicht</B> aus dem Internet angew&auml;hlt werden k&ouml;nnen. Diese Methode eignet
sich daher hervorragend, um zwei und mehr Rechner eines privaten Anschlusses per
DF&Uuml;-Netzwerk oder ISDN-Router an das Internet zu koppeln.
<P>
<CENTER><IMG SRC="pat.gif"></CENTER>
<P>
IP Masquerading r&uuml;ckt mit dieser Funktionalit&auml;t sehr nahe an Proxy- und
Firewall-L&ouml;sungen heran, wobei ein Proxy explizit f&uuml;r ein Protokoll
(z. B. HTTP) existieren und aufgerufen werden mu&szlig;.
</UL>
<P>

<H3>Subnetze</H3>
Nachdem nun klar ist, was ein Netz der Klasse A oder B ist, soll auf die Bildung
von Subnetzen hingewiesen werden. Diese dienen dazu, ein bestehendes Netz
in weitere, kleinere Netze zu unterteilen.
<ul>
<LI>Subnetze sind Strukturierungsm&ouml;glichkeit f&uuml;r Netze, ohne
da&szlig; man zus&auml;tzliche Klasse-A-, Klasse-B- oder Klasse-C-IP-Adressen braucht.
<li>Die Standardprozedur, um ein Netz in Unternetze (Subnetze) zu teilen,
nennt man "Subnetting".
<li>Die Hostadresse des A-, B- oder C-Netzes teilt sich in die Bereiche
Subnetzadresse (Subnet-ID, Teilnetz-ID) und Hostadresse (verbleibende, verk&uuml;rzte
Host-ID). Ein Teil des Hostadressbereiches wird also genutzt, um die Subnetze zu
unterscheiden.
<li>Die Netzadresse und den Subnetzanteil des Hostadressraumes bezeichnet man als
"erweiterte Netzadresse" (extended network prefix).
<LI>Die interne Subnetz-Struktur von A-, B- oder C-Netzen ist nach au&szlig;en hin
unsichtbar.
<li>Damit Router in der Lage sind, Datagramme in das richtige Netz zuzustellen,
m&uuml;ssen sie bei der IP-Adresse den Netz- und Hostanteil unterscheiden k&ouml;nnen.
<li>Dies geschieht traditionell durch die Netzmaske bzw. Subnetzmaske (subnet mask).
</ul>

Die Subnetzmaske dient dem Rechner dazu, die Zuordnung von Netzwerk-Teil und
Host-Teil vorzunehmen. Sie hat denselben Aufbau wie eine IP-Adresse (32 Bit bzw.
4 Byte). Per Definition sind alle Bit des "Netzwerk-Teils" auf 1 zu setzen,
alle Bit des "Host-Teils" auf 0. F&uuml;r die o.a. Adre&szlig;klassen hat die
Subnetzmaske demnach folgendes Aussehen:
<P>
<table ALIGN=CENTER WIDTH="80%" border=1 cellpadding=4>
<tr>
<th>Adre&szlig;-Klasse</td>
<th>Subnetzmaske (bin&auml;r)</td>
<th>Subnetzmaske (dezimal)</td>
</tr>
<tr>
<td>Class A</td>
<td><TT>11111111.00000000.00000000.00000000</TT></td>
<td><TT>255.0.0.0</TT></td>
</tr>
<tr>
<td>Class B</td>
<td><TT>11111111.11111111.00000000.00000000</TT></td>
<td><TT>255.255.0.0</TT></td>
</tr>
<tr>
<td>Class C</td>
<td><TT>11111111.11111111.11111111.00000000</TT></td>
<td><TT>255.255.255.0</TT></td>
</tr>
</table>
<br>
Diese Subnetzmaske (auch "Default Subnetzmaske" genannt) kann manuell
&uuml;berschrieben werden.
<P>
Eine Subnet-Maske f&uuml;r ein Netz der Klasse
C lautet daher 255.255.255.0. Das bedeutet, da&szlig; die ersten drei Bytes die
Netzadresse angeben und das vierte Byte die Rechner adressiert. Eine Subnetz-Maske
mit dem Wert 255.255.0.0 w&uuml;rde folglich ein Netz der Klasse B angeben und
f&uuml;r ein C-Netz steht die Maske 255.255.255.0.

<H4>Aufteilung in Subnetze </H4>
<p>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADDING=4>
<TR><TD VALIGN="TOP" >Netzwerk-<br>anteil in Bit</TD>
<TD VALIGN="TOP" >Hostanteil<BR>in Bit</TD>
<TD VALIGN="TOP" >Subnetz-<br>anzahl *)</TD>
<TD VALIGN="TOP" >Hostanzahl **)</TD>
<TD VALIGN="TOP" >Subnetzmaske</TD>
</TR>
<TR><TD VALIGN="TOP"><B>8</B></TD>
<TD VALIGN="TOP"><B>24</B></TD>
<TD VALIGN="TOP"><B>1</B></TD>
<TD VALIGN="TOP"><B>16777216</B></TD>
<TD VALIGN="TOP"><B>255.0.0.0 &nbsp; &nbsp; &nbsp; Klasse A</B></TD>
</TR>
<TR><TD VALIGN="TOP">9</TD>
<TD VALIGN="TOP">23</TD>
<TD VALIGN="TOP">2</TD>
<TD VALIGN="TOP">128*65536</TD>
<TD VALIGN="TOP">255.<B>128</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">10</TD>
<TD VALIGN="TOP">22</TD>
<TD VALIGN="TOP">4</TD>
<TD VALIGN="TOP">64*65536</TD>
<TD VALIGN="TOP">255.<B>192</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">11</TD>
<TD VALIGN="TOP">21</TD>
<TD VALIGN="TOP">
8</TD>
<TD VALIGN="TOP">32*65536</TD>
<TD VALIGN="TOP">255.<B>224</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">12</TD>
<TD VALIGN="TOP">20</TD>
<TD VALIGN="TOP">16</TD>
<TD VALIGN="TOP">16*65536</TD>
<TD VALIGN="TOP">255.<B>240</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">13</TD>
<TD VALIGN="TOP">19</TD>
<TD VALIGN="TOP">32</TD>
<TD VALIGN="TOP">8*65536</TD>
<TD VALIGN="TOP">255.<B>248</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">14</TD>
<TD VALIGN="TOP">18</TD>
<TD VALIGN="TOP">64</TD>
<TD VALIGN="TOP">4*65536</TD>
<TD VALIGN="TOP">255.<B>252</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">15</TD>
<TD VALIGN="TOP">17</TD>
<TD VALIGN="TOP">128</TD>
<TD VALIGN="TOP">2*65536</TD>
<TD VALIGN="TOP">255.<B>254</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP"><B>16</B></TD>
<TD VALIGN="TOP"><B>16</B></TD>
<TD VALIGN="TOP"><B>1</B></TD>
<TD VALIGN="TOP"><B>65536</B></TD>
<TD VALIGN="TOP"><B>255.255.0.0 &nbsp; &nbsp; &nbsp; Klasse B</B></TD>
</TR>
<TR><TD VALIGN="TOP">17</TD>
<TD VALIGN="TOP">15</TD>
<TD VALIGN="TOP">2</TD>
<TD VALIGN="TOP">128*256</TD>
<TD VALIGN="TOP">255.255.<B>128</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">18</TD>
<TD VALIGN="TOP">14</TD>
<TD VALIGN="TOP">4</TD>
<TD VALIGN="TOP">64*256</TD>
<TD VALIGN="TOP">255.255.<B>192</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">19</TD>
<TD VALIGN="TOP">13</TD>
<TD VALIGN="TOP">8</TD>
<TD VALIGN="TOP">32*256</TD>
<TD VALIGN="TOP">255.255.<B>224</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">20</TD>
<TD VALIGN="TOP">12</TD>
<TD VALIGN="TOP">16</TD>
<TD VALIGN="TOP">16*256</TD>
<TD VALIGN="TOP">255.255.<B>240</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">21</TD>
<TD VALIGN="TOP">11</TD>
<TD VALIGN="TOP">32</TD>
<TD VALIGN="TOP">8*256</TD>
<TD VALIGN="TOP">255.255.<B>248</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">22</TD>
<TD VALIGN="TOP">10</TD>
<TD VALIGN="TOP">64</TD>
<TD VALIGN="TOP">4*256</TD>
<TD VALIGN="TOP">255.255.<B>252</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">23</TD>
<TD VALIGN="TOP">9</TD>
<TD VALIGN="TOP">128</TD>
<TD VALIGN="TOP">2*256</TD>
<TD VALIGN="TOP">255.255.<B>254</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP"><B>24</B></TD>
<TD VALIGN="TOP"><B>8</B></TD>
<TD VALIGN="TOP"><B>1</B></TD>
<TD VALIGN="TOP"><B>256</B></TD>
<TD VALIGN="TOP"><B>255.255.255.0 &nbsp; &nbsp; &nbsp; Klasse C</B></TD>
</TR>
<TR><TD VALIGN="TOP">25</TD>
<TD VALIGN="TOP">7</TD>
<TD VALIGN="TOP">2</TD>
<TD VALIGN="TOP">128</TD>
<TD VALIGN="TOP">255.255.255.<B>128</B></TD>
</TR>
<TR><TD VALIGN="TOP">26</TD>
<TD VALIGN="TOP">6</TD>
<TD VALIGN="TOP">4</TD>
<TD VALIGN="TOP">64</TD>
<TD VALIGN="TOP">255.255.255.<B>192</B></TD>
</TR>
<TR><TD VALIGN="TOP">27</TD>
<TD VALIGN="TOP">5</TD>
<TD VALIGN="TOP">8</TD>
<TD VALIGN="TOP">32</TD>
<TD VALIGN="TOP">255.255.255.<B>224</B></TD>
</TR>
<TR><TD VALIGN="TOP">28</TD>
<TD VALIGN="TOP">4</TD>
<TD VALIGN="TOP">16</TD>
<TD VALIGN="TOP">16</TD>
<TD VALIGN="TOP">255.255.255.<B>240</B></TD>
</TR>
<TR><TD VALIGN="TOP">29</TD>
<TD VALIGN="TOP">3</TD>
<TD VALIGN="TOP">32</TD>
<TD VALIGN="TOP">8</TD>
<TD VALIGN="TOP">255.255.255.<B>248</B></TD>
</TR>
<TR><TD VALIGN="TOP">30</TD>
<TD VALIGN="TOP">2</TD>
<TD VALIGN="TOP">64</TD>
<TD VALIGN="TOP">4</TD>
<TD VALIGN="TOP">255.255.255.<B>252</B></TD>
</TR>
</TABLE>
<p>
<H4>Anmerkungen:</H4>
<UL>
<B>*)&nbsp;</B> Die erste und letzte bei der Unterteilung entstehenden Adressen
d&uuml;rfen nicht verwendet werden (Verwechslung mit Netz- und Broadcast-Adresse
des &uuml;bergeordneten Netzes). Die Anzahl der Subnetze verringert sich somit
jeweils um zwei:<br>
Ist der Netzwerkanteil der IP-Adresse <B>n</B> Bits, dann erh&auml;lt man
<B>(2<SUP>n</SUP>) - 2</B> Subnetze.
<P>
<B>**)</B> Die Rechneranzahl verringert sich ebenfalls um zwei wegen Subnetz-Adresse
(alle Rechnerbits auf 0) und Broadcast-Adresse (alle Rechnerbits auf 1):<BR>
Ist der Hostanteil der IP-Adresse <B>m</B> Bits, dann erh&auml;lt man
<B>(2<SUP>m</SUP>) - 2</B> Hosts pro Subnetz.
</UL>
<p>
Besitzt breispielsweise ein Unternehmen ein Netz der Klasse C, m&ouml;chte
man dieses vielleicht in zwei Segmente unterteilen, die voneinander getrennt sind.
Der Broadcastverkehr des ersten Segments kann so das andere nicht beeintr&auml;chtigen.
In diesem Fall kommt die Subnetz-Maske zum Einsatz, welche die Rechneradressen in
zwei Bereiche gliedert. Sollen die Rechner in vier gleich gro&szlig;e Subnetze mit
je 64 Knoten eingeteilt werden, lautet die Subnetz-Maske 255.255.255.192. Es
gilt die folgende Formel f&uuml;r das <I>Maskier-Byte:</I>
<P>
Bytewert = 256 - (Anzahl der Knoten in einem Segment)
<P>
Als das Subnetting erstmals standardisiert wurde, war es verboten die Subnetze zu
nutzen, in denen alle Subnetzbits den Wert 0 oder 1 hatten (siehe Anmerkungen oben).
Damit ergeben sich im Beispiel nur zwei Subnetze mit je 62 Hosts. Inzwischen beherrschen
fast alle Systeme korrektes Subnetting ("classless" routing).
<P>
<H4>Beispiel: Aufteilung in 4 Subnetze</H4>
Ein Netz der Klasse C soll in vier gleich gro&szlig;e Subnetze geteilt werden. Die
Netzadresse betr&auml;gt 192.168.98.0. Der Administrator w&auml;hlt daher zur
Unterteilung die Subnetz-Maske 255.255.255.192. Die vier Rechner mit den IP-Adressen
192.168.98.3, 192.168.98.73. 192.168.98.156 und 192.168.98.197 befinden sich daher
in vier Subnetzen zwischen denen geroutet werden mu&szlig;. Broadcasts in Subnetz 1
werden somit nicht in die anderen Subnetze &uuml;bertragen. Es ist nun zum Beispiel
f&uuml;r das Unternehmen m&ouml;glich, die Rechner des Vertriebs in Subnetz 1, die
des Einkaufs in Subnetz 2, jene der Entwicklung in Subnetz 3 und ein Netz aus
Demorechnern in Subnetz 4 zu organisieren. Damit ist gesichert, da&szlig;
St&ouml;rungen in einzelnen Subnetzen auch lokal auf diese beschr&auml;nkt
bleiben. Sie schlagen nicht auf die Datenstruktur des ganzen Unternehmens durch.
<P>
<CENTER><IMG SRC="subnetting.gif"></CENTER>
<P>
Allgemein ergibt sich f&uuml;r ein C-Netz folgende Aufstellung:
<P>
<H4>Subnetze eines C-Netzes</H4>
In Klammern die reduzierte Anzahl der Subnetze (Anzahl - 2). Die rot unterlegten
M&ouml;glichkeiten sind dann in der Praxis nicht einsetzbar.
<P>
<table ALIGN=CENTER WIDTH="80%" border=1 cellpadding=4>
  <tr>
    <td align="center">Subnetzbits</td>
    <td align="center">Hostbits</td>
    <td align="center">m&ouml;gliche Subnetze</td>
    <td align="center">Hostadressen</td>
    <td align="center">Subnetzmaske</td>
  </tr>
  <tr>
    <td align="center"><font color="#CC0000">1</font></td>
    <td align="center"><font color="#CC0000">7</font></td>
    <td align="center"><font color="#CC0000">2 (0)</font></td>
    <td align="center"><font color="#CC0000">126 (0)</font></td>
    <td align="center"><font color="#CC0000">255.255.255.128</font></td>
  </tr>
  <tr>
    <td align="center">2</td>
    <td align="center">6</td>
    <td align="center">4 (2)</td>
    <td align="center">62</td>
    <td align="center">255.255.255.192</td>
  </tr>
  <tr>
    <td align="center">3</td>
    <td align="center">5</td>
    <td align="center">8 (6)</td>
    <td align="center">30</td>
    <td align="center">255.255.255.224</td>
  </tr>
  <tr>
    <td align="center">4</td>
    <td align="center">4</td>
    <td align="center">16 (14)</td>
    <td align="center">14</td>
    <td align="center">255.255.255.240</td>
  </tr>
  <tr>
    <td align="center">5</td>
    <td align="center">3</td>
    <td align="center">32 (30)</td>
    <td align="center">6</td>
    <td align="center">255.255.255.248</td>
  </tr>
  <tr>
    <td align="center">6</td>
    <td align="center">2</td>
    <td align="center">64 (62)</td>
    <td align="center">2</td>
    <td align="center">255.255.255.252</td>
  </tr>
  <tr>
    <td align="center"><font color="#CC0000">7</font></td>
    <td align="center"><font color="#CC0000">1</font></td>
    <td align="center"><font color="#CC0000">128</font></td>
    <td align="center"><font color="#CC0000">0</font></td>
    <td align="center"><font color="#CC0000">255.255.255.254</font></td>
  </tr>
</table>
<P>

<H4>Beispiel: Aufteilung in 8 (6) Subnetze</H4>
Von den acht variabel verwendbaren Bits nutzt er also die drei h&ouml;chstwertigen
Bits f&uuml;r das Subnetz und die f&uuml;nf letzten Bits f&uuml;r die Hostadresse.
Die erste Adresse jedes Subnetz ist die Adresse in der alle Hostbits den Wert 0 haben.
<p>
<table ALIGN=CENTER WIDTH="80%" border=1 cellpadding=4>
  <tr>
    <td>&nbsp;</td>
    <td colspan="3">Subnetzbits</td>
    <td colspan="5">Hostbits</td>
    <td>dezimal</td>
  </tr>
  <tr>
    <td>Dezimale Wertigkeit des Bit</td>
    <td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>&nbsp;</td>
  </tr>
  <tr>
    <td><font color="#cc0000">erstes Subnetz</font></td>
    <td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td>
  </tr>
  <tr>
    <td>zweites Subnetz</td>
    <td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>32</td>
  </tr>
  <tr>
    <td>drittes Subnetz</td>
    <td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>64</td>
  </tr>
  <tr>
    <td>viertes Subnetz</td>
    <td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>96</td>
  </tr>
  <tr>
    <td>f&uuml;nftes Subnetz</td>
    <td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>128</td>
  </tr>
  <tr>
    <td>sechstes Subnetz</td>
    <td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>160</td>
  </tr>
  <tr>
    <td>siebtes Subnetz</td>
    <td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>192</td>
  </tr>
  <tr>
    <td><font color="#cc0000">achtes Subnetz</font></td>
    <td><font color="#cc0000">1</font></td><td><font color="#cc0000">1</font></td><td><font color="#cc0000">1</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">224</font></td>
  </tr>
</table>
<p>Damit sind die acht zur Verf&uuml;gung stehenden Subnetze bekannt:<BR>
<PRE>
<font color="#cc0000">192.168.0.0/27</font>
192.168.0.32/27
192.168.0.64/27
192.168.0.96/27
192.168.0.128/27
192.168.0.160/27
192.168.0.192/27
<font color="#cc0000">192.168.0.224/27</font>
</PRE>
<H4>Anmerkung:</H4>
<UL>
Die Zahl hinter dem Schr&auml;gstrich (oben ist das die 27) gibt an,
wieviele Bits der 32 Bit langen IP-Adresse als Netzanteil verwendet werden.
</UL>
<P>
Diese Subnetze k&ouml;nnen jetzt einzelnen Netzen zugeordnet werden. Die folgende Tabelle
zeigt die Netz- und Broadcastadressen von jedem einzelnen Subnetz und die Rechneradressen.
<p>
<table ALIGN=CENTER WIDTH="80%" border=1 cellpadding=4>
  <tr>
    <td>Subnetz</td>
    <td colspan=3>IP-Adressen (letztes Oktett)</td>
  </tr>
  <tr>
    <td>&nbsp;</td><td>Netz</td><td>Hosts</td><td>Broadcast</td>
  </tr>
  <tr>
    <td><font color="#cc0000">erstes Subnetz</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">1-30</font></td><td><font color="#cc0000">31</font></td>
  </tr>
  <tr>
    <td>zweites Subnetz</td><td>32</td><td>33-62</td><td>63</td>
  </tr>
  <tr>
    <td>drittes Subnetz</td><td>64</td><td>65-94</td><td>95</td>
  </tr>
  <tr>
    <td>viertes Subnetz</td><td>96</td><td>97-126</td><td>127</td>
  </tr>
  <tr>
    <td>f&uuml;nftes Subnetz</td><td>128</td><td>129-158</td><td>159</td>
  </tr>
  <tr>
    <td>sechstes Subnetz</td><td>160</td><td>161-190</td><td>191</td>
  </tr>
  <tr>
    <td>siebtes Subnetz</td><td>192</td><td>193-222</td><td>223</td>
  </tr>
  <tr>
    <td><font color="#cc0000">achtes Subnetz</font></td><td><font color="#cc0000">224</font></td><td><font color="#cc0000">225-254</font></td><td><font color="#cc0000">255</font></td>
  </tr>
</table>
<p>
Als kleine Hilfe gibt es hier noch einen Subnetz-Rechner
als Javascript-Programm. Eingegeben wird eine IP-Netzadresse
in CIDR-Form (<B>C</B>lassless <B>I</B>nter-<B>D</B>omain <B>R</B>outing,
z.B. 10.1.2.0/24). Nach dem Klick auf "Berechnen" erscheinen
im unteren Feld die Werte der Netzadresse, der Subnet-Maske und
der Bereich der zugeh&ouml;rigen IP-Adressen, wobei die erste Adresse
des angebenen Bereichs die Netzadresse darstellt und die letzte Adresse
die Broadcast-Adresse.

<P>
<DIV ALIGN=CENTER>
<form name="CIDR">
<table bgcolor="#000000" border=0 cellpadding="1" cellspacing="0">
<tr><td>
 <table bgcolor="#DDDDDD" border=0 cellpadding="5" cellspacing="0">
 <tr>
 <td bgcolor="#DDDDDD">CIDR: </td>
 <td><input name="Eingabe" size="20" value="192.168.1.0/24">
     <input type="button" value="Berechnen" onclick="CalcSubnet()">
 <td>
 </tr><tr>
 <td bgcolor="#DDDDDD">IP-Bereich: </td>
 <td><textarea cols="40" rows="3" name="Result" onfocus="blur()"></textarea></td>
 </tr>
 </table>
</td></tr></table>
</form>

<script type="text/javascript">
// IP-Bereiche umrechnen
function CalcSubnet()
  {
  document.CIDR.Result.value;
  Eingabe = document.CIDR.Eingabe.value;
  if (Eingabe != "")
    {
    Wert = Eingabe.split("/");
    if (Wert.length != 2)
      {
      alert("Eingabe: IP-Adresse/Netzanteil\nz.B. 192.168.233.0/24");
      return;
      }
    else
      {
      IP = Wert[0].split(".");
      if (IP.length != 4)
        {
        alert("Fehlerhafte Eingabe der IP-Nummer! \nEine IP-Adresse besteht aus 4 Zahlen (0=< Zahl <=255), getrennt durch Punkte\nz.B. 192.168.233.0");
        return;
        }
      }
    }
  NETZ = "";
  LAST = "";
  MASK = "";
  NetNum = parseInt(Wert[1]);
  if (isNaN(NetNum))
    {
    alert("Fehlerhafter Netzanteil!\nKeine Zahl!");
    return;
    }
  if (NetNum < 0 || NetNum > 32)
    {
    alert("Netzanteil /" + NetNum +" ist nicht erlaubt (0=< Netzanteil =<32)");
    return;
    }
  for (i=0; i<4; i++)
    {
    if (CalcPart(IP[i]))
      {
      alert("Fehlerhafte Eingabe der IP-Nummer '" + IP[i] +"' im "+ (i+1) +". Byte!  \nEine IP-Adresse besteht aus 4 Zahlen (0=< Zahl <=255), getrennt durch Punkte\nz.B. 192.168.233.0");
      return;
      }
    if (i < 3)
      { NETZ += "."; LAST += "."; MASK += "." };
    }
  document.CIDR.Result.value = "Netz:  " + NETZ + "\nMaske: " + MASK + "\nRange: " + NETZ + " - " + LAST;
  }

function CalcPart(Part)
  {
  if (isNaN(Part)) return 1;
  var m = parseInt(Part);
  if (isNaN(m)) return 1;
  if(m < 0 || m > 255) return 1;
  var cumm =+ m;
  if (NetNum >= 8)
    { NETZ += cumm; LAST += cumm; MASK += "255"; }
  else
    {
    if (NetNum < 0)
      { NETZ += "0"; LAST += "255"; MASK += "0"; }
    else
      {
      var f = 256, ZifNet = 0, ZifLast = 0, ZifMask = 0;
      while (f > 1)
        {
        f = f/2;
        NetNum -= 1;
        if (NetNum >= 0)
          {
          if (m >= f)
            { m -= f; ZifNet += f; ZifLast += f; }
          ZifMask += f;
          }
        else
          {
          if (m > f) { m -= f; }
          ZifLast += f;
          }
        }
      NETZ += ''+ZifNet; LAST += ''+ZifLast; MASK += ''+ZifMask;
      }
    }
  NetNum -= 8;
  return 0;
  }
// --></script>
</DIV>
<P>

<H2><A NAME="8.4">ICMP - Internet Control Message Protocol</A></H2>
ICMP erlaubt den Austauch von Fehlermeldungen und Kontrollnachrichten auf
IP-Ebene. ICMP benutzt das IP wie ein ULP, ist aber integraler Bestandteil
der IP-Implementierung. Es macht IP nicht zu einem 'Reliable Service', ist
aber die einzige M&ouml;glichkeit Hosts und Gateways &uuml;ber den Zustand
des Netzes zu informieren (z. B. wenn ein Host tempor&auml;r nicht erreichbar
ist --&gt; Timeout).
<P>
Die ICMP-Nachricht ist im Datenteil des IP-Datagramms untergebracht, sie
enth&auml;lt ggf. den IP-Header und die ersten 64 Bytes des die Nachricht
ausl&ouml;senden Datagramms (z. B. bei Timeout).
<P>
<center><IMG SRC="icmp.gif" ALT=""></center>
<P>
Die f&uuml;nf Felder der ICMP-Message haben folgende Bedeutung:
<DL>
<DT>Type
<DD>Identifiziert die ICMP-Nachricht
<UL>
<LI> 0   Echo reply
<LI> 3   Destination unreachable
<LI> 4   Source quench
<LI> 5   Redirect (Change a Route)
<LI> 8   Echo request
<LI>11   Time exceeded for a datagram
<LI>12   Parameter Problem on a datagram
<LI>13   Timestamp request
<LI>14   Timestamp reply
<LI>15   Information request
<LI>16   Information reply
<LI>17   Address mask request
<LI>18   Address mask reply
</UL>
<DT>Code
<DD>Detailinformation zum Nachrichten-Typ

<DT>Checksum
<DD>Pr&uuml;fsumme der ICMP-Nachricht (Datenteil des IP-Datagramms)

<DT>Identifier und Sequence-Nummer
<DD>dienen der Zuordnung eintreffender Antworten
zu den jeweiligen Anfragen, da eine Station mehrere Anfragen aussenden kann
oder auf eine Anfrage mehrere Antworten eintreffen k&ouml;nnen.
</DL>
<P>
Wenden wir uns nun den einzelnen Nachrichtentypen zu:
<DL>
<DT>Echo request/reply
<DD>&Uuml;berpr&uuml;fen der Erreichbarkeit eines Zielknotens. Es k&ouml;nnen
Testdaten mitgeschickt werden, die dann unver&auml;ndert zur&uuml;ckgeschickt
werden (--&gt; Ping-Kommando unter UNIX).

<DT>Destination unreachable
<DD>Im Codefeld wird die Ursache n&auml;her beschrieben:
     0    Network unreachable
     1    Host unreachable
     2    Protocol unreachable
     3    Port unreachable
     4    Fragmentation needed
     5    Source route failed

<DT>Source quench
<DD>Wenn mehr Datagramme kommen als eine Station verarbeiten kann, sendet sie
diese Nachricht an die sendende Station.

<DT>Redirect
<DD>wird vom ersten Gateway an Hosts im gleichen Teilnetz gesendet, wenn es
eine bessere Route-Verbindung &uuml;ber einen anderen Gateway gibt. In der
Nachricht wird die IP-Adresse des anderen Gateways angegeben.

<DT>Time exceeded
<DD>F&uuml;r diese Nachricht an den Quellknoten gibt es zwei Ursachen:
<UL>
<LI>Time-to-live exceeded (Code 0): Wenn ein Gateway ein Datagramm eliminiert,
dessen TTL-Z&auml;hler abgelaufen ist.
<LI>Fragment reassembly time exceeded (Code 1): Wenn ein Timer abl&auml;uft,
bevor alle Fragmente des Datagramms eingetroffen sind.
</UL>
<DT>Parameter problem on a Datagramm
<DD>Probleme bei der Interpretation des IP-Headers. Es wird ein Verweis
auf die Fehlerstelle und der fragliche IP-Header zur&uuml;ckgeschickt.

<DT>Timestamp request/reply
<DD>Erlaubt Zeitmessungen und -synchronisation im Netz. Drei Zeiten werden gesendet
(in ms seit Mitternacht, Universal Time):
<UL>
<LI>Originate T.:  Sendezeitpunkt des Requests (vom Absender)
<LI>Receive T.:    Ankunftszeit (beim Empf&auml;nger)
<LI>Transmit T.:   Sendezeitpunkt des Reply (vom Empf&auml;nger)
</UL>

<DT>Information request/reply
<DD>Mit dieser Nachricht kann ein Host die Netid seines Netzes erfragen, indem
er seine Netid auf Null setzt.

<DT>Address mask request/reply
<DD>Bei Subnetting (siehe unten) kann ein Host die Subnet-Mask erfragen.
</DL>
<P>
F&uuml;r den User nutzbar ist ICMP vor allem f&uuml;r die Kommandos <i>ping</i>
und <i>traceroute</i> (bei Windows "tracert"). Diese Kommandos senden ICMP-Echo-Requests
aus und warten auf den ICMP-Echo-Reply. So kann man die Erreichbarkeit eines
Knotens feststellen. Will man alle Knoten im lokalen Netz erkennen gen&uuml;gt ein
<i>ping</i> auf die Broadcast-Adresse, z. B.:
<pre>
ping 192.168.33.255
</pre>
Zum Anzeigen der Arp-Tabelle gibt es unter Windows wie unter Linux das <i>arp</i>-Kommando,
mit <i>arp -a</i> erh&auml;lt man eine Liste der aktuell gespeicherten MAC-Adressen und
deren Zuordnung zu IP-Adressen.
<P>
F&uuml;hrt man das obige <i>ping</i>-Kommando und das <i>arp</i>-Kommando nacheinander
aus, erh&auml;lt man eine liste der IP- umd MAC-Adressen der aktiven lokalen Knoten, z.B.:
<PRE>
ping -b -c1 192.168.33.255
arp -a
</PRE>
<P>


<H2><A NAME="8.5">UDP - User Datagram Protocol</A></H2>
UDP ist ein einfaches Schicht-4-Protokoll, das einen nicht zuverl&auml;ssigen,
verbindungslosen Transportdienst ohne Flu&szlig;kontrolle zur Verf&uuml;gung
stellt. UDP erm&ouml;glicht zwischen zwei Stationen mehrere unabh&auml;ngige
Kommunikationsbeziehungen (Multiplex-Verbindung): Die Identifikation der
beiden Prozesse einer Kommuninkationsbeziehung geschieht (wie auch bei TCP,
siehe unten) durch Port-Nummern (kurz "Ports"), die allgemein
bekannten Anwendungen fest zugeordnet sind. Es lassen sich aber auch Ports
dynamisch vergeben oder bei einer Anwendung durch verschiedene Ports deren
Verhalten steuern. Die Transporteinheiten werden 'UDP-Datagramme' oder 'User
Datagramme' genannt. Sie haben folgenden Aufbau:
<P>
<center><IMG SRC="udp.gif" ALT=""></center>
<P>
<DL>
<DT>Source Port
<DD>Identifiziert den sendenden Proze&szlig; (falls nicht ben&ouml;tigt, wird
der Wert auf Null gesetzt).

<DT>Destination Port
<DD>Identifiziert den Proze&szlig; des Zielknotens.

<DT>Length
<DD>L&auml;nge des UDP-Datagramms in Bytes (mindestens 8 = Headerl&auml;nge)

<DT>UDP-Checksum
<DD>Optionale Angabe (falls nicht verwendet auf Null gesetzt) einer Pr&uuml;fsumme.
Zu deren Ermittlung wird dem UDP-Datagramm ein Pseudoheader von 12 Byte
vorangestellt (aber nicht mit &uuml;bertragen), der u. a. IP-Source-Address,
IP-Destination-Address und Protokoll-Nummer (UDP = 17) enth&auml;lt.
</DL>
<P>

<H2><A NAME="8.6">TCP - Transmission Control Protocol</A></H2>
Welches &uuml;bergeordnete Protokoll der Transportschicht das Datenpaket
erh&auml;lt, steht im 'Protokoll'-Feld eines jeden IP-Paketes. Jedes Protokoll
der Transportschicht bekommt eine eindeutige Identifikationsnummer zugewiesen,
anhand der die IP-Schicht entscheiden kann, wie weiter mit dem Paket zu verfahren
ist. Eines der wichtigsten Protokolle der Transportschicht ist TCP.
<P>
Die Aufgabe von TCP ist es, die oben geschilderten Defizite von IP zu verbergen.
F&uuml;r den TCP-Benutzer soll es nicht mehr sichtbar sein, da&szlig; die
darunterliegenden Protokollschichten Datenpakete versenden, sondern es soll der
Benutzer mit einem Byte-Strom wie bei einer normalen Datei (oder einem Terminal)
arbeiten k&ouml;nnen. TCP garantiert vor allen Dingen den korrekten Transport der
Daten - jedes Paket kommt nur einmal, fehlerfrei und in der richtigen Reihenfolge an.
Zus&auml;tzlich k&ouml;nnen bei TCP mehrere Programme die Verbindung zwischen
zwei Rechnern quasi-gleichzeitig nutzen. TCP teilt die Verbindung in viele
virtuelle Kan&auml;le ("Ports") auf, die zeitmultiplex mit Daten versorgt werden.
Nur so ist es m&ouml;glich, da&szlig; beispielsweise mehrere Benutzer eines
Rechners zur selben Zeit das Netz in Anspruch nehmen k&ouml;nnen oder da&szlig; man
mit einer einzigen W&auml;hlverbindung zum Provider gleichzeitig E-Mail empfangen und
Dateien per FTP &uuml;bertragen kann.
<p>
Dieses Protokoll implementiert also einen verbindungsorientierten, sicheren Transportdienst
als Schicht-4-Protokoll. Die Sicherheit wird durch positive R&uuml;ckmeldungen
(acknowledgements) und Wiederholung fehlerhafter Bl&ouml;cke erreicht. Fast
alle Standardanwendungen vieler Betriebssysteme nutzen TCP und das darunterliegende
IP als Transportprotokoll, weshalb man die gesamte Protokollfamilie allgemein
unter 'TCP/IP' zusammenfa&szlig;t. TCP l&auml;&szlig;t sich in lokalen und
weltweiten Netzen einsetzen, da IP und die darunterliegenden Schichten mit
den unterschiedlichsten Netzwerk- und &Uuml;bertragungssystemen arbeiten
k&ouml;nnen (Ethernet, Funk, serielle Leitungen, ...). Zur Realisierung
der Flu&szlig;kontrolle wird ein Fenstermechanismus (sliding windows)
verwendet (variable Fenstergr&ouml;&szlig;e). TCP-Verbindungen sind
vollduplex. Wie bei allen verbindungsorientierten Diensten mu&szlig; zun&auml;chst
eine virtuelle Verbindung aufgebaut und bei Beendigung der Kommunikation
wieder abgebaut werden. "Verbindungsaufbau" bedeutet hier eine
Vereinbarung beider Stationen &uuml;ber die Modalit&auml;ten der &Uuml;bertragung
(z. B. Fenstergr&ouml;&szlig;e, Akzeptieren eines bestimmten Dienstes, usw.).
Ausgangs- und Endpunkte einer virtuellen Verbindung werden wie bei UDP durch
Ports identifiziert. Allgemein verf&uuml;gbare Dienste
werden &uuml;ber 'well known' Ports (--&gt; feste zugeordnete Portnummer)
erreichbar. Andere Portnummern werden beim Verbindungsaufbau vereinbart.
<P>

Damit die st&auml;ndige Best&auml;tigung jedes Datensegments den Transport nicht
&uuml;ber Geb&uuml;hr hemmt, werden zwei Tricks verwendet. Zum einen kann die
Empfangsbet&auml;tigung einem Segment in Gegenrichtung mitgegeben werden - das spart ein
separates Quittungssegment. Zweitens mu&szlig; nicht jedes Byte sofort best&auml;tigt
werden, sondern es gibt ein sogenanntes 'Fenster'.
Die Fenstergr&ouml;&szlig;e gibt an, wieviele Bytes gesendet werden d&uuml;rfen,
bis die &Uuml;bertragung quittiert werden mu&szlig;. Erfolgt keine Quittung,
werden die Daten nochmals gesendet. Die empfangene Quittung enth&auml;lt
die Nummer des Bytess, das als n&auml;chstes vom Empf&auml;nger erwartet
wird - womit auch alle vorhergehenden Bytes quittiert sind. Die Fenstergr&ouml;&szlig;e
kann dynamisch mit der Quittung des Empf&auml;ngers ge&auml;ndert
werden. Werden die Ressourcen knapp, wird die Fenstergr&ouml;&szlig;e verringert.
Beim Extremfall Null wird die &Uuml;bertragung unterbrochen, bis der Empf&auml;nger
erneut quittiert. Neben einem verl&auml;&szlig;lichen Datentransport ist
so auch die Flu&szlig;kontrolle gew&auml;hrleistet.
<P>
<center><IMG SRC="windows.gif" ALT=""></center>
<P>
Das Prinzip des Fenstermechanismus ist eigentlich ganz einfach. Wenn man das Bild
betrachtet, ergibt sich folgende Sachverhalt:
<UL>
<LI> Die Fenster gr&ouml;&szlig;e im Beispiel betr&auml;gt drei Bytes.
<LI>Byte 1 wurde von der Datenquelle gesendet und vom Empf&auml;nger quittiert.
<LI>Die Quelle hat die Bytes 2, 3 und 4 gesendet, sie wurden aber vom
Empf&auml;nger noch nicht quittiert (Quittung eventuell noch unterwegs).
<LI>Byte 5 wurde von der Quelle noch nicht gesendet. Er geht erst dann auf
die Reise, wenn die Quittung f&uuml;r Byte 2 (oder h&ouml;her) eingetroffen ist.
</UL>
<P>
Das TCP-Paket wird oft auch als 'Segment' bezeichnet. Jedem TCP-Block ist ein
Header vorangestellt, der aber wesentlich umfangreicher als die bisherigen ist:
<P>
<center><IMG SRC="tcp.gif" ALT=""></center>
<P>
<DL>
<DT>Source Port
<DD>Identifiziert den sendenden Proze&szlig;.

<DT>Destination Port
<DD>Identifiziert den Proze&szlig; des Zielknotens.

<DT>Sequence Number
<DD>TCP betrachtet die zu &uuml;bertragenden Daten als numerierten Bytestrom,
wobei die Nummer des ersten Bytes beim Verbindungsaufbau festgelegt wird.
Dieser Bytestrom wird bei der &Uuml;bertragung in Bl&ouml;cke (TCP-Segmente)
aufgeteilt. Die 'Sequence Number' ist die Nummer des ersten Datenbytes im
jeweiligen Segment (--&gt; richtige Reihenfolge &uuml;ber verschiedene Verbindungen
eintreffender Segmente wiederherstellbar).

<DT>Acknowledgement Number
<DD>Hiermit werden Daten von der Empf&auml;ngerstation best&auml;tigt, wobei
gleichzeitig Daten in Gegenrichtung gesendet werden. Die Best&auml;tigung
wird also den Daten "aufgesattelt" (Piggyback). Die Nummer bezieht
sich auf eine Sequence-Nummer der empfangenen Daten; alle Daten bis zu dieser
Nummer (ausschlie&szlig;lich) sind damit best&auml;tigt --&gt; Nummer des
n&auml;chsten erwarteten Bytes. Die G&uuml;ltigkeit der Nummer wird durch
das ACK-Feld (--&gt; Code) best&auml;tigt.

<DT>Data Offset
<DD>Da der Segment-Header &auml;hnlich dem IP-Header Optionen enthalten kann,
wird hier die L&auml;nge des Headers in 32-Bit-Worten angegeben.

<DT>Res.
<DD>Reserviert f&uuml;r sp&auml;tere Nutzung

<DT>Code
<DD>Angabe der Funktion des Segments:
<UL>
<LI>URG  Urgent-Pointer (siehe unten)
<LI>ACK  Quittungs-Segment (Acknowledgement-Nummer g&uuml;ltig)
<LI>PSH  Auf Senderseite sofortiges Senden der Daten (bevor Sendepuffer
gef&uuml;llt ist) und auf Empfangsseite sofortige Weitergabe an die Applikation
(bevor Empfangspuffer gef&uuml;llt ist) z. B. f&uuml;r interaktive Programme.
<LI>RST  Reset, Verbindung abbauen
<LI>SYN Das 'Sequence Number'-Feld enth&auml;lt die initiale Byte-Nummer
(ISN) --&gt; Numerierung  beginnt  mit ISN + 1. In der Best&auml;tigung
&uuml;bergibt die Zielstation ihre ISN (Verbindungsaufbau).
<LI>FIN Verbindung abbauen (Sender hat alle Daten gesendet), sobald der
Empf&auml;nger alles korrekt empfangen hat und selbst keine Daten mehr loswerden
will.
</UL>

<DT>Window
<DD>Spezifiziert die Fenstergr&ouml;&szlig;e, die der Empf&auml;nger bereit
ist anzunehmen - kann dynamisch ge&auml;ndert werden.

<DT>Checksum
<DD>16-Bit L&auml;ngsparit&auml;t &uuml;ber Header und Daten.

<DT>Urgent Pointer
<DD>Markierung eines Teils des Datenteils als dringend. Dieser wird unabh&auml;ngig
von der Reihenfolge im Datenstrom sofort an das Anwenderprogramm weitergegeben
(URG-Code mu&szlig; gesetzt sein).  Der Wert des Urgent-Pointers markiert
das letzte abzuliefernde Byte; es hat die Nummer &lt;Sequence Number&gt;
+ &lt;Urgent Pointer&gt;.

<DT>Options
<DD>Dieses Feld dient dem Informationsaustausch zwischen beiden Stationen auf
der TCP-Ebene, z. B. die Segmentgr&ouml;&szlig;e (die Ihrerseits von der
Gr&ouml;&szlig;e des IP-Datagramms abh&auml;ngen sollte, um den Durchsatz
im Netz optimal zu gestalten).
</DL>
<P>

<H4>Ablauf einer TCP-Session</H4>
Im Gegensatz zu IP ist TCP <B>verbindungsorientiert</B>. Das mu&szlig; so sein,
denn TCP-Verbindungen sollen ja f&uuml;r den Benutzer prinzipiell wie Dateien zu
handhaben sein. Das bedeutet, eine TCP-Verbindung wird wie eine Datei ge&ouml;ffnet und
geschlossen, und man kann ihre Position innerhalb des Datenstroms bestimmen, genau
wie man bei einer Datei die Position der Lese- oder Schreibposition angeben kann.
TCP sendet die Daten auch in gr&ouml;&szlig;eren Einheiten, um den Verwaltungsaufwand
durch Header- und Kontrollinformationen klein zu halten. Im Gegensatz zu
den IP-Paketen bezeichnet man die Einheiten der Transportschicht als "Segmente".
Jedes gesendete TCP-Segment hat eine eindeutige Folgenummer, welche die Position
seines ersten Bytes im Byte-Strom der Verbindung angibt. Anhand dieser Nummer
kann die Reihenfolge der Segmente korrigiert und doppelt angekommene Segmente
k&ouml;nnen aussortiert werden. Da die L&auml;nge des Segments aus dem IP-Header
bekannt ist, k&ouml;nnen auch L&uuml;cken im Datenstrom entdeckt werden, und der
Empf&auml;nger kann verlorengegangene Segmente neu anfordern.
<P>
Beim &Ouml;ffnen einer TCP-Verbindung tauschen beide Kommunikationspartner
Kontrollinformationen aus, die sicherstellen, da&szlig; der jeweilige Partner
existiert und Daten annehmen kann. Dazu schickt die Station A ein Segment mit der
Aufforderung, die Folgenummern zu synchronisieren. <BR>
Das einleitende Paket mit gesetztem SYN-Bit ("Synchronise-" oder "Open"-Request)
gibt die Anfangs-"Sequence Number" des Client bekannt. Diese Anfangs-"Sequence
Number wird zuf&auml;llig bestimmt. Bei allen nachfolgenden Paketen ist das
ACK-Bit ("Acknowledge", "Quittung") gesetzt. Der Server antwortet mit ACK, SYN
und der Client best&auml;tigt mit ACK. Das sieht dann so aus:
<P>
<CENTER><IMG SRC="tcp-hs1.gif"></CENTER>
<P>
Die Station B wei&szlig; jetzt, da&szlig;
der Sender eine Verbindung &ouml;ffnen m&ouml;chte und an welcher
Position im Datenstrom der Sender anfangen wird zu z&auml;hlen. Sie
best&auml;tigt den Empfang der Nachricht und legt ihrerseits eine
Folgenummer f&uuml;r &Uuml;bertragungen in Gegenrichtung fest.
<P>
<CENTER><IMG SRC="tcp-hs2.gif"></CENTER>
<P>
Station A best&auml;tigt nun den Empfang der Folgenummer von B und beginnt
dann mit der &Uuml;bertragung von Daten.
<P>
<CENTER><IMG SRC="tcp-hs3.gif"></CENTER>
<P>
Diese Art des Austausches von Kontrollinformationen, bei der jede Seite die Aktionen
der Gegenseite best&auml;tigen mu&szlig;, ehe sie wirksam werden k&ouml;nnen,
hei&szlig;t "Dreiwege-Handshake". Auch beim Abbau einer Verbindung wird auf diese
Weise sichergestellt, da&szlig; beide Seiten alle Daten korrekt und vollst&auml;ndig
empfangen haben. Im zeitlichen Zusammenhang stellt sich eine TCP/IP-Verbindung
folgenderma&szlig;en dar:
<P>
<center><img src="tcpip2.gif"></center>
<P>
Das folgende Beispiel zeigt die Arbeitsweise des TCP/IP - Protokolls. Es wird
eine Nachricht von einem Rechner im gr&uuml;nen Netz zu einem Rechner im orangen
Netz gesendet.
<P>
<TABLE BORDER=0 CELLPADDING=5>
<TR>
<TD VALIGN=TOP><img src="tcpbsp1.gif"></TD>
<TD VALIGN=TOP>
Die Nachricht wird in mehrere Pakete aufgeteilt und auf der besten Route
auf die Reise geschickt. Das verbindungslose IP-Protokoll sorgt zusammen mit
den Routern f&uuml;r den Weg.</TD>
</TR><TR>
<TD VALIGN=TOP>
Da eine Strecke &uuml;berlastet ist, werden die Pakete 3, 4 und 5 auf einer
anderen Strecke weiter transportiert. Dieser Transport erfolgt zuf&auml;lligerweise
schneller als jener der Pakete 1 und 2.</TD>
<TD VALIGN=TOP><img src="tcpbsp2.gif"></TD>
</TR><TR>
<TD VALIGN=TOP><img src="tcpbsp3.gif"></TD>
<TD VALIGN=TOP>
Die Pakete wandern ihrem Bestimmungsnetz entgegen. Das erste Paket ist
bereits angekommen. Paket 3 kommt vor Paket 2 am Ziel an.</TD>
</TR><TR>
<TD VALIGN=TOP>
Die Pakete 1, 2 und 3 sind - in falscher Reihenfolge - am Zielrechner angekommen.
Auf der Strecke, auf der Pakete 4 und 5 transportiert werden, tritt eine St&ouml;rung
auf.</TD>
<TD VALIGN=TOP><img src="tcpbsp4.gif"></TD>
</TR><TR>
<TD VALIGN=TOP><img src="tcpbsp5.gif"></TD>
<TD VALIGN=TOP>
Paket 4 ist bei der St&ouml;rung verloren gegangen. Paket 5 wird auf einer
anderen Route zum Zielnetz geschickt (w&auml;ren die Routen statisch am Router
eingetragen, ginge auch Paket 5 verloren).</TD>
</TR><TR>
<TD VALIGN=TOP>
Alle &uuml;berlebenden Pakete sind am Zielrechner angekommen. Das TCP-Protokoll
setzt die Pakete wieder in der richtigen Reihenfolge zusammen und fordert das
fehlende Paket 4 nochmals beim Sender an. F&uuml;r den Empf&auml;nger ergibt sich
ein kontinuierlicher Datenstrom.</TD>
<TD VALIGN=TOP><img src="tcpbsp6.gif"></TD>
</TR>
</TABLE>
<P>

<H4>TCP-Zustands&uuml;bergangsdiagramm</H4>
Den gesamte Lebenszyklus einer TCP-Verbindung beschreibt die folgende Grafik in einer
relativ groben Darstellung.
<P>
<center><img src="tcpzust.gif"></center>
<P>
Erkl&auml;rung der Zust&auml;nde:
<UL>
<li> LISTEN: Warten auf ein Connection Request.
<li> SYN-SENT: Warten auf ein passendes Connection Request,
nachdem ein SYN gesendet wurde.
<li>SYN-RECEIVED: Warten auf Best&auml;tigung des Connection Request
Acknowledgement, nachdem beide Teilnehmer ein Connection Request
empfangen und gesendet haben.
<li>ESTABLISHED: Offene Verbindung.
<li>FIN-WAIT-1: Warten auf ein Connection Termination Request des Kommunikationspartners
oder auf eine Best&auml;tigung des Connection Termination, das vorher gesendet wurde.
<li>FIN-WAIT-2: Warten auf ein Connection Termination Request des Kommunikationspartners.
<li>CLOSE-WAIT: Warten auf ein Connection Termination Request (CLOSE) der dar&uuml;berliegenden
Schicht.
<li>CLOSING: Warten auf ein Connection Termination Request des Kommunikationspartners.
LAST-ACK: Warten auf die Best&auml;tigung des Connection Termination Request, das zuvor an
den Kommunikationspartner gesendet wurde.
</ul>
<P>

<H3>Zeit&uuml;berwachung</H3>

In allen Protokollimplementierungen spielt die Zeit eine wichtige Rolle. So werden
alle Abl&auml;ufe zeitlich &uuml;berwacht. Dazu werden in der Protokollimplementierung
sogenannte "Timer" gestartet, deren Timeout zur Fehlerbehandlung führt.
<p>

<H4>Paketwiederholungs-Wecker oder Retransmission Timeout</H4>

In Weitverkehrsnetzen mit unterschiedlichsten Verbindungsarten, die noch dazu
zeitlichen Schwankungen unterworfen sind, ist die Wahl der Wartezeit auf
Best&auml;tigungen schwierig.
Der Retransmission Timeout (RTO) l&auml;uft ab, wenn der vorgegebene Zeitraum
zwischen dem Aussenden eines TCP-Pakets bis zum Eintreffen der dazugeh&ouml;rigen
Quittung &uuml;berschritten wird. In diesem Fall mu&szlig; das Paket noch einmal
gesendet werden. Allerdings darf der Zeitraum nicht fest definiert sein, da man
sonst TCP nicht &uuml;ber Netzwerke mit unterschiedlichen Laufzeiten betreiben
k&ouml;nnte - wenn man z.B. Ethernet und eine serielle Verbindung &uuml;ber mehrere
Gateways miteinander vergleicht, ergibt sich ein tausendfacher Unterschied in der
&Uuml;bertragungsrate. Daher wird in TCP bei jedem Paket die Zeit gemessen, die
zwischen Senden und Empfangen einer Quittung vergeht, die sogenannte <i>Round Trip Time
(RTT)</i>. Die so gemessene Zeit wird &uuml;ber eine Formel umgerechnet, die Spitzen
nach oben und unten herausfiltert, sich aber auch allm&auml;hlich an eine
verl&auml;ngerte oder verk&uuml;rzte Laufzeit anpa&szlig;t. Das Ergebnis ist die
<i>Smoothed Round Trip Time (SRTT)</i>, d.h. die mittlere Zeit, die f&uuml;r einen
Paketaustausch verstreicht. Diese Zeit wird nochmals skaliert, um weiteren Spielraum
f&uuml;r unvorhergesehene Verz&ouml;gerungen zu schaffen.
<PRE>
SRTT:     S = aS + (1 - a)R
RTO:      T = min[U, max[L,&szlig;S]]
          (L &lt; T &lt; U)
</PRE>
 S Smoothed Round Trip Time<BR>
 R Round Trip Time<BR>
 T Retransmission Timeout (z.B. 30 Sekunden)<BR>
 U Zeitobergrenze (z.B. 1 Sekunde)<BR>
 L Zeituntergrenze (z.B. 1 Minute)<BR>
 a Smoothing Factor (z.B. 0.9)<BR>
 &szlig; Scaling Factor (z.B. 2.0)<BR>
<P>
Die beiden Formeln werden durch den RFC 793 spezifiziert: zun&auml;chst den SRTT-Filter,
danach die Ermittlung des RTO. Falls nach der Wiederholung des Pakets der Wiederholungstimer
ein weiteres Mal abl&auml;uft, wird der RTO in der Regel bis zu zw&ouml;lfmal exponentiell
erh&ouml;ht. Erst wenn auch diese Erh&ouml;hung keinen Effekt zeigt, gilt die Verbindung als
unterbrochen.
<P>

<H4>Persistance Timer</H4>
Beim Austausch von Daten &uuml;ber TCP ist es im Prinzip m&ouml;glich, da&szlig;
das Empfangsfenster gerade auf 0 steht - und genau in diesem Moment ein Paket
verlorengeht, das das Fenster wieder &ouml;ffnen sollte. Als Ergebnis warten
dann beide TCPs bis in alle Ewigkeit aufeinander. Ein Gegenmittel dazu ist der
Persistenz-Timer, der in bestimmten Zeitabschnitten kleine TCP-Pakete
(1 Byte) abschickt und damit &uuml;berpr&uuml;ft, ob die Empf&auml;ngerseite wieder
bereit ist. Ist das Empfangsfenster nach wie vor 0, kommt eine negative Quittung
zur&uuml;ck; ist es gr&ouml;&szlig;er, k&ouml;nnen nach der positiven Quittung
weitere Daten gesendet werden.
<P>

<H4>Stillhaltezeit oder Quiet Time</H4>
Jede M&ouml;glichkeit der Verwechslung von Verbindungen durch im Netz herumirrende
&uuml;berholte TCP-Pakete sollte verhindert werden. Daher werden nach dem Abbau
von TCP-Verbindungen Portnummern erst wieder freigegeben, wenn eine bestimmte Zeitspanne,
die zweimal die "Maximum Segment Lifetime" (MSL) betr&auml;gt, vergangen ist. Die MSL
entspricht der Zeit, in UNIX die im TTL-Feld von IP eingetragen wird.
Der UNIX-Anwender bemerkt diese Wartezeit, wenn er eine Verbindung zwischen
gleichen Partnern (d.h. gleichen Portnummern) sofort nach dem Abbruch wieder
er&ouml;ffnen will. Das System teilt ihm dann mit, da&szlig; die verwendete
Portnummer noch belegt ist. Erst nach Ablauf von ca. 30 Sekunden ist ein erneuter
Verbindungsaufbau m&ouml;glich.
<P>

<H4>Keep Alive Timer und Idle Timer</H4>
Dabei handelt es sich um zwei nicht in der TCP-Spezifikation vorgesehene Wecker, die
aber in UNIX-Systemen implementiert sind. Beide stehen miteinander in Verbindung.
Der Keep Alive Timer bewirkt, da&szlig; in regelm&auml;&szlig;igen Zeitabst&auml;nden
ein leeres Paket abgeschickt wird, um das Bestehen der Verbindung zum Partner zu
&uuml;berpr&uuml;fen. Antwortet der Partnerrechner nicht, wird die Verbindung
nach Ablauf des Idle Timers abgebrochen. Eine Applikation aktiviert diese Timer mit
der KEEP_ALIVE-Option &uuml;ber die Socket-Schnittstelle.
In der folgenden Tabelle sind die Werte f&uuml;r die oben genannten Timer angegeben.
Dazu ist zu bemerken, da&szlig; die Dauer der Timer implementationsabh&auml;ngig ist
und nicht immer auf die unten angegebenen Werte eingestellt sein mu&szlig;.
<P>

<TABLE BORDER=1 CELLPADDING=3 CELLSPACING=0>
<TR><TH COLSPAN=2>Einstellungen der TCP-Timer (implementationsabh&auml;ngig)</TH></TR>
<TR><TH>Timer</TH><TH>Dauer [s]</TH></TR>
<TR><TD>Retransmission Timeout</TD><TD>dynamisch</TD></TR>
<TR><TD>Persistance Timer</TD><TD>5</TD></TR>
<TR><TD>Quiet Timer</TD><TD>30</TD></TR>
<TR><TD>Keep Alive Timer</TD><TD>45</TD></TR>
<TR><TD>Idle Timer</TD><TD>360</TD></TR>
</TABLE>
<P>


<H3>Algorithmen zur Steigerung der Effizienz</H3>

Zwischen einer TCP-Implementierung nach Spezifikation und einem optimierten TCP-Subsystem,
wie man es in UNIX-Systemen vorfindet, liegt ein weiter Weg. Zahllose Verbesserungen
sind in den Jahren in die UNIX-TCP-Implementierungen eingeflossen und neue Algorithmen
in Nachfolgeversionen integriert worden:
<P>

<H4>Acknowledgement Delay</H4>
Normalerweise sendet der Empf&auml;nger nach Erhalt eines Pakets ein Antwortpaket,
in dem die Gr&ouml;&szlig;e des Empfangsfensters verkleinert und die Daten quittiert
werden. Nach &Uuml;bergabe der Daten an den empfangenden Proze&szlig; werden die Datenpuffer
im System frei, was ein Absenden eines Pakets mit einer Vergr&ouml;&szlig;erung des
Empfangsfensters zur Folge hat. Hat das Programm die Daten verarbeitet, folgt in der
Regel kurz danach eine Antwort, es sind also f&uuml;r eine Transaktion in der Regel drei
Pakete notwendig. Man hat aber festgestellt, da&szlig; in manchen F&auml;llen, z.B. beim
Telnet- oder SSH-Betrieb, ein Verz&ouml;gern des Quittungspakets um 0,2 Sekunden
Vorteile bringt: nach dieser kurzen Wartezeit k&ouml;nnen alle drei Informationen -
Empfangsfenster, Quittung und Antwort - in einem einzigen Paket versendet werden. Damit
Datentransfers, die hohen Durchsatz ben&ouml;tigen, nicht gebremst werden, unterbleibt die
Verz&ouml;gerung, wenn das Empfangsfenster um mindestens 35% oder zwei maximale Pakete
ver&auml;ndert wurde.
<P>


<H4>Silly Window Syndrome Avoidance</H4>
In bestimmten Situationen werden Empfangsfensterangaben versendet, die derart klein sind,
da&szlig; das Netzwerk und Rechner von den vielen Quittungspaketen &uuml;ber Geb&uuml;hr
belastet werden. Um das zu verhindern, wird das Empfangsfenster nur dann wieder
vergr&ouml;&szlig;ert, wenn ausreichend Platz (mehr als 1/4 des Datenpuffers oder ein
maximales Paket) zur Verf&uuml;gung steht. Desgleichen verh&auml;lt sich auch der
Sender konservativ und sendet nur, wenn das angebotene Fenster ausreichend gro&szlig; ist.
<P>

<H4>Nagle Algorithmus oder Small Packet Avoidance</H4>
Benannt nach seinem Erfinder John Nagle, versucht dieser Algorithmus, das Versenden von 
kleinen TCP-Paketen zu verhindern. Wenn bestimmte Anwendungen nur sehr kleine Pakete
versenden, ist der Header meist größer als die Nutzdaten. Daher versucht der Algorithmus 
mehrere Pakete zusammenzufassen. Das erste Paket wird immer sofort ausgesendet, weitere Daten 
aber auf Senderseite so lange gepuffert, bis ein volles Paket geschickt werden kann oder 
eine Quittung f&uuml;r das vorhergehende Paket eingetroffen ist. Ist ein Paket nicht voll, 
dann wird es gesendet, wenn keine unbestätigten Pakete mehr unterwegs sind. Probleme ergeben 
sich jedoch bei Anwendungen, die viele kleine Nachrichten abschicken, ohne eine Antwort 
zur&uuml;ckzuerhalten (z. B. SSH). In diesem Fall lässt sich der Nagle-Algorithmus 
abschalten. 

<H4>Slow Start with Congestion Avoidance</H4>
Diese miteinander verbundenen Algorithmen, manchmal auch als Jacobson-Algorithmen
bezeichnet, sind erst in j&uuml;ngster Zeit bekannt geworden und in erster
Linie f&uuml;r langsame Netzwerke und den Betrieb von Netzen mit Gateways von
Bedeutung.  Man hatte in den letzten Jahren beobachtet, da&szlig; das Internet mit
steigender Belastung immer weniger Datendurchsatz lieferte und zum Teil sogar
nahezu zusammenbrach. Als man die Vorg&auml;nge n&auml;her betrachtete, wurde
festgestellt, da&szlig; mehr als die H&auml;lfte der Daten Wiederholungen
verlorengegangener TCP-Pakete waren. Was war geschehen? Ein Netzwerkpfad -
Datenpuffer vom Sender &uuml;ber m&ouml;gliche Gateways bis hin zum
Empf&auml;nger - kann nur eine endliche Datenmenge aufnehmen.
Wenn ein Gateway oder ein Host sehr durch Verkehr belastet sind, kann es
vorkommen, da&szlig; nicht gen&uuml;gend Pufferplatz zur Aufnahme von Paketen
vorhanden ist. In diesem Fall werden die Pakete vom Gateway verworfen,
woraufhin der Absender des Pakets nach Ablauf des Retransmission Timeouts
eine Wiederholung vornimmt und dadurch insgesamt die Belastung des Netzes weiter
unn&ouml;tig steigert. Der Slow Start-Algorithmus versucht nun zu ermitteln, wieviele
Daten zu einem Zeitpunkt in Richtung Empf&auml;nger unterwegs sein k&ouml;nnen, ohne
da&szlig; es dabei zu Verlusten kommt. Erreicht wird das &uuml;ber eine allm&auml;hliche
Steigerung der ausgesendeten Datenmenge bis zu einem Punkt, an dem sich ein
gleichm&auml;ssiger Datenflu&szlig; ohne Wiederholungen ergibt. Wo fr&uuml;her
die Menge der auszusendenden Daten durch die Gr&ouml;&szlig;e bestimmt wurde,
ist jetzt die Aufnahmekapazit&auml;t des Netzwerkpfads, das sogenannte "Congestion Window",
die bestimmende Gr&ouml;&szlig;e, wobei das Congestion Window immer kleiner oder gleich
dem Empfangsfenster (Receive Window) ist. Hat sich das Congestion Window eingependelt,
wird es erst wieder ver&auml;ndert, wenn auftretende Wiederholungen ein Ansteigen der
Netzwerklast signalisieren: in diesem Fall tritt die "Congestion Avoidance" in Kraft.
Gleichzeitig wird durch st&auml;ndiges vorsichtiges Vergr&ouml;&szlig;ern des Congestion
Windows versucht, unter Umst&auml;nden freiwerdende Ressourcen zu benutzen. Aufgrund des
konservativen Verhaltens l&auml;&szlig;t sich der Durchsatz um bis zu 30% steigern und
die Anzahl der wiederholten Pakete um &uuml;ber 50% senken. In Verbindung mit diesen
beiden Algorithmen wurde auch die Ermittlung des Retransmission Timeouts verbessert.
Dieser Wert pa&szlig;t sich jetzt schneller an Ver&auml;nderungen in der RTT an und
verhindert zus&auml;tzliche Paketwiederholungen.
<P>


<H3>Ports f&uuml;r jeden Dienst</H3>
Server-Prozesse lauschen bei UDP und TCP auf bestimmten Portnummern. Per
&Uuml;bereinkunft werden dazu Ports niedriger Nummern verwendet. F&uuml;r
die Standarddienste sind diese Portnummern in den RFCs festgeschrieben.
Ein Port im "listen"-Modus ist gewisserma&szlig;en eine halboffene Verbindung.
Nur Quell-IP und Quellport sind bekannt. Der Serverproze&szlig; kann vom
Betriebssystem dupliziert werden, so da&szlig; weitere Anfragen auf diesem
Port behandelt werden k&ouml;nnen.
<P>
<ul>
<li>Die Portnummern werden auf dem Host-System konfiguriert und haben zwei Funktionen:
  <ul>
  <li>Allgemein verf&uuml;gbare Dienste werden &uuml;ber 'well known' Ports
       (--&gt; feste, per RFC zugeordnete Portnummer) erreichbar. Sie stehen
       also f&uuml;r ein Protokoll, das &uuml;ber die Nummer direkt
       angesprochen wird
  <li>oder sie werden beim Verbindungsaufbau vereinbart und einem
       Server-Programm zugewiesen
  </ul>
<li>Die Portangabe ist n&ouml;tig, wenn mehrere Serverprogramme auf dem
adressierten Rechner laufen.
<li>Die Portnummer steht im TCP-Header und ist 16 Bit gro&szlig;. Theoretisch
k&ouml;nnen also bis zu 65535 TCP-Verbindungen auf einem Rechner mit einer einzigen
IP-Adresse aufgebaut werden.
<li>Portnummern werden oft auch bei der Konfiguration von Internet-Clients
als Parameter gefordert.
<li>Die Client-Prozesse verwenden normalerweise freie Portnummern, die vom
lokalen Betriebssystem zugewiesen werden (Portnummer &gt; 1024).
</ul>
<p>
<center><img src="ports.gif"></center>
<p>
Die "well known" Portnummern (0 bis 1023), die weltweit eindeutig adressiert
werden m&uuml;ssen, werden durch die IANA (Internet Assigned Numbers Authority)
vergeben. Einige Beispiele f&uuml;r TCP-Ports (UDP verwendet eine andere
Zuordnung):
<p>
<table border=1 cellspacing=0 cellpadding=3 align=center>
<tr><th>Portnummer</th><th>Protokoll</th></tr>
<tr><td>20</td><td>FTP (Daten)</td></tr>
<tr><td>21</td><td>FTP (Befehle)</td></tr>
<tr><td>22</td><td>Secure Shell</td></tr>
<tr><td>23</td><td>Telnet</td></tr>
<tr><td>25</td><td>SMTP</td></tr>
<tr><td>53</td><td>DNS-Server</td></tr>
<tr><td>80</td><td>HTTP (Proxy-Server)</td></tr>
<tr><td>110</td><td>POP3</td></tr>
<tr><td>143</td><td>IMAP</td></tr>
</table>
<p>
Eine vollst&auml;ndige Portliste erh&auml;lt man bei
<a href="http://www.isi.edu/in-notes/iana/assignments/port-numbers" target=_blank>http://www.isi.edu/in-notes/iana/assignments/port-numbers</a>.
<p>
<table border=1 cellspacing=0 cellpadding=3 align=center width="80%">
 <tr>
  <td valign=top>Well Known Ports</td>
  <td valign=top>1&nbsp;&nbsp;1023</td>
  <td valign=top>Diese Ports sind fest einer Anwendung oder einem Protokoll
  zugeordnet. Die feste Zuordnung erm&ouml;glicht eine einfachere Konfiguration.
  Die Verwaltung dieser Ports &uuml;bernimmt die Internet Assigned Numbers Authority
  (IANA).</td>
 </tr>
 <tr>
  <td valign=top>Registered Ports</td>
  <td valign=top>1024&nbsp;&nbsp;49151</td>
  <td valign=top>Diese Ports sind f&uuml;r diverse Dienste vorgesehen.</td>
 </tr>
 <tr>
  <td valign=top>Dynamically Allocated Ports</td>
  <td valign=top>49152&nbsp;&nbsp;65535</td>
  <td valign=top>Diese Ports werden dynamisch zugewiesen. Jeder Client kann
  diese Ports nutzen. Wenn ein Prozess einen Port benötigt, fordert er diesen
  bei seinem Host an.</td>
 </tr>
</table>
<p>
IP-Adresse und Portnummer definieren einen Kommunikationsendpunkt, der in der
TCP/IP-Welt "Socket" genannt wird.
Die Grenze zwischen der Anwendungsschicht und der Transportschicht ist in den meisten
Implementierungen zugleich die Grenze zwischen dem Betriebssystem und den
Anwendungsprogrammen. Im OSI-Modell ist diese Grenze in etwa die Grenze zwischen
den Schichten 4 und 5. Daher ordnet man IP meist ungef&auml;hr in die Ebene 3 und
TCP ungef&auml;hr in Ebene 4 des OSI-Modells ein. Da TCP/IP jedoch &auml;lter und
einfacher als das OSI-Modell ist, kann diese Einordnung nicht genau passen.
<P>

<H4>Port-Scans</H4>
Beim Scanning wird versucht, offene Ports eines Rechners zu ermitteln. Das ist
meist auch der erste Schritt eines Angreifers, der in einem Rechner eindringen will.
Deshalb dient ein Portscan auch dazu, die Sicherheit des eigenen Systems zu
&uuml;berpr&uuml;fen. Bei den Scanning-Methoden wurden Verfahren entwickelt, bei denen
versucht wird, den Scanvorgang auf dem gescannten Rechern unentdeckt zu lassen.
<UL>
<LI><I>TCP-Connect-Scan</I><BR>
Bei dieser Methode wird versucht, eine Verbindung zu einem Port auf
dem Zielrechner aufzubauen. Der Scanner l&auml;&szlig;t einen vollst&auml;ndigen
Dreiwege-Handshake zu, bevor er die Verbindung wieder unterbricht.
Diese Art der Scans ist allerdings sehr leicht zu entdecken und
kann auch leicht mit Hilfe von Firewalls abgeblockt werden.
<P>
<LI><I>TCP-SYN-Scan</I><BR>
Diese Methode wird oft als "Half-Open-Scan" bezeichnet. Der Scanner sendet
ein SYN-Packet an den Zielrechner, wie bei einem ganz normalen Verbindungsaufbau.
Wenn der Zielrechner mit einem RST antwortet, wei&szlig; der Scanner, da&szlig; dieser
Port geschlossen ist. Antwortet der Zielrechner jedoch mit einem SYN/ACK, handelt
es sich um einem offenen Port. In diesem Falle wird die Verbindung vom Scanner sofort
mit einem RST beendet. Diese Art des Scannens ist nicht ganz so leicht auf dem
Zielrechner zu entdecken wie der Connect Scan.
<P>

<LI><I>Stealth FIN-Scan</I><BR>
Stealth Scans sollen vom Zielrechner nicht entdeckt werden. Allerdings
gibt es Programme, die genau solche Scans entdecken. Beim "Stealth FIN Scan"
wird nur ein Packet mit einem FIN-Flag, ohne begleitendes ACK-Flag gesendet.
Diese Art von Paket ist unzul&auml;ssig. Wenn der Port offen ist, wird das Paket des
Scanners vom Zielrechner ignoriert. Wenn der Port geschlossen ist, antwortet der
Zielrechner mit einem RST-Paket.
<P>
<LI><I>Stealth Xmastree-Scan</I><BR>
Bei diesem Scan sind die FIN-, URG-, und PUSH-Flags alle gemeinsam gesetzt. Auch
dieses Paket ist unzul&auml;ssig. Wenn der Port offen ist, wird das Paket des
Scanners vom Zielrechner ignoriert. Wenn der Port geschlossen ist, antwortet der
Zielrechner mit einem RST-Paket.
<P>
<LI><I>Stealth Null-Scan</I><BR>
Bei diesem Scan sind alle Flags auf Null gesetzt. Alles Weitere wie oben.
<P>
<LI><I>ACK-Scan</I><BR>
Dieser Scan wird verwendet, um Firewalls zu testen ob sie mit "stateful inspection"
arbeiten (z.B. Firewall 1) oder ob es sich nur um einfache Packetfilter handelt,
die eingehende SYN Packete verwerfen. Der ACK-Scan sendet
ein Packet mit gesetztem ACK-Flag und zuf&auml;lliger Sequenznummer an die Ports.
Wenn das Paket von der Firewall durchgelassen wird, sendet der Server ein RST, da
das Paket nicht zuzuordnen ist. In diesem Fall wird der Port als "ungefiltert"
klassifiziert. Wenn die Firewall den Status einer Verbindung &uuml;berwacht, wird
das Paket ohne eine Antwort vom Zielrechner abgewiesen oder es wird dem
Scanner mit einer ICMP Destination unreachable Nachricht geantwortet.
</UL>
<P>

<H2><A NAME="8.7">PPP</A></H2>
Das <B>Point to Point Protocol</B> (PPP) findet gegenw&auml;rtig vielfachen
Einsatz. Es arbeitet mit drei Teilprotokollen:
<UL>
<LI> Das Data Link Layer Protocol erm&ouml;glicht die &Uuml;bertragung
(Encapsulation) von Datagrammen &uuml;ber serielle Verbindungen mit Hilfe von HDLC.
<LI> Das Link Control Protocol (LCP) steuert Aufbau, Konfiguration und
Test der Verbindung.
<LI> Das Network Control Protocol (NCP) erm&ouml;glicht die &Uuml;bertragung
von Konfigurationsdaten f&uuml;r verschiedene Protokolle der Vermittlungsschicht.
</UL>
PPP ist geeignet f&uuml;r den simultanen Einsatz verschiedener Protokolle der
Vermittlungsschicht, es ist also ein so genanntes "Multi-Protokoll-Protokoll".
Es ist ein zustandsorientiertes Protokoll:
<P>
<CENTER><IMG SRC="ppp2.gif"></CENTER>
<P>
PPP ist ein verbindungsorientiertes Protokoll und unterscheidet drei Phasen
Verbindungsaufbau, Daten&uuml;bertragung und Verbindungsabbau. Die Realisierung
dieser Phasen unter Ber&uuml;cksichtigung der Teilprotokolle von PPP zeigt
das Bild unten.
<OL>
<LI> Der anrufende PPP-Knoten sendet LCP-Rahmen zum Aufbau und zur Konfiguration der
Verbindung (Data Link). Die LCP-Pakete verf&uuml;gen &uuml;ber ein Feld mit
Konfigurations-Optionen. Zu diesen Optionen z&auml;hlen beispielsweise die
Maximum Transmission Unit (MTU). Hierbei handelt es sich um die Angabe, ob
bestimmte PPP-Felder komprimiert werden, oder das Link Authentication Protocol
(LAP).
<LI>In einer optionalen Phase wird &uuml;berpr&uuml;ft, ob die Qualit&auml;t der
Verbindung f&uuml;r den Aufbau einer &Uuml;bertragung der Pakete der Vermittlungsschicht
ausreicht.
<LI> Es folgt eine Authentifizierungsphase.
<LI> Der anrufende PPP-Knoten sendet NCP-Rahmen zur Auswahl und Konfiguration des zu
&uuml;bertragenden Protokolls der Vermittlungsschicht.
<LI> Nun k&ouml;nnen die Daten &uuml;bertragen werden.
<LI> Die Verbindung bleibt bis zur Beendigung durch LCP- oder NCP-Rahmen bestehen
oder bis ein externes Ereignis auftritt. Zu diesen kann eine Unterbrechung durch den
Anwender, der Abbruch der &Uuml;bertragung oder der Ablauf eines "Inactivity Timers"
z&auml;hlen.
</OL>
<P>
<CENTER><IMG SRC="ppp3.gif"></CENTER>
<P>
PPP unterst&uuml;tzt verschiedene Protokolle zur Authentifizierung. Dabei realisieren
alle Protokolle nur eine einseitige Authentifizierung. Dies bedeutet, dass sich der
anrufende Knoten bzw. dessen Anwender authentifizieren und der angerufene Knoten diese
Authentifizierung &uuml;berpr&uuml;fen muss. Der angerufene Knoten authentifiziert
sich durch seine Verf&uuml;gbarkeit unter dieser physischen Verbindung. Die
wichtigsten Authentifizierungsprotokolle sind:
<UL>
<LI>das Password Authentication Protocol (PAP),
<LI>das Shiva Password Authentication Protocol(SPAP),
<LI>das Challenge Handshake Authentication Protocol (CHAP) sowie
<LI>eine Variante des CHAP, das Microsoft-CHAP (MS-CHAP), das in zwei Versionen vorliegt.
</UL>
<P>
Die Authentifzierungsprotokolle mit der gr&ouml;&szlig;ten Verbreitung sind PAP und CHAP. Auch
MS-CHAPv2 ist recht h&auml;ufig anzutreffen. Die meisten ISPs fragen beim einw&auml;hlenden Host
zun&auml;chst CHAP an.
<P>
<B>PAP</B> unterst&uuml;tzt ein so genanntes Zwei-Wege-Handshake. Die Kombination "Username/Password"
wird vom anrufenden Knoten so lange &uuml;bertragen, bis die Authentifizierung best&auml;tigt
oder abgelehnt wird. Im Falle der Ablehnung wird die Verbindung abgebrochen. Dieses Vorgehen
bietet allerdings nur eine geringe Sicherheit: Das Passwort wird unverschl&uuml;sselt &uuml;bertragen.
Es ist eine beliebige Anzahl von Wiederholungen m&ouml;glich. Und schlie&szlig;lich werden
H&auml;ufigkeit und Geschwindigkeit der Versuche vom anrufenden Knoten bestimmt, so dass ein
Brute-Force-Angriff m&ouml;glich wird.
<P>
<B>CHAP</B> bietet ein erh&ouml;htes Sicherheitsniveau im Rahmen eines so genannten Drei-Wege-Handshakes.
Der anrufende Knoten darf erst die Authentifizierung beginnen, wenn er vom angerufenen Knoten dazu
aufgefordert wurde. Auf diese Weise werden H&auml;ufigkeit und Geschwindigkeit der Versuche vom
angerufenen Knoten bestimmt. Zus&auml;tzlich wird die Kombination "Username/Password" nur im Rahmen
einer Ein-Wege-Hash-Funktion (Message Digest 5, MD5) &uuml;bertragen. Die &Uuml;berpr&uuml;fung
kann also nicht nur beim Verbindungsaufbau, sondern auch periodisch w&auml;hrend der Verbindung
stattfinden.
<P>

<H2><A NAME="8.8">IP Next Generation</A></H2>
von Heiko Holtkamp (<a href="http://www.rvs.uni-bielefeld.de/~heiko/tcpip/tcpip.pdf">
http://www.rvs.uni-bielefeld.de/~heiko/tcpip/tcpip.pdf</a>)
<P>
Das rasche (exponentielle Wachstum) des Internet zwingt dazu, das Internet Protokoll
in der Version 4 (IPv4) durch ein Nachfolgeprotokoll (IPv6 Internet Protocol
Version 6) zu ersetzen.
<P>
Vinton Cerf (der 'Vater' des Internet) bezeichnet in einem Interview mit der Zeitschrift
c't das Internet <I>"(...) als die wichtigste Infrastruktur f&uuml;r alle Arten
von Kommunikation."</I>. Auf die Frage, wie man sich die neuen Kommunikationsdienste
des Internet vorstellen k&ouml;nne, antwortete Cerf:
<P>
<BLOCKQUOTE>
<I>"Am spannendsten finde ich es, die ganzen Haushaltsger&auml;te ans Netz anzuschlie&szlig;en. Ich denke
dabei nicht nur daran, da&szlig; der K&uuml;hlschrank sich in Zukunft mit der Heizung austauscht, ob es in der
K&uuml;che zu warm ist. Stromgesellschaften k&ouml;nnten beispielsweise Ger&auml;te wie Geschirrsp&uuml;lmaschinen
kontrollieren und ihnen Strom genau dann zur Verf&uuml;gung stellen, wenn gerade keine Spitzennachfrage herrscht.
Derartige Anwendungen h&auml;ngen allerdings davon ab, da&szlig; sie zu einem erschwinglichen Preis angeboten werden.
Das ist nicht unbedingt ferne Zukunftsmusik; die Programmierer m&uuml;&szlig;ten eigentlich nur damit anfangen,
endlich Software f&uuml;r intelligente Netzwerkanwendungen zu schreiben. Und nat&uuml;rlich mu&szlig; die Sicherheit
derartiger Systeme garantiert sein. Schlie&szlig;lich m&ouml;chte ich nicht, da&szlig; die Nachbarkinder mein Haus
programmieren!"</I>
</BLOCKQUOTE>
<P>
Auf die Internet Protokolle kommen in der n&auml;chsten Zeit also v&ouml;llig neue
Anforderungen zu.
<P>

<H2>Classless InterDomain Routing - CIDR</H2>
<P>Der Verknappung der Internet-Adressen durch die st&auml;ndig steigende Benutzerzahl
wird zun&auml;chst versucht, mit dem <I>Classless Inter-Domain Routing (CIDR)</I>
entgegen zu wirken.
Durch die Vergabe von Internet-Adressen in Klassen (A,B,C,...) wird eine gro&szlig;e Anzahl
von Adressen verschwendet. Hierbei stellt sich vor allem die Klasse B als Problem dar.
Viele Firmen nehmen ein Netz der Klasse B f&uuml;r sich in Anspruch, da ein Klasse A Netz
mit bis zu 16 Mio. Hosts selbst f&uuml;r eine sehr gro&szlig;e Firma &uuml;berdimensioniert
scheint, ein Netz der Klasse C mit 254 Hosts aber zu klein.
<P>
Ein gr&ouml;&szlig;erer Host-Bereich f&uuml;r Netze der Klasse C (z. B. 10 Bit, 1022 Hosts
pro Netz) h&auml;tte das Problem der knapper werdenden IP-Adressen vermutlich gemildert.
Ein anderes Problem w&auml;re dadurch allerdings entstanden: die Eintr&auml;ge der
Routing-Tabellen h&auml;tten sich um ein Vielfaches vermehrt.
<P>
Ein anderes Konzept ist das Classless Inter-Domain Routing (RFC 1519): die verbleibenden
Netze der Klasse C werden in Bl&ouml;cken variabler Gr&ouml;&szlig;e zugewiesen. Werden
beispielsweise 2000 Adressen ben&ouml;tigt, so k&ouml;nnen einfach acht aufeinanderfolgende
Netze der Klasse C vergeben werden. Zus&auml;tzlich werden die verbliebenen Klasse-C-Adressen
restriktiver und strukturierter vergeben (RFC 1519). Die Welt ist dabei in vier Zonen
aufgeteilt, von denen jede einen Teil des verbliebenen Klasse C Adre&szlig;raums erh&auml;lt:
<P>
<CENTER>
<TABLE BORDER=1 CELLPADDING=4 BGCOLOR="#CCCCCC">
<TR><TD>194.0.0.0 - 195.255.255.255</TD><TD>Europa</TD></TR>
<TR><TD>198.0.0.0 - 199.255.255.255</TD><TD>Nordamerika</TD></TR>
<TR><TD>200.0.0.0 - 201.255.255.255</TD><TD>Mittel- und S&uuml;damerika</TD></TR>
<TR><TD>202.0.0.0 - 203.255.255.255</TD><TD>Asien und pazifischer Raum</TD></TR>
<TR><TD>204.0.0.0 - 223.255.255.255</TD><TD>Reserviert f&uuml;r zuk&uuml;nftige Nutzung</TD></TR>
</TABLE>
</CENTER>
<P>
Jede der Zonen erh&auml;lt dadurch in etwa 32 Millionen Adressen zugewiesen. Vorteil bei
diesem Vorgehen ist, da&szlig; die Adressen einer Region im Prinzip zu einem Eintrag in
den Routing-Tabellen komprimiert worden sind und jeder Router, der eine Adresse
au&szlig;erhalb seiner Region zugesandt bekommt diese getrost ignorieren darf.
<P>

<H3>Internet Protokoll Version 6 - IPv6 (IP Next Generation, IPnG)</H3>
Der vorrangige Grund f&uuml;r eine &Auml;nderung des IP-Protokolls ist auf den
begrenzten Adre&szlig;raum und das Anwachsen der Routing-Tabellen zur&uuml;ckzuf&uuml;hren.
CIDR schafft hier zwar wieder etwas Luft, dennoch ist klar absehbar, da&szlig; auch
diese Ma&szlig;nahme nicht ausreicht, um die Verknappung der Adressen f&uuml;r eine
l&auml;ngere Zeit in den Griff zu bekommen. Weitere Gr&uuml;nde f&uuml;r eine
&Auml;nderung des IP-Protokolls sind die neuen Anforderungen an das Internet, denen IPv4
nicht gewachsen ist. Streaming-Verfahren wie Real-Audio oder Video-on-Demand erfordern
das Festlegen eines Mindestdurchsatzes, der nicht unterschritten werden darf. Bei IPv4
kann so ein "Quality of Service" jedoch nicht definiert - und damit auch nicht
sichergestellt - werden. Die <I>IETF (Internet Engineering Task Force)</I> begann
deshalb 1990 mit der Arbeit an einer neuen Version von IP. Die wesentlichen Ziele des
Projekts sind:
<UL>
<LI>Unterst&uuml;tzung von Milliarden von Hosts, auch bei ineffizienter Nutzung des Adre&szlig;raums
<LI>Reduzierung des Umfangs der Routing-Tabellen
<LI>Vereinfachung des Protokolls, damit die Router Pakete schneller abwickeln k&ouml;nnen
<LI>H&ouml;here Sicherheit (Authentifikation und Datenschutz) als das heutige IP
<LI>Mehr Gewicht auf Dienstarten, insbesondere f&uuml;r Echtzeitanwendungen
<LI>Unterst&uuml;tzung von Multicasting durch die M&ouml;glichkeit, den Umfang zu definieren
<LI>M&ouml;glichkeit f&uuml;r Hosts, ohne Adre&szlig;&auml;nderung auf Reise zu gehen (Laptop)
<LI>M&ouml;glichkeit f&uuml;r das Protokoll, sich zuk&uuml;nftig weiterzuentwickeln
<LI>Unterst&uuml;tzung der alten und neuen Protokolle in Koexistenz f&uuml;r Jahre
</UL>
Im Dezember 1993 forderte die IETF mit RFC 1550 die Internet-Gemeinde dazu auf,
Vorschl&auml;ge f&uuml;r ein neues Internet Protokoll zu machen. Auf die Anfrage
wurde eine Vielzahl von Vorschl&auml;gen eingereicht. Diese reichten von nur
geringf&uuml;gigen &Auml;nderungen am bestehenden IPv4 bis zur vollst&auml;ndigen
Abl&ouml;sung durch ein neues Protokoll. Aus diesen Vorschl&auml;gen wurde von der
IETF das <I>Simple Internet Protocol Plus (SIPP)</I> als Grundlage f&uuml;r die neue
IP-Version ausgew&auml;hlt.
<P>
Als die Entwickler mit den Arbeiten an der neuen Version des Internet Protokolls begannen,
wurde ein Name f&uuml;r das Projekt bzw. das neue Protokoll ben&ouml;tigt. Angeregt durch
die Fernsehserie "Star Trek - Next Generation", wurde als Arbeitsname <I>IP - Next
Generation (IPnG)</I> gew&auml;hlt. Schlie&szlig;lich bekam das neue IP eine offizielle
Versionsnummer zugewiesen: IP Version 6 oder kurz IPv6. Die Protokollnummer 5 (IPv5)
wurde bereits f&uuml;r ein experimentelles Protokoll verwendet.
<P>

<H3>Die Merkmale von IPv6</H3>
Viele der Merkmale von IPv4 bleiben in IPv6 erhalten. Trotzdem ist IPv6 im allgemeinen
nicht mit IPv4 kompatibel, wohl aber zu den dar&uuml;berliegenden Internet-Protokollen,
insbesondere den Protokollen der Transportschicht (TCP, UDP). Die wesentlichen Merkmale
von IPv6 sind:
<UL>
<LI><B>Adre&szlig;gr&ouml;&szlig;e:</B> Statt bisher 32 Bit stehen nun 128 Bit
f&uuml;r die Adressen bereit. Theoretisch lassen sich damit 2<SUP>128</SUP>
= 3.4*10<SUP>38</SUP> Adressen vergeben.
<LI><B>Header-Format:</B> Der IPv6-Header wurde vollst&auml;ndig ge&auml;ndert. Der
Header enth&auml;lt nur sieben statt bisher 13 Felder. Diese &Auml;nderung erm&ouml;glicht
die schneller Verarbeitung der Pakete im Router. Im Gegensatz zu IPv4 gibt es bei IPv6
nicht mehr nur einen Header, sondern mehrere Header. Ein Datengramm besteht
aus einem Basis-Header, sowie einem oder mehreren Zusatz-Headern, gefolgt von den Nutzdaten.
<P>
<IMG SRC="ipv6dgram.gif">
<P>
<LI><B>Erweiterte Unterst&uuml;tzung von Optionen und Erweiterungen:</B> Die Erweiterung
der Optionen ist notwendig geworden, da einige der bei IPv4 notwendige Felder nun optional
sind. Dar&uuml;ber hinaus unterscheidet sich auch die Art, wie die Optionen dargestellt
werden. F&uuml;r Router wird es damit einfacher, Optionen, die nicht f&uuml;r
sie bestimmt sind, zu &uuml;berspringen.
<LI><B>Dienstarten:</B> IPv6 legt mehr Gewicht auf die Unterst&uuml;tzung von
Dienstarten. Damit kommt IPv6 den Forderungen nach einer verbesserten Unterst&uuml;tzung
der &Uuml;bertragung von Video- und Audiodaten entgegen, z. B. durch eine Option zur
Echtzeit&uuml;bertragung.
<LI><B>Sicherheit:</B> IPv6 beinhaltet nun im Protokoll selbst Mechanismen zur sicheren
Daten&uuml;bertragung. Wichtige neue Merkmale von IPv6 sind hier Authentifikation,
Datenintegrit&auml;t und Datenverl&auml;sslichkeit.
<LI><B>Erweiterbarkeit:</B> IPv6 ist ein erweiterbares Protokoll. Bei der Spezifikation
des Protokolls wurde nicht versucht, alle m&ouml;glichen Einsatzfelder f&uuml;r das
Protokoll in die Spezifikation zu integrieren. &Uuml;ber Erweiterungs-Header kann das
Protokoll erweitert werden.
</UL>
<P>

<H3>Aufbau des IPv6-Basis-Headers</H3>
Im IPv6 wird im Vergleich zum IPv4 auf eine Checksumme verzichtet,
um den Routern die aufwendige &Uuml;berpr&uuml;fung - und damit Rechenzeit
- zu ersparen. Ein &Uuml;bertragungsfehler muss deshalb in den h&ouml;heren
Schichten erkannt werden. Der Paketkopf ist durch die Verschlankung
nur doppelt so gro&szlig;, wie ein IPv4-Header.
<P>
<center><IMG SRC="ipv6mainheader.gif"></center>
<P>
<DL>
<DT><B>Version:</B></DT>
<DD>
Mit dem Feld <I>Version</I> k&ouml;nnen Router &uuml;berpr&uuml;fen, um welche
Version des Protokolls es sich handelt. F&uuml;r ein IPv6-Datengramm ist dieses Feld
immer 6 und f&uuml;r ein IPv4-Datengramm dementsprechend immer 4. Mit diesem Feld
ist es m&ouml;glich f&uuml;r eine lange Zeit die unterschiedlichen Protokollversionen
IPv4 und IPv6 nebeneinander zu verwenden. &Uuml;ber die Pr&uuml;fung des Feldes
Version k&ouml;nnen die Daten an das jeweils richtige "Verarbeitungsprogramm"
weitergeleitet werden.
<DT><B>Priority:</B></DT>
<DD>
Durch das Feld <I>Priority</I> (oder <I>Traffic Class</I>) kann angegeben
werden, ob ein Paket bevorzugt behandelt werden mu&szlig;. Dies ist f&uuml;r die
Anpassung des Protokolls an die neuen Real Time Anwendungen n&ouml;tig geworden.
Damit k&ouml;nnen zum Beispiel Videodaten den E-Maildaten vorgezogen werden. Bei
einem Router unter Last besteht damit die M&ouml;glichkeit der Flusskontrolle.
Pakete mit kleinerer Priorit&auml;t werden verworfen und m&uuml;ssen wiederholt
werden.Mit den vier Bit lassen sich 16 Priorit&auml;ten angeben, wovon
1 bis 7 f&uuml;r "Non Real Time"- und 8 bis 15 f&uuml;r "Real Time"-Anwendungen
reserviert sind. Die Zahl Null gibt an, dass die Priorit&auml;t des
Verkehrs nicht charakterisiert ist.
<DT><B>Flow Label</B></DT>
<DD>
Mit Hilfe des Feldes <I>Flow Label</I> k&ouml;nnen Eigenschaften des Datenflusses
zwischen Sender und Empf&auml;nger definiert werden. Das Flow
Label selbst ist nur eine Zufallszahl. Die Eigenschaften m&uuml;ssen
durch spezielle Protokolle oder durch den Hop-by-Hop-Header in den Routern
eingestellt werden. Eine Anwendung ist zum Beispiel, da&szlig; die Pakete eines
Flusses immer den gleichen Weg im Netz nehmen. Durch Speichern der Informationen
f&uuml;r das jeweilige Flow-Label, mu&szlig; der Router bestimmte Berechnungen nur
f&uuml;r das erste Paket ausf&uuml;hren, und kann danach f&uuml;r alle Folgepakete
die Resultate verwenden. Erst die Einf&uuml;hrung des Flow Labels erm&ouml;glicht
die Einf&uuml;hrung von Quality-of-Service-Parametern im IP-Verkehr.
<DT><B>Payload Length</B></DT>
<DD>
Das Feld <I>Payload Length (Nutzdatenl&auml;nge)</I> gibt an, wie viele Bytes
dem IPv6-Basis-Header folgen, der IPv6-Basis-Header ist ausgeschlossen. Die
Erweiterungs-Header werden bei der Berechnung der Nutzdatenl&auml;nge mit einbezogen.
Das entsprechende Feld wird in der Protokollversion 4 mit <I>Total Length</I> bezeichnet.
Allerdings bezieht IPv4 den 20 Byte gro&szlig;en Header auch in die Berechnung ein,
wodurch die Bezeichnung "total length" gerechtfertigt ist.
<DT><B>Next Header</B></DT>
<DD>
Das Feld <I>Next Header</I> gibt an, welcher Erweiterungs-Header dem IPv6-Basis-Header
folgt. Jeder folgende Erweiterungs-Header beinhaltet ebenfalls ein Feld Next Header, das
auf den nachfolgenden Header verweist. Beim letzten IPv6-Header, gibt das Feld an, welches
Transportprotokoll (z.B. TCP oder UDP) folgt.
<DT><B>Hop Limit</B></DT>
<DD>
Im Feld <I>Hop Limit</I> wird festgelegt, wie lange ein Paket &uuml;berleben darf.
Der Wert des Feldes wird von jedem Router vermindert. Ein Datengramm wird verworfen,
wenn das Feld den Wert Null hat. IPv4 verwendete hierzu das Feld <I>Time to Live</I>.
Die Bezeichnung bringt mehr Klarheit, da schon in IPv4 die Anzahl Hops gez&auml;hlt
und nicht die Zeit gemessen wurde.
<DT><B>Source Address, Destination Address</B></DT>
<DD>
Die beiden Felder f&uuml;r <I>Quell-</I> und <I>Zieladresse</I> dienen zur
Identifizierung des Senders und Empf&auml;ngers eines IP-Datengramms. Bei IPv6 sind
die Adressen vier mal so gro&szlig; wie IPv4: 128 Bit statt 32 Bit.
</DL>
<P>
Das Feld <I>Length (Internet Header Length - IHL)</I> von IPv4 ist nicht
mehr vorhanden, da der IPv6-Basis-Header eine feste L&auml;nge von 40 Byte hat.
Das Feld <I>Protocol</I> wird durch das Feld <I>Next Header</I> ersetzt.
Alle Felder die bisher zur Fragmentierung eines IP-Datengramms ben&ouml;tigt wurden
(<I>Identification, Flags, Fragment Offset</I>), sind im IPv6-Basis-Header nicht
mehr vorhanden, da die Fragmentierung in IPv6 gegen&uuml;ber IPv4 anders gehandhabt
wird. Alle IPv6-kompatiblen Hosts und Router m&uuml;ssen Pakete mit einer Gr&ouml;&szlig;e
von 1280 Byte unterst&uuml;tzen. Empf&auml;ngt ein Router ein zu gro&szlig;es Paket, so
f&uuml;hrt er keine Fragmentierung mehr durch, sondern sendet eine Nachricht an den
Absender des Pakets zur&uuml;ck, in der er den sendenden Host anweist, alle weiteren
Pakete zu diesem Ziel aufzuteilen. Es wird also vom Hosts erwartet, da&szlig; er
von vornherein eine passende Paketgr&ouml;&szlig;e w&auml;hlt. Die Steuerung der
Fragmentierung erfolgt bei IPv6 &uuml;ber den <I>Fragment Header</I>.
Das Feld <I>Checksum</I> ist nicht mehr vorhanden.
<P>

<H3>Erweiterungs-Header im IPv6</H3>
Bei IPv6 mu&szlig; nicht mehr der ganze optionale Teil des Headers von allen Routern
verarbeitet werden, womit wiederum Rechenzeit eingespart werden kann. Diese
optionalen Header werden miteinander verkettet. Jeder optionale Header beinhaltet
die Identifikation des folgenden Header. Es besteht auch die M&ouml;glichkeit
selber Optionen zu definieren.
<P>
Derzeit sind sechs Erweiterungs-Header definiert. Alle Erweiterungs-Header sind optional.
Werden mehrere Erweiterungs-Header verwendet, so ist es erforderlich, sie in einer
festen Reihenfolge anzugeben.
<P>
<CENTER>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADDING=4>
<TR>
<TH>Header</TD>
<TH>Beschreibung</TD>
</TR>
<TR>
<TD VALIGN=TOP>IPv6-Basis-Header</TD>
<TD VALIGN=TOP>Zwingend erforderlicher IPv6-Basis-Header</TD>
</TR>
<TR>
<TD VALIGN=TOP>Optionen f&uuml;r Teilstrecken<BR>
(Hop-by-Hop Options Header)</TD>
<TD VALIGN=TOP>Dies ist der einzige optionale Header, der von jedem Router bearbeitet
werden mu&szlig;. Bis jetzt ist nur die "Jumbo Payload Option" definiert, in der die
L&auml;nge eines Paketes angegeben werden kann, das l&auml;nger als 64 KByte ist.
</TD>
</TR>
<TR>
<TD VALIGN=TOP>Optionen f&uuml;r Ziele<BR>
(Destination Options Header)</TD>
<TD VALIGN=TOP>Zus&auml;tzliche Informationen f&uuml;r das Ziel</TD>
</TR>
<TR>
<TD VALIGN=TOP>Routing<BR>
(Routing Header)</TD>
<TD VALIGN=TOP>Definition einer vollst&auml;ndigen oder teilweisen Route.
Er wird f&uuml;r das Source-Routing in IPv6 verwendet.</TD>
</TR>
<TR>
<TD VALIGN=TOP>Fragmentierung<BR>
(Fragment Header)</TD>
<TD VALIGN=TOP>In IPv6 wird, wie oben beschrieben, die Fragmentierung nur
noch End to End gemacht. Die Fragmentierinformationen werden in diesem
optionalen Header abgelegt.
</TD>
</TR>
<TR>
<TD VALIGN=TOP>Authentifikation<BR>
(Authentication Header)</TD>
<TD VALIGN=TOP>Er dient der digitalen Signatur von Paketen, um die Quelle eindeutig
feststellen zu k&ouml;nnen.
</TD>
</TR>
<TR>
<TD VALIGN=TOP>Verschl&uuml;sselte Sicherheitsdaten<BR>
(Encapsulating Security Payload Header)</TD>
<TD VALIGN=TOP>Informationen &uuml;ber den verschl&uuml;sselten Inhalt.</TD>
</TR>
<TR>
<TD VALIGN=TOP>Optionen f&uuml;r Ziele<BR>
(Destination Options Header)</TD>
<TD VALIGN=TOP>Zus&auml;tzliche Informationen f&uuml;r das Ziel (f&uuml;r
Optionen, die nur vom endg&uuml;ltigen Ziel des Paketes verarbeitet werden
m&uuml;ssen).</TD>
</TR>
<TR>
<TD VALIGN=TOP>Header der h&ouml;heren Schichten<BR>
(Upper Layer Header)</TD>
<TD VALIGN=TOP>Header der h&ouml;heren Protokollschichten (TCP, UDP, ...)</TD>
</TR>
</TABLE>
</CENTER>
<P>

<H3>IPv6-Adressen</H3>
Die IPv6-Adressen sind zwar von 32 Bit auf 128 Bit angewachsen, trotzdem sind die
grunds&auml;tzlichen Konzepte gleich geblieben. Die Adresse wird normalerweise
Sedezimal (Hexadezimal, Basis 16) notiert und hat die allgemeine Form
<PRE>
  xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx
</PRE>
Sie ist damit recht l&auml;nglich. Um die Schreibweise zu vereinfachen,
wurden einige Regeln eingef&uuml;hrt:
<UL>
<LI>F&uuml;hrende Nullen<BR>
Die f&uuml;hrenden Nullen k&ouml;nnen mit Nullen oder Doppelpunkten
zusammengefasst werden.
<PRE>
1234:0000:0000:0000:0000:0000:0000:1234
                  --&gt;
         1234:0:0:0:0:0:0:1234
                  --&gt;
               1234::1234
</PRE>
<P>
<LI>IPv4 kompatible Adressen haben die Form:
<PRE>
0:0:0:0:0:0:C206:AFFE
      oder
::C206:AFFE
</PRE>
Um die Lesbarkeit zu erh&ouml;hen kann man auch eine gemischt Form verwenden:
<PRE>
::196.6.175.254
</PRE>
<P>
<LI>IPv4 gemappte IPv6 Adressen haben die Form:
<PRE>
::FFFF:C206:A17E
</PRE>
<LI>Die Loopback Adresse ist neu (anstelle 127.0.0.1):
<PRE>
::1
</PRE>
</UL>
<P>

In IPv4 wurden die Adressen anf&auml;nglich in die bekannten Klassen eingeteilt.
Ein weiteres Problem bei den IPv4 Adressen ist, da&szlig; die Router keine
Hierarchie in den Adressen erkennen k&ouml;nnen. Auch IPv6 ist in der allgemeinen
Form unstrukturiert, es kann aber durch definierte Pr&auml;fixe strukturiert werden.
Die allgemein strukturiert Adresse sieht danach wie folgt aus:
<P>
<center><img src="ipv6strukt.gif"></center>
<P>
Die Strukturierung erlaubt die Einteilung der Adresse in Adresstypen. Jeder Pr&auml;fix
identifiziert somit einen Adresstyp. Die bereits definierten Adresstypen und die
zugeh&ouml;rigen Pr&auml;fixe sind:
<P>
<center>
<table border=1 cellpadding=4>
<tr><th>Adresstyp</th><th>Pr&auml;fix (bin&auml;r)</th></tr>
<tr>
<td valign=TOP>Reserviert f&uuml;r IPv4 und Loopback</td><td align=right valign=TOP>0000 0000</td></tr>
<tr><td valign=TOP> NSAP-Adressen </td><td align=right valign=TOP> 0000 001 </td></tr>
<tr><td valign=TOP> IPX-Adressen </td><td align=right valign=TOP> 0000 010 </td></tr>
<tr><td valign=TOP> Anbieterbasierte Unicast-Adresse </td><td align=right valign=TOP> 010 </td></tr>
<tr><td valign=TOP> Reserviert f&uuml;r geografische Unicast-Adresse </td><td align=right valign=TOP> 100 </td></tr>
<tr><td valign=TOP> Zusammenfassbare globale Adressen </td><td align=right valign=TOP> 001 </td></tr>
<tr><td valign=TOP> Standortlokale Adresse </td><td align=right valign=TOP> 1111 1110 11 </td></tr>
<tr><td valign=TOP> Multicast-Adresse </td><td align=right valign=TOP> 1111 1111 </td></tr>
</table>
</center>
<P>
Wie man in der Tabelle erkennen kann, werden die Adressen grob in die Typen
<I>Unicast</I>, <I>Multicast</I> und <I>Anycast</I> eingeteilt, deren Eigenschaften
nachfolgend kurz erkl&auml;rt werden sollen.
<UL>
<LI><I>Unicast</I><BR>
Als Unicast-Adressen bezeichnet man die Adressen, die f&uuml;r Punkt-zu-Punkt-Verbindungen
verwendet werden. Sie werden in verschiedene Gruppen eingeteilt:
  <UL>
  <LI>Geographisch basierte Unicast-Adresse<BR>
  F&uuml;r diese Adressen wurde erst der Adressbereich und der Pr&auml;fix
  reserviert. Die Idee ist, dass ein hierarchisches Routing aufgrund der
  geographischen Lage - &auml;hnlich wie beim Telefon - m&ouml;glich sein
  soll.
  <LI>Anbieterbasierte Unicast-Adressen<BR>
  Dieser Adresstyp erlaubt ein hierarchisches Routing aufgrund der Adressr&auml;ume
  der Anbieter. Diese Adressen werden von einem Register &uuml;ber ein gro&szlig;es
  Gebiet verwaltet. Diese Register geben die Adressen an die Anbieter weiter,
  welche ihrerseits Adressen weitergeben k&ouml;nnen. Somit ergibt sich
  eine Adress-Struktur, die wie folgt aussieht:
  <P>
  <img src="ipv6unicast.gif">
  <p>
  Die Einf&uuml;hrung von nationalen Registern ergibt eine Aufteilung
  der Anbieter- und Subscriber-ID in National-Register-, Anbieter- und
  Subscriber-ID.
  </UL>
<LI><I>Linklokale und standortlokale Adressen</I><BR>
Diese Adressen werden f&uuml;r die TCP/IP-Dienste innerhalb eines Unternehmens
genutzt. Die Linklokalen Adressen werden nicht in das Internet geroutet und haben
den folgenden Aufbau:
<P>
<img src="ipv6loc1.gif">
<P>
Im Gegensatz dazu stehen die standortlokalen Adressen, die nur innerhalb eines
Subnetzes g&uuml;ltig sind und deshalb von keinem Router behandelt werden.
<P>
<img src="ipv6loc2.gif">
<p>
<LI><I>Multicast-Adressen</I><BR>
In IPv4 wird das Rundsenden eines Paketes an mehrere Stationen durch das IGMP
(Internet Group Management Protokoll) realisiert. In IPv6 ist das Prinzip
&uuml;bernommen, aber ein eigener Adresstyp definiert worden. IGMP entf&auml;llt
somit g&auml;nzlich. Das Paket f&uuml;r Multicast-Meldungen sieht wie folgt aus:
<P>
<img src="ipv6multicast.gif">
<P>
Das Flag gibt an, ob die Gruppen ID tempor&auml;r, oder von der IANA
zugewiesen ist. Der Scope gibt den G&uuml;ltigkeitsbereich der Multicast
Adresse an. Dieser reicht vom nodelokalen bis zum globalen Bereich.
<LI><I>Anycast Adressen</I><BR>
Diese Adressen sind neu definiert worden. es k&ouml;nnen mehrere Rechner zu einer
Gruppe zusammengefasst werden und sie sind dann unter einer einzigen Adresse erreichbar.
Damit ist beispielsweise eine Lastverteilung m&ouml;glich: der Rechner, der am wenigsten
belastet ist, behandelt das Paket. Die Adresse hat die folgende Struktur:
<p>
<img src="ipv6anycast.gif">
<P>
</UL>

<H3>Sicherheit</H3>
Der Bedarf an digitalen Unterschriften oder elektronischen Zahlungsm&ouml;glichkeiten
steigt st&auml;ndig. Deshalb stand bei der Spezifikation von IPv6 die Sicherheit von
Anfang an im Mittelpunkt. F&uuml;r die Sicherheitsfunktionen von IPv6 ist eine
spezielle Arbeitsgruppe "IPSec" zust&auml;ndig.<BR>
In IPv6 wurden Sicherheitsmechanismen f&uuml;r die Authentisierung und Verschl&uuml;sselung
auf IP Ebene spezifiziert. Die Verschl&uuml;sselungsfunktionen definieren Verfahren,
die das Mitlesen durch Unbefugte verhindern. Es gibt zwei unterschiedliche Ans&auml;tze.
Bei der ersten Variante werden alle Nutzdaten (Payload) verschl&uuml;sselt. Der Header
bleibt normal lesbar. Bei der anderen Variante ist es m&ouml;glich, den Header
ebenfalls zu verschl&uuml;sseln. Das codierte Paket wird in ein anderes IPv6-Packet
verpackt und zu einem fixen Ziel bef&ouml;rdert ("IP-Tunnel"). Am Ziel wird das Paket
wieder entschl&uuml;sselt und &uuml;ber das sichere interne Netz &uuml;bertragen.
<p>
Authentisierungsmechanismen liefern den Beweis auf Unverf&auml;lschtheit
der Nachricht und identifiziert den Absender (Digitale Unterschrift).
Hier werden verschiedene kryptographische Verfahren eingesetzt.
Die Verfahren f&uuml;r die Verschl&uuml;sselung und die Authentisierung
k&ouml;nnen auch getrennt angewandt werden.
Verwaltung und Verteilung der Schl&uuml;ssel wird nicht von IPv6 gel&ouml;st.
Das Standardverfahren f&uuml;r den IPv6-Authentisierungsmechanismus
ist MD5 mit 128 Bit langen Schl&uuml;sseln. IPv6 schreibt keinen
Verschl&uuml;sselungsmechanismus vor, jedes System im Internet
mu&szlig; jedoch den DES mit CBD (Cipher Block Chaining) unterst&uuml;tzen.
<P>

<H2><A NAME="8.9">Domain Name System (DNS)</A></H2>
Es hat sich ziemlich fr&uuml;h herausgestellt, da&szlig; menschliche
Benutzer die numerischen IP-Adressen nicht benutzen wollen,
sondern aussagekr&auml;ftige und vor allem merkbare Namen
bevorzugen. Au&szlig;erdem ist es ein gro&szlig;er Nachteil der IP-
Adressen, da&szlig; aus ihnen keinerlei geographische Information
zu entnehmen ist. Man sieht einer Zieladresse nicht an, ob
sie in Australien oder im Nebenzimmer lokalisiert ist,
au&szlig;er man kennt zuf&auml;llig die gew&auml;hlten Zahlen. Es wurde
daher das Domain Name System entwickelt, das den Aufbau von
Rechnernamen regelt. Es ordnet jedem (weltweit eindeutigen)
Namen eine IP-Adresse zu. Dabei gibt es einige Varianten.
Eine Maschine mit einer IP-Adresse kann mehrere Funktionen
haben und daher auch mehrere Namen, die auf diese
Funktionen hinweisen. Genauso kann eine Maschine (z. B. ein
Router) viele IP-Adressen haben aber nur einen Namen.
<P>
Beim "Domain-Name-System"  (oder kurz: DNS) handelt es sich um einen
Dienst, der zu einem Rechnernamen die zugeh&ouml;rige IP-Nummer
liefert und umgekehrt. Das ist in etwa mit der Funktionsweise
einer Telefonauskunft vergleichbar:
Der Kunde ruft bei einer bestimmten Telefonnummer an und fragt
nach der Rufnummer eines Teilnehmers. Nachdem er Name und Wohnort
der gesuchten Person durchgegeben hat, erh&auml;lt er als Antwort die gew&uuml;nschte
Nummer aus einem Verzeichnis. Genauso l&auml;uft eine DNS-Abfrage ab.
<center>
<p>
<img src="auskunft.gif">
<p>
</center>
Gibt ein Benutzer in seinem Webbrowser zum Beispiel die Adresse
<p>
<TT>
http://www.VereinGegenZuLangeDomainnamenEV.de
</TT>
<p>

ein, dann sorgt ein Teil der Netzwerk-Software
auf seinem lokalen Rechner daf&uuml;r, da&szlig; ein Name-Server nach der IP-Adresse
des Rechners <TT>www.vereingegenzulangedomainnamenev.de</TT> gefragt wird.
Dieser Softwareteil wird als <i> Resolver</i> bezeichnet und entspricht in
obigem Beispiel dem Kunden, der die Auskunft anruft.
Welche IP-Adresse dieser Server hat, mu&szlig; dem Klientenrechner nat&uuml;rlich
bekannt sein, genauso wie der Kunde eine einzige Telefonnummer wissen mu&szlig;,
n&auml;mlich die der Auskunft selbst.

Auf der Serverseite arbeitet eine Software, die als <i>"Domain-Name-Server"</i> oder
kurz <i>"Name-Server"</i> bezeichnet wird und anhand einer Datenbank
(<i>"Zone-File"</i>) die passende IP-Nummer zum Rechnernamen liefert, oder
einen anderen Name-Server fragt, wenn die Adresse unbekannt ist.
<center>
<p>
<img src="dns-simple.gif">
<p>
</center>

DNS ist ein typisches Beispiel f&uuml;r einen Verzeichnisdienst. Seine Aufgaben sind:

<ul>
  <li>Strukturierung der Namen. (Dom&auml;nen-Konzept)
  <li>Zuteilung und Verwaltung von Namen.
  <li>Aufl&ouml;sen von Namen (="Nachschlagen") in beide Richtungen (Name zu Adresse und Adresse zu Name)
  <li>Zwischenspeichern von Adressen (Caching)
  <li>Einteilung der Daten in hierarchische Ebenen
  <li>Verteilung der Daten auf verschiedene Knoten
  <li>Bereitstellung von Redundanz (Secondary-DNS, Caching-Only-Server)
</ul>
Damit das DNS funktioniert mu&szlig; es Instanzen geben, die
Namen in IP-Adressen und IP-Adressen in Namen umwandeln
('aufl&ouml;sen') k&ouml;nnen. Diese Instanzen sind durch Programme
realisiert, die an gr&ouml;&szlig;eren Maschinen st&auml;ndig (meist im
Hintergrund) im Betrieb sind und 'Nameserver' hei&szlig;en. Jeder Rechner, der an das
Internet angeschlossen wird, mu&szlig; die Adresse eines oder
mehrerer Nameserver wissen, damit die Anwendungen auf
diesem Rechner mit Namen benutzt werden k&ouml;nnen. Die
Nameserver sind f&uuml;r bestimmte Bereiche, sogenannte
'domains' oder 'Zonen', zust&auml;ndig (Institute, Organisationen, Regionen)
und haben Kontakt zu anderen Nameservern, so da&szlig; jeder Name
aufgel&ouml;st werden kann.
<p>

<h3>Dom&auml;nen-Konzept</h3>
In den Anf&auml;ngen des ARPA-Nets, aus  dem das Internet entstand, wurde die
Namensaufl&ouml;sung &uuml;ber eine einzige Datei erledigt. Jeder Rechner
kopierte sich Nachts per FTP diese Datei von einem  Master-Server auf die
lokale Platte. Dieses Konzept funktioniert nat&uuml;rlich nur, solange die
Anzahl der Namen nicht gro&szlig; ist. Die ben&ouml;tigte Bandbreite ist proportinal
zum Quadrat der beteiligten Rechner.
<p>
B ~ N<sup>2</sup>
<p>
Als Relikt aus dieser Zeit kennt fast jedes Betriebssystem auch heute noch eine
Hosts-Datei, in der f&uuml;r kleine Netze Rechner/Nummern-Zuordnungen
abgelegt werden k&ouml;nen. (Bei Windows im Verzeichnis <TT>\WINDOWS\HOSTS</TT>,
bei Unix unter <TT>/etc/hosts</TT>, bei Novell unter
<TT>SYS:SYSTEM/ETC/HOSTS</TT>, etc.)

Die Syntax aller dieser Hosts-Dateien ist einfach. F&uuml;r jeden Rechner gibt
es eine eigene Zeile mit dem Inhalt:
<pre>
IP-Nummer	Hostname Alias Alias ....
</pre>
Zum Beispiel:
<pre>
192.168.112.1    chef dumpfbacke
192.168.112.2    Snow-White
192.168.112.3    Doc
192.168.112.4    Happy
192.168.112.5    Bashful
192.168.112.6    Sneezy
192.168.112.7    Sleepy
192.168.112.7    Grumpy
192.168.112.8    Dopey
</pre>
Der Begriff <i>Alias</i> l&auml;&szlig;t sich dabei am besten durch <i>"Spitzname"</i>
(oder englisch <i>Nickname</i>) ersetzen; also ein weiterer Name f&uuml;r ein und den
selben Rechner.
<p>
Bei einer kleinen Menge von Rechnern ist die Namensverwaltung mit einer Datei noch
m&ouml;glich; f&uuml;r einen so gro&szlig;en und st&auml;ndig wechselnden Verbund wie
das Internet ist sie aber nicht geeignet. Hier ist eine dezentrale Verwaltung mit
einem eigens darauf abgestimmten Namensraum n&ouml;tig.
<p>
Der Namensraum des DNS ist in sogenannte Dom&auml;nen eingeteilt. Die Dom&auml;nen sind
hierarchisch als Baum angeordnet,

<p>
<center>
<img src="dns-baum.gif">
</center>
<p>
Ausgehend von der Wurzel (=<i>Root</i>) des Baumes ist der Namensraum in sogenannte
"<i>Toplevel-Domains</i>" eingeteilt. Man unterscheidet dabei zwischen zwei verschiedenen
Klassen von Toplevel-Dom&auml;nen: Den generischen und den l&auml;nderspezifischen.
<p>
<center>
<table border=1 cellpadding=5>
<tr><th colspan=2>Toplevel-Dom&auml;nen</th></tr>
<tr><th valign="top">generisch bzw.gesponsert</th>
<td>
<table border=0 cellpadding=3 cellspacing=0 width="70%">
<tr><td width="20%">com</td><td>Kommerzielle Organisationen</td></tr>
<tr><td>edu</td><td>(education) Schulen und Hochschulen</td></tr>
<tr><td>gov</td><td>(government) Regierungsinstitutionen</td></tr>
<tr><td>mil</td><td>milit&auml;rische Einrichtungen</td></tr>
<tr><td>net</td><td>Netzwerk betreffende Organisationen</td></tr>
<tr><td>org</td><td>Nichtkommerzielle Organisationen</td></tr>
<tr><td>int</td><td>Internationale Organisationen</td></tr>
<tr><td><P>arpa</td><td>und das alte ARPA-Net bzw. R&uuml;ckw&auml;rts-Aufl&ouml;sung
von Adressen</td></tr>
</table>
<P>
Ende 2000 sind neue TLDs von der ICANN genehmigt worden:
<P>
<table border=0 cellpadding=3 cellspacing=0 width="70%">
<tr><td width="20%">aero</td><td>Luftfahrtindustrie</td></tr>
<tr><td>coop</td><td>Firmen-Kooperationen</td></tr>
<tr><td>museum</td><td>Museen</td></tr>
<tr><td>pro</td><td>&Auml;rzte, Rechtsanw&auml;lte und andere Freiberufler</td></tr>
<tr><td>biz</td><td>Business (frei f&uuml;r alle)</td></tr>
<tr><td>info</td><td>Informationsanbieter (frei f&uuml;r alle)</td></tr>
<tr><td>asia</td><td>Anbieter aus Asien</td></tr>
<tr><td>jobs</td><td>Job-Angebote</td></tr>
<tr><td>travel</td><td>Reise-Angebote</td></tr>
<tr><td>cat</td><td>F&ouml;rderung der katalanischen Sprache</td></tr>
<tr><td>mobi</td><td>WWW f&uuml; Smartphones/Tablets</td></tr>
<tr><td>tel</td><td>Darstellung von Kontaktdaten (Telnic Ltd.)</td></tr>
<tr><td>name</td><td>Private Homepages (frei f&uuml;r alle, aber nur
dreistufige Domains der Form &lt;Vorname&gt;.&lt;Name&gt;.name)</td></tr>
</table>
</tr>
<tr>
<th valign="top">l&auml;nderspezifisch</th>
<td>Jeweils ein L&auml;nderk&uuml;rzel f&uuml;r jedes Land, z.B.:<br>
<table border=0 cellpadding=5 cellspacing=0 width="70%">
<tr><td width="20%">by</td><td>Weissrussland</td></tr>
<tr><td>de</td><td>Deutschland</td></tr>
<tr><td>at</td><td>&Ouml;stereich</td></tr>
<tr><td>fr</td><td>Frankreich</td></tr>
<tr><td>to</td><td>Tonga</td></tr>
<tr><td>tv</td><td>Tuvalu</td></tr>
</table>
</td>
</tr>
<tr>
<th valign="top">Pseudo- und reservierte Dom&auml;nen</th>
<td>
<table border=0 cellpadding=3 cellspacing=0 width="70%">
<tr><td width="20%"><b>Pseudo</b></td><td></td></tr>
<tr><td width="20%">bitnet</td><td>BITNET (historisch)</td></tr>
<tr><td>csnet</td><td>f&uuml;r Mail-Weiterleitung ins CSNET (historisch)</td></tr>
<tr><td>local</td><td>verwendbar f&uuml;r private (Heim-)Dom&auml;nen</td></tr>
<tr><td>root</td><td>vrsn-end-of-zone-marker-dummy-record.root</td></tr>
<tr><td>uucp</td><td>"Unix to Unix Copy" (historisch)</td></tr>
<tr><td>onion</td><td>Tor-Network intern</td></tr>
<tr><td>exit</td><td>Tor-Network intern</td></tr>
<tr><td><br><b>Reserviert</b></td><td></td></tr>
<tr><td>example</td><td>f&uuml;r lokalen Test/Dokumentation</td></tr>
<tr><td>invalid</td><td>f&uuml;r lokalen Test/Dokumentation</td></tr>
<tr><td>localhost</td><td>f&uuml;r lokalen Test/Dokumentation</td></tr>
<tr><td>test</td><td>f&uuml;r lokalen Test/Dokumentation</td></tr>
</table>
</td>
</tr>
</table>
</center>

<p>
Unterhalb der Toplevel-Dom&auml;nen folgen Subdom&auml;nen, die wiederum Dom&auml;nen
enthalten k&ouml;nen und schliesslich, als Blatt des Baumes, ein einzelner Rechner.
Der Name <TT>www.netzmafia.de</TT> ist also so zu verstehen. In der Toplevel-Dom&auml;ne
<i>".de"</i> ist die Subdomain "<i>Netzmafia</i>" bekannt. Innerhalb der Subdomain
"<i>netzmafia</i>" gibt es einen Rechner namens "<i>www</i>". Analog zu unserem
Beispiel mit der Telefonauskunft, ist mit "de" das Land, mit "netzmafia" der Ort und
die Stra&szlig;e und mit "www" der Name eines Teilnehmers bestimmt. Die komplette Adresse
eines Rechners in der beschriebenen Notation, z.B. bezeichnet man (www.netzmafia.de</i>)
als FQDN (<i>Full-Qualified-Domain-Name</i>).
<p>
F&uuml;r die Aufnahme einer Verbindung zwischen zwei Rechnern
mu&szlig; in jedem Fall der Rechnername in eine zugeh&ouml;rige IP-
Adresse umgewandelt werden. Aus Sicherheitsaspekten ist es
manchmal w&uuml;nschenswert, auch den umgekehrten Weg zu gehen,
n&auml;mlich zu einer sich meldenden Adresse den Namen und damit
die organisatorische Zugeh&ouml;rigkeit offenzulegen.
<P>

<H4>Komponenten des DNS</H4>
Insgesamt sind es drei Hauptkomponenten, aus denen sich das DNS zusammensetzt:
<OL>
<li> Der <B>Domain Name Space</B>, ein baumartig, hierarchisch strukturierter Namensraum
und die Resource Records. Das sind Datens&auml;tze, die den Knoten zugeordnet sind.
<li> <B>Name Server</B> sind Programme bzw. Rechner, die die Informationen &uuml;ber die
Struktur des Domain Name Space verwalten und aktualisieren. EinNameserver hat
normalerweise nur eine Teilsicht des Domain Name Space zu verwalten. Oft wird
auch der Rechner, auf dem das Nameserverprogramm l&auml;uft, als 'Nameserver' oder
'DNS-Server' bezeichnet.
<li> <B>Resolver</B> sind die Programme, die f&uuml;r den Client Anfragen an den
Nameserver stellen. Resolver sind einemNameserver zugeordnet; bei Anfragen, die er
nicht  beantworten kann (anderer Teilbereich des Domain Name Space). kann er aufgrund
von Referenzen andere Nameserver kontakten, um die Information zu erhalten.
</OL>
<P>
<center><img src="dns.gif"></center>
<P>

Der <B>Nameserver</B> des DNS verwaltet also einzelne Zonen, die einen Knoten im DNS-Baum
und alle darunterliegenden Zweige beinhalten. Auf jeder Ebene des DNS-Baums kann es
Namesever geben, wobei jeder Nameserver seinen n&auml;chsth&ouml;heren und n&auml;chstniedrigeren Nachbarn
kennt. Aus Sicherheitsgr&uuml;nden gibt es f&uuml;r jede Zone in der Regel mindestens zwei Nameserver
(<I>primary</I> und <I>secondary</I>), wobei beide die gleiche Information halten.
Nameservereintr&auml;ge k&ouml;nnen nicht nur die Zuordnung Rechnername - IP-Adresse enthalten,
sondern (neben anderem) auch weitere Namenseintr&auml;ge f&uuml;r einen einzigen Rechner und
Angaben f&uuml;r Postverwaltungsrechner einer Domain (MX, mail exchange).
<P>
Basis des Nameservice bilden die "Root-Nameserver", die f&uuml;r die Top-Level-Domains
zust&auml;ndig sind. Federf&uuml;hrende Organistation ist hier die ICANN
(<i>=Internet Corporation for Assigned Names and Numbers </i>,
Adresse: <a href="http://www.icann.org">http://www.icann.org</a>). Gr&uuml;ndung 1998.
ICANN beauftragt die Verwalter der Zone "." (Wurzel des DNS-Baumes) mit 13 Servern.
Bis auf die Server I (Stockholm), K (London) und  M (Tokio) stehen alle
Server in den USA.
<P>
<CENTER><IMG SRC="nameserver.gif"></CENTER>
<P>
<TABLE BORDER=1 CELLPADDING=5 cellspacing=0 width="70%" align=center>
<TR><TH>Name</TH><TH>Typ</TH><TH>Betreiber</TH><TH>URL</TH></TR>
<TR><TD>a</TD><TD>com</TD><TD>InterNic</TD><TD>http://www.internic.org</TD></TR>
<TR><TD>b</TD><TD>edu</TD><TD>ISI</TD>     <TD>http://www.isi.edu</TD></TR>
<TR><TD>c</TD><TD>com</TD><TD>PSINet</TD>  <TD>http://www.psi.net</TD></TR>
<TR><TD>d</TD><TD>edu</TD><TD>UMD</TD>     <TD>http://www.umd.edu</TD></TR>
<TR><TD>e</TD><TD>usg</TD><TD>NASA</TD>    <TD>http://www.nasa.gov</TD></TR>
<TR><TD>f</TD><TD>com</TD><TD>ISC</TD>     <TD>http://www.isc.org</TD></TR>
<TR><TD>g</TD><TD>usg</TD><TD>DISA</TD>    <TD>http://nic.mil</TD></TR>
<TR><TD>h</TD><TD>usg</TD><TD>ARL</TD>     <TD>http://www.arl.mil</TD></TR>
<TR><TD>i</TD><TD>int</TD><TD>NordUnet</TD><TD>http://www.nordu.net</TD></TR>
<TR><TD>j</TD><TD>( &nbsp; )</TD> <TD>(TBD)</TD>   <TD>http://www.iana.org</TD></TR>
<TR><TD>k</TD><TD>int</TD><TD>RIPE</TD>    <TD>http://www.ripe.net</TD></TR>
<TR><TD>l</TD><TD>( &nbsp; )</TD> <TD>(TBD)</TD>   <TD>http://www.iana.org</TD></TR>
<TR><TD>m</TD><TD>int</TD><TD>WIDE</TD>    <TD>http://www.wide.ad.jp</TD></TR>
</TABLE>
<p>
Der Server A ist der prim&auml;re Server, alle anderen sind seine Secondaries.
Eine Liste dieser Root-Server muss jeder DNS-Server haben (Ausnahme: Cache-Only-Server).
Erzeugung der Liste mit dem Kommando:
<pre>
dig @rs.internic.net . ns > root.servers
</pre>
<p>
Die Namen, die im Internet verwendet werden m&uuml;ssen dabei einige Spezifikationen
erf&uuml;llen:
<ul>
<li>Die L&auml;nge eines Namensteiles (Dom&auml;nen- oder Rechnername) darf maximal
63 Zeichen betragen.
<li> Die Gesamtl&auml;nge des Full-Qualified-Domain-Names darf 255 Zeichen nicht
&uuml;berschreiten.
<li>Nur Buchstaben, Ziffern und "-" sind in den Namen zugelassen. Dabei muss jeder
Name mit einem Buchstaben oder einer Ziffer beginnen und enden. ("3bla-fasel" ist
zul&auml;ssig, "3bla-" aber nicht.)
<li>Zwischen Gro&szlig;- und Kleinschreibung wird nicht unterschieden.
<li>Die Domains "example.com" und "example.net" sind f&uuml;r Dokumentationen
vorgesehen und werden nicht vergeben. 
</ul>
Bei der Registrierung einer Domain unterhalb von ".de" gelten zus&auml;tzlich noch
folgende Regeln:
<ul>
<li>Der Domainname mu&szlig; mindestens 3 Zeichen haben. Insgesamt gibt es in ".de"
noch 4 Domains mit nur 2 Buchstaben, die aus Besitzstands-Gr&uuml;nden beibehalten werden.
<li>Wegen eines weit verbreiteten Fehlers in der Named-Server-Software sind Domains
mit den gleichen Namen wie Toplevel-Eintr&auml;ge verboten. (Also z.B.: "at.de") Das ist
in RFC 1535 n&auml;her beschrieben.
<li>KFZ-Kennzeichen k&ouml;nnen nicht registriert werden.
</ul>
<p>
<center>
<img src="domains_simple.gif">
</center>
<p>
Ein wichtiger Bestandteil des DNS-Konzeptes ist die Aufteilung der ben&ouml;tigten Datenbank
auf viele verschiedene Rechner. Da das Gesamtsystem voll funktionsf&auml;hig bleiben
mu&szlig;, auch wenn ein Server ausgefallen ist, wird die Datenhaltung mit Hilfe von
Zust&auml;ndigkeiten gel&ouml;st: Zu jeder Domain gibt es mindestens einen zugeh&ouml;rigen
Server, der verantwortlich die darin enthaltenen Subdomains oder Rechner verwaltet, oder
die Verwaltung an einen weiteren Server weiterdelegiert. Am Stamm des DNS-Baumes sitzen
dazu die "<i>Root-Server</i>", die alle Eintr&auml;ge ihrer jeweiligen Domain kennen.
Das hei&szlig;t, da&szlig; der Root-Nameserver der Dom&auml;ne ".de" einen Eintrag f&uuml;r
den Named-Server der Domain "netzmafia.de" besitzt. Dieser Server hat wieder eine Liste
der in "netzmafia.de" enthaltenen Rechner und Subdomains.
<p>
Die Frage eines Clients nach der IP-Nummern eines Rechners wird wie folgt abgewickelt:

<p>
<center>
<img src="dns-ablauf.gif">
</center>
<p>

<ol>
<li>Der Client-Rechner "grumpy.zwerge.org" stellt die DNS-Anfrage nach "www.netzmafia.de" an seinen zust&auml;ndigen DNS-Server. Dessen IP-Nummer muss dem Client bekannt sein.
<li>Kennt der Nameserver der Domain "zwerge.org" die Antwort nicht, so erkundigt er sich beim Root-Nameserver nach der Adresse des Nameservers von ".de"
<li>Der Root-Nameserver antwortet dem zust&auml;ndigen DNS-Server der Domain "zwerge.org" mit der Adresse des Nameservers von ".de"
<li>Der Nameserver der Domain "zwerge.org" erkundigt sich beim Nameserver von ".de" nach der Adresse des Nameservers von "netzmafia.de".
<li>Der Nameserver von ".de" antwortet dem zust&auml;ndigen DNS-Server der Domain "zwerge.org" mit der Adresse des Nameservers von "netzmafia.de"
<li>Der Nameserver der Domain "zwerge.org" erkundigt sich beim Nameserver von "netzmafia.de" nach der Adresse des Rechners "www.netzmafia.de".
<li>Der Nameserver von "netzmafia.de" antwortet dem zust&auml;ndigen DNS-Server der Domain "zwerge.org" mit der Adresse des Rechners von "www.netzmafia.de".
<li>Der DNS-Server von "zwerge.org" liefert die IP-Nummer an den anfragenden Client. Damit ist die DNS-Abfrage abgehandelt.
</ol>
<P>

<H3>DNS-Typen</H3>

Man unterscheidet folgende DNS-Typen
<ul>
<li>Cache-Only
  <ul>
    <li>Besitzt keine eigenen Tabellen mit Rechnernamen (Zone-Files).
    <li>Alle Anfragen werden an einen &uuml;bergeordneten Server weitergegeben.
    <li>Adressen werden zwischengespeichert.
    <li>Zweck: Z.B. Entlastung einer Providerleitung
    <li>Sehr einfach einzurichten.
  </ul>
<li>Secondary-DNS
  <ul>
    <li>Besitzt eigene Tabellen, die er vom Primary-DNS kopiert.
    <li>Die Tabellen k&ouml;nnen aber nicht ver&auml;ndert werden.
    <li>Zweck: Lastteilung, Backup
    <li>Einfach einzurichten.
  </ul>
<li>Primary-DNS
  <ul>
    <li>Besitzt eigene Tabellen f&uuml;r eine oder mehrere Zonen.
    <li>Tabellen k&ouml;nnen lokal ver&auml;ndert werden.
    <li>Server ist "<i>authoritative</i>" f&uuml;r seine Zone.
    <li>Relativ hoher Aufwand f&uuml;r Einrichtung und Pflege.
  </ul>
</ul>
<p>


<H3>DNS Resource Records</H3>
Im Standardfall generiert ein DNS-Server seine interne Datenbank
aus einer Textdatei, der sogenannten "Zonen-Datei". Damit er
funktioniert, m&uuml;ssen bestimmte Eintr&auml;ge korrekt eingetragen
worden sein. An dieser Stelle sollen nur ein paar grundlegende
Eigenschaften der wichtigsten Typen von Resource Records betrachtet
werden. Es gibt verschiedene Record-Typen:
<ul>
<li>SOA-Records (Source of Authority) enthalten die technischen Angaben f&uuml;r
die gesamte Zone sowie einige Steuerdaten f&uuml;r die Zusammenarbeit der
Nameserver untereinander. SOA-Records sind weiter unten genauer erkl&auml;rt.
<li>NS-Records (Name Server) verweisen auf die Nameserver, die f&uuml;r eine Zone
authoritativ sind. Auf den eigenen Namen zeigende NS-Records dienen der
Plausibilit&auml;tspr&uuml;fung; NS-Records f&uuml;r eine Subdomain weisen darauf
hin, dass die Informationen f&uuml;r die Subdomain auf einem anderen
Nameserver zu finden sind (Delegation).
<li>A-Records (Address) verkn&uuml;pfen einen Domainnamen mit einer IP-Adresse.
Um IPv4- und IPv6-Adressen zu unterscheiden, wird seit einiger Zeit f&uuml;r
IPv4 der A-Record und f&uuml;r IPv6 der AAAA-Record verwendet.
<li>PTR-Records (Pointer) verkn&uuml;pfen eine IP-Adresse "r&uuml;ckw&auml;rts"
mit einem Domainnamen.
<li>CNAME-Records Canonical Name) definieren einen Domainnamen als Alias f&uuml;r
einen anderen. Es gibt also f&uuml;r jedes System einen A-Record und ggf. noch beliebig
viele CNAME-Records.
<li>MX-Records (Mail Exchanger) definieren, bei welchen Rechnern Mail f&uuml;r eine
Domain eingeliefert werden soll. Auf diese Weise sind geneische Mailadressen wie
z.B. "plate@fhm.edu" m&ouml;glich.
<li>TXT-Records (Text) enthalten beliebige alphanumerische Informationen zu
einem Domainnamen.
</ul>

<H4>Aufbau der Zonendatei</H4>
Beispiel des Primary DNS "<i>aella.serverzwerge.de</i>":
<pre>
; Zonendatei fuer die Domaene serverzwerge.de
;
$TTL 1D
@       in      SOA     aella.serverzwerge.de.  dnsadmin.aella.serverzwerge.de. (
                2002051505        ; Seriennummer
                10800   ; Refresh : 3 Stunden
                3600    ; Retry   : 1 Stunde
                604800  ; Expire  : 1 Woche
                86400)  ; Min. TTL: 1 Tag
                NS              aella.serverzwerge.de.
                MX              10 aella.serverzwerge.de.
                MX              50 mail.irgendeinprovider.de.

aella           A       10.23.200.100
snowwhite       A       10.23.200.17
doc             A       10.23.200.18
happy           A       10.23.200.19
bashful         A       10.23.200.20
sneezy          A       10.23.200.21
sleepy          A       10.23.200.22
grumpy          A       10.23.200.23
dopey           A       10.23.200.24
                HINFO   "Hexium 7.5" "Linux"

beispiel        CNAME   aella
</pre>

<h4>Der SOA-Record</h4>
Jede Zone muss einen SOA-Record (Start of Authority) enthalten. Dort
sind wichtige Informationen &uuml;ber die Zone abgelegt. Hier ein Beispiel:
</p>
<pre>
$TTL 1D
@       in      SOA     aella.serverzwerge.de.  dnsadmin.aella.serverzwerge.de. (
                2002051505        ; Seriennummer
                10800   ; Refresh : 3 Stunden
                3600    ; Retry   : 1 Stunde
                604800  ; Expire  : 1 Woche
                86400)  ; Min. TTL: 1 Tag
</pre>
Das Semikolon leitet Kommentare ein, die nat&uuml;rlich nicht vorhanden
sein m&uuml;ssen.
<ul>
<li>Das erste Feld im SOA-Record benennt den primary master server.
Dies ist der Server, der die endg&uuml;ltige Autorit&auml;t &uuml;ber den Inhalt der
Zone ist. Dort ist das Zonefile selbst abgelegt.
<li>Das zweite Feld des SOA-Records nennt die Mailbox der f&uuml;r die Zone
verantwortlichen Person. Das @-Zeichen der E-Mail-Adresse  wird hier durch einen Punkt
ersetzt. Links vom @ stehende Punkte m&uuml;ssen als \. notiert werden, um eine
eindeutige Zuordnung f&uuml;r den Punkt zu erreichen, der f&uuml;r den @ steht.
<li>Die Seriennummer spielt eine wichtige Rolle im Zusammenspiel
zwischen Master-DNS und Slave-DNS: Slaves f&uuml;hren nur dann einen Zonentransfer
durch, wenn die vom Master &uuml;bermittelte Seriennummer gr&ouml;&szlig;er ist als
die der lokal gehaltenen Zone. Sie wird meist nach dem Schema yyyymmddnn gebildet:
yyyy = Jahr (4-stellig), mm = Monat (2-stellig), dd = Tag (2-stellig) und nn die
Viertelstunde (2-stellig) des aktuellen Tags.
<li>Der Refresh-Wert legt fest, wie h&auml;ufig ein Slave beim Master
nachfragt, ob sich die Zone ver&auml;ndert hat.
<li>Der Retry-Wert legt fest, wie h&auml;ufig ein Slave einen fehlgeschlagenen
Zonentransfer wiederholt, bis er aufgibt.
<li>Der Expire-Wert legt fest, wie lange ein Slave seine Kopie einer
Zone noch als g&uuml;ltig ansieht, wenn er den Master nicht erreichen kann.
<li>Der Minimum-TTL-Wert legt fest, wie lange eine negative Antwort vom
Client zwischengespeichert werden darf. Er ist einer der beiden
wichtigsten Timer in einer Zonendatei (TTL = Time To Live).
<li>Der Eintrag in der $TTL-Zeile oberhalb des SOA-Records  legt fest,
welche Lebensdauer die Resource Records des Zonefiles in den Caches nicht
authoritativer Nameserver haben sollen.
</ul>
Um die Last auf den f&uuml;r eine Zone authoritativen Nameservern zu
verringern, speichern die von den Internetbenutzern verwendeten
Forwarder die Ausk&uuml;nfte, die sie von den authoritativen Nameservern
erhalten haben, f&uuml;r eine bestimmte Zeit zwischen. Der f&uuml;r die Zone
zust&auml;ndige Administrator kann das Caching der Forwarder in manchen
Grenzen beeinflussen.
<p>
Wird eine Nameserver-Anfrage positiv beantwortet, &uuml;bermittelt der
authoritative Nameserver zusammen mit dem angefragten Resource Record
die gew&uuml;nschte Lebenszeit des Eintrags in Form der TTL. Ist im
Zonefile f&uuml;r den Resource Record keine TTL angegeben, so &uuml;bermittelt
der authoritative Nameserver den mit $TTL im Zonefile gesetzten
Defaultwert.
Der Forwarder &uuml;bermittelt die Antwort weiter an die Quelle der Anfrage
und speichert die Antwort f&uuml;r die &uuml;bermittelte Zeitdauer zwischen, so
dass weitere Anfragen nach dem gleichen Resource Record innerhalb
dieser Zeitdauer ohne erneuten Zugriff auf den authoritativen Server
beantwortet werden k&ouml;nnen.
<p>
Bevor man zeitkritische &Auml;nderungen an einer Zone vornimmt (z.B. Umzug
eines Web- oder Mailservers auf eine andere IP-Adresse), ist zu
empfehlen, zuerst einen oder beide TTL-Werte herunterzusetzen. Dies
sollte mindestens einen TTL-Zeitraum vor der eigentlichen &Auml;nderung
geschehen, damit die k&uuml;rzere TTL sich herumgesprochen hat. Nachdem die
&Auml;nderung erfolgreich durchgef&uuml;hrt wurde, kann die TTL wieder
heraufgesetzt werden.
<p>
<h4>Der MX-Record</h4>
Nimmt eine Domain am E-Mailverkehr teil, so wird einer oder mehrere MX-Records
in die Zone eingetragen. MX-Records haben zus&auml;tzlich zu ihrem Ziel eine
Priorit&auml;tsangabe. soll eine E-Mail an die Domain zugestellt werden,
versucht der absendende Mailserver zuerst den MX-Record niedrigster Priorit&auml;t.
Kann er die E-Mail dort nicht ausliefern, versucht er der Reihe nach die
MX-Records h&ouml;herer Priorit&auml;t.
<p>
Gibt es f&uuml;r einen Domainnamen keinen MX-Record, sondern nur einen
A-Record, wird die Mail an diesen zugestellt. Dieses Verhalten ist
historisch bedingt und nicht mehr sinnvoll. Trotzdem wird es
immer noch so gehandhabt. Soll eine Domain nicht am E-Mailverkehr
teilnehmen, so ist es sinnvoll, einen MX-Record auf ein System zu
setzen, das f&uuml;r den Domainnamen eingehende E-Mail mit einem
permanenten Fehler ablehnt.
<p>

<h2><A NAME="8.10">Zero Configuration Networking</A></h2>
Nicht nur Computer, sondern immer mehr andere Komponenten müssen an das 
lokale Netz angeschlossen werden. Gleichzeitig gibt es gerade bei der 
Heimvernetzung mehr und mehr User ohne jegiche Kenntnisse über IP-Adressen,
Netzmaske, Gatway-Adresse usw. Gibt es im LAN einen DHCP-Server, kann der 
die Aufgabe übernehmen und die Clients holen sich von dort ihre
Daten. Als DHCP-Server arbeitet heute schon jeder DSL-Router und auch
manche WLAN-Access-Points können DHCP. 
<p>
Für LANs ohne DHCP-Server gibt es auch eine recht einfache Lösung zum
automatischen Konfigurieren der Netzwerkadressen. Bei IPv4 ist der Block
169.254.0.0/16 für die so genannten <b>Link Local Addresses</b> (IPv4LL)
reserviert, bei IPv6 ist es der Adressbereich fe80::/10 und das
Verfahren nennt sich <b>Stateless Automatic Autoconfiguration</b> (SLAAC) 
(siehe auch RFCs 3927 und 4862) bzw. <b>Automatic Private IP Adressing</b> 
(APIPA). Um an eine IP-Adresse zu kommen, wählt sich das Gerät eine 
zufällige Adresse aus diesem Bereich unter Zuhilfenahme seiner MAC-Adresse 
zusammen mit einem Zufallsgenerator. Dann stellt es durch ARP-Tests sicher, dass 
diese nicht bereits vergeben ist. Auf diese Weise können sich mehrere 
Geräte zu einem Ad-Hoc-Netz vereinigen.  
Die Netzmaske bei IPv4 lautet demnach 255.255.0.0, wobei die ersten und 
letzten 256 Adressen nicht verwendet werden dürfen.
<p>
Jedes Gerät macht seine so erworbene Adresse allen anderen per
ARP-Announcement im Abstand von zwei Sekunden bekannt. Hierbei verwendet
er als Absender- und Empfänger-IP die eben erworbene Adresse. Das Gerät muss 
aber weiterhin auf Adresskonflikte achten, die durch andere Rechner verursacht 
werden. Dies erkennt er, wenn ARP-Pakete mit seiner Adresse als Absenderadresse
von anderen Teilnehmern eintreffen. Hat das Gerät offene TCP-Verbindungen
und wurden noch keine kollidierenden ARP-Pakete empfangen (nur ein ARP-Probe),
sendet es ein klarstellendes ARP-Announcement. In allen anderen Fällen wird 
es sich eine neue Adresse berechnen.
<p>
Damit sind zwar alle Rechner eine IP-Adresse, aber noch keinen aussagekräftigen 
Namen. Für einige Geräte einen DNS-Server aufzusetzen wäre overkill. Abhilfe
schafft hier der Multicast DNS (MDNS, <A href="http://www.multicastdns.org">
www.multicastdns.org</a>). Er arbeitet ähnlich wie der "nbormale" DNS, nur
eben über Multicast. Jedes Gerät hat DNS-Records gespeichert und tritt der 
Multicast-Gruppe bei. Zur Namensauflösung schickt ein Gerät seine Anfrage
an die IPv4-Multicastadresse 224.0.0.251 (bei IPv6: ff02::fb). Ein Rechner mit
dem passenden Eintrag liefert dann die Antwort. Bei MDNS haben alle Systeme
die Top-Level-Domain ".local".
<p>
Es gibt sogar noch eine Erweiterung, DNS Service Discovery (DNS-SD, <A 
href="http://www.dns-sd.org">www.dns-sd.org</a>). Mittels DNS-SD werden 
Informationen über angebotene Dienste unter Verwendung der bestehenden 
DNS-Typen wie SRV, TXT oder PTR publiziert. Alle diese Möglichkeiten sind
unter <b>Zeroconf Netwirking</b> spezifiziert (<a href="http://www.zeroconf.org">
www.zeroconf.org</a>). Bei Apple ist die Implementierung unter dem Namen
"Bonjour" erfolgt und auch für Windows-Rechner erhältlich, die Open-Source-Variante 
heißt "Avahi" (<a href="http://www.avahi.org">www.avahi.org</a>).
<p>


<H2><A NAME="8.11">Netzwerkkonfiguration am Beispiel Linux</A></H2>
Eigentlich ist es egal, welches Betriebssystem als Beispiel genommen wird -
die Netzkonfiguration ist in etwa immer gleich. Auch viele der unten
erw&auml;hnten Dateien finden sich z. B. bei Windows. Linux dient
deshalb als Beispiel, weil man hier nicht nur irgendwelche Fenster anklickt,
sondern sehen kann, wie mit ein paar Kommandos das Netzwerkinterface eingebunden
wird und welche Effekte auf welche Art und Weise erzielt werden.
Die wichtigsten Dateien, Bezeichnungen und Anwendungen:
<p><ul>
<li><tt>/etc/HOSTNAME</tt> oder <tt>/etc/hostname</tt>
<li><tt>/etc/hosts</tt>
<li><tt>/etc/networks</tt>
<li><tt>/etc/host.conf</tt>
<li><tt>/etc/resolv.conf</tt>
<li><tt>/etc/nsswitch.conf</tt>
<li><b>ifconfig</b>
<li><b>route</b>
<li><b>ip</b>
<li><b>netstat</b>
<li><b>ping</b>
<li><b>traceroute</b>
</ul>

Die Netzwerkkonfiguration l&auml;uft im Normalbetrieb immer automatisch beim
Systemstart ab. Init-Scripts &uuml;bernehmen die Konfiguration der
Schnittstellen, das Anlegen der Routen und vieles mehr. Trotzdem ist das
Wissen um die manuelle Konfiguration wichtig, erstens f&uuml;r Probleml&ouml;sungen
und zweitens, weil damit auf die Schnelle auch eine Umkonfiguration von
Netzwerkkarten oder ein experimenteller Aufbau m&ouml;glich ist.
<P>

Auf den (Hardware-)Treiber des Netzwerk-Interface wird aus diesem Grund nicht
eingegangen. Um festzustellen, ob &uuml;berhaupt ein Treiber geladen wurde,
gen&uuml;gt das Kommando
<pre>
dmesg | more
</pre>
das alle Boot-Meldungen auflistet. Darin findet man auch die Meldungen zur
Netzwerkkarte, z.B.:
<pre>
...

8139cp 10/100 PCI Ethernet driver v0.0.6 (Nov 19, 2001)
8139cp: pci dev 00:0f.0 (id 10ec:8139 rev 10) is not an 8139C+ compatible chip
8139cp: Try the "8139too" driver instead.
8139too Fast Ethernet driver 0.9.24
PCI: Found IRQ 9 for device 00:0f.0
eth0: RealTek RTL8139 Fast Ethernet at 0xe081af00, 00:00:e8:76:2f:ea, IRQ 9
eth0:  Identified 8139 chip type 'RTL-8139A'

...
</pre>
Aus dieser Meldung ist auch die MAC-Adresse des Netzwerk-Interface ablesbar
(im Beispiel: 00:00:e8:76:2f:ea).
<p>
Im Folgenden werden die wichtigsten Konfigurationsdateien f&uuml;r das Netz
besprochen, wobei viele der Dateien - eventuell leicht modifiziert oder
mit &auml;hnlichem Nanen - auch bei Windows zu finden sind. Bei Linux
findet man diese Daten traditionsgem&auml;&szlig; im Verzeichnis <i>/etc</i>.
<P>

<h3>Setzen des Hostnamens</h3>
Die Netzwerksoftware verl&auml;&szlig;en sich darauf, da&szlig; der Name der
Maschine einen sinnvollen Wert hat. Er wird im Normalfall w&auml;hrend
des Boot-Vorgangs mit dem Befehl <i>hostname</i> gesetzt. Um den
Hostnamen auf name zu setzen, geben Sie folgendes ein:
<pre>
hostname <i>name</i>
</pre>
Es ist &uuml;blich, nur den Host-Namen ohne jede Domain-Angabe zu verwenden.
<p>

<H3>/etc/hosts</H3>
In dieser Datei werden die Systeme des Netzwerks mit ihrem Systemnamen und
die dazu geh&ouml;renden Internet-Adressen aufgelistet.
Auch, wenn man im normalen Betrieb DNS einsetzt, sollte man einen Teil der
Rechnernamen in <i>/etc/hosts</i> eintragen. Oft m&ouml;chte man n&auml;mlich auch w&auml;hrend
des Bootens, wenn noch keine Netzwerkschnittstellen aktiv sind, symbolische
Namen verwenden.
<p>
Um sicherzustellen, da&szlig; alle Programme ausschlie&szlig;lich <i>/etc/hosts</i> verwenden,
um die Adresse eines Systems zu suchen, m&uuml;ssen Sie ggf. die Datei <i>/etc/nsswitch.conf</i>
editieren. Interessant ist die Zeile, die mit "hosts:" beginnt. Dort sollte "files dns" stehen,
was bedeutet, da&szlig; erst in der lokalen Datei <i>/etc/hosts</i> nachgesehen und dann erst
ein Nameserver kontaktiert wird. Typischerweise sieht die Datei im Ausschnitt so aus:
<pre>
# /etc/nsswitch.conf
#
...
hosts:          files dns
networks:       files
...

</pre>
Auf diese Datei wird weiter unten noch genauer eingegangen.
<P>
Die Datei <i>hosts</i> enth&auml;lt einen Eintrag pro Zeile, bestehend aus der IP-Adresse,
dem Hostnamen und einer optionalen Liste von Aliasen f&uuml;r den Hostnamen. Die Felder
sind durch Leerzeichen oder Tabulatoren voneinander getrennt, und das Adre&szlig;feld mu&szlig;
in Spalte eins beginnen. Ein Doppelkreuz (#) leitet immer einen Kommentar ein.
<p>
Namen k&ouml;nnen entweder mit voller Domainangabe (Full Qualified Domain Name, FQDN)
oder relativ zur lokalen Domain sein. So ist das System sowohl unter seinem offiziellen
als auch unter dem k&uuml;rzeren lokalen Namen bekannt. Man kann in der Datei auch die
Namen und IP-Adressen beliebiger anderer Rechner eintragen. Immer notwendig ist der
Eintrag f&uuml;r den Rechner selbst, "<tt>127.0.0.1 localhost</tt>",
denn sonst funktionieren gewisse Dienste (z.B. lpd) nicht.
<P>
F&uuml;r alle folgenden Beispiele werden f&uuml;r die Rechnernamen Schneewittchen und die
sieben Zwerge (in der englischen Fassung von Walt Disney) verwendet. Damit keine
Kollision mit real existierenden Internet-Domains auftreten, kann man als
Domainnamen beispielsweise "<TT>zwerge.local</TT>" nehmen. Als Netz verwenden
wir das private B-Netz <tt>172.20.y.x</tt> - und davon sogar nur ein C-Subnetz,
<tt>172.20.20.x</tt>.
<p>
Das folgende Beispiel zeigt, wie die Datei <i>/etc/hosts</i> im Zwergenwald
aussehen k&ouml;nnte.
<pre>
#
# Hostdatei fuer Snowwhite and Friends
#
# IP            FQDN                        Aliase
127.0.0.1       localhost

# die Zwerge
10.27.210.17    snowwhite.zwerge.local    snowwhite
10.27.210.18    doc.zwerge.local          doc
10.27.210.19    happy.zwerge.local        happy
10.27.210.20    bashful.zwerge.local      bashful
10.27.210.21    sneezy.zwerge.local       sneezy
10.27.210.22    sleepy.zwerge.local       sleepy
10.27.210.23    grumpy.zwerge.local       grumpy
10.27.210.24    dopey.zwerge.local        dopey
...
</pre>

Nach der Internet-Adresse wird der "offizielle" Name des Systems angegeben, gefolgt von
Alias-Namen f&uuml;r dieses System. Wird als Argument f&uuml;r ein Netzwerk-Kommando ein Name
angegeben, so wird in dieser Datei die zugeh&ouml;rige Internet-Adresse ermittelt. Erst
&uuml;ber die Adresse wird eine Verbindung zum Zielsystem aufgebaut. Die Datei <TT>/etc/hosts</TT>
wird jedoch auch f&uuml;r den umgekehrten Vorgang benutzt. Mit einem
IP-Datagram wird nur die Internet-Adresse des sendenden Systems mitgeschickt. Soll
nun der zugeh&ouml;rige Name ermittelt werden, so geschieht dies ebenfalls mittels dieser
Datei. Das Resultat ist jedoch immer der "offizielle" Name des Systems. Deshalb ist
darauf zu achten, da&szlig; stets dieser Name verwendet werden mu&szlig;, wenn ein Rechnername
in weiteren Konfigurationsdateien eingetragen wird.
<P>
Jetzt wissen Sie auch, da&szlig; der Eintrag "<tt>127.0.0.1 www.microsoft.com</tt>"
in der <i>/etc/hosts</I> beispielsweise zu komischen Effekten f&uuml;hren w&uuml;rde
(welchen?).
<p>

<H3>/etc/networks</H3>
Genau wie f&uuml;r IP-Adressen m&ouml;chte man manchmal auch symbolische Namen f&uuml;r
Netzwerknummern verwenden. Aus diesem Grunde gibt es parallel zu <i>/etc/hosts</i> die
Datei <i>/etc/networks</i>, die Netzwerknamen auf Netzwerknummern abbildet. Diese
Datei wird nicht unbedingt ben&ouml;tigt.  Im Zwergenwald w&uuml;rden z.B. folgende
<i>networks</i>-Datei installiert:
<pre>
# /etc/networks
zwergenwald      172.20.20.0
</pre>
Beachten Sie, da&szlig; die Namen in <i>networks</i> nicht mit den Hostnamen in der Datei
<i>hosts</i> &uuml;bereinstimmen und kollidieren, da manche Programme ansonsten seltsame
Resultate produzieren.
<p>

<H3>/etc/protocols</H3>
In dieser Datei sind die Protokollnamen und Protokollnummern der Transportprotokolle
eingetragen, die das System unterst&uuml;tzt. Dank dieser Datei kann man in vielen
Programmen den symbolischen Namen eines Protokolls anstelle der Nummer angeben.
Jede Zeile der Datei enth&auml;lt den Namen des Transportprotokolls, die
Protokollnummer und den Aliasnamen des Protokolls, zum Beispiel:
<PRE>
ip      0     IP         # internet protocol, pseudo protocol number
icmp    1     ICMP       # internet control message protocol
igmp    2     IGMP       # Internet Group Management
ggp     3     GGP        # gateway-gateway protocol
ipencap 4     IP-ENCAP   # IP encapsulated in IP
tcp     6     TCP        # transmission control protocol
egp     8     EGP        # exterior gateway protocol
udp     17    UDP        # user datagram protocol
...
</PRE>
<P>

<H3>/etc/services</H3>
In dieser Datei werden die Namen von Netzwerkdiensten sowie die zugeh&ouml;rigen
Portnummern und Protokollnamen gespeichert Dank dieser Datei kann man in vielen
Programmen den symbolischen Namen eines Dienstes anstelle der Nummer angeben.
Beispiel:
<PRE>
...
ftp       21  tcp
ssh       22  tcp
telnet    23  tcp
smtp      25  tcp
whois     43  tcp
domain    53  tcp
gopher    70  tcp
finger    79  tcp
www       80  tcp
www       80  udp
...
</PRE>
<P>

<H3>/etc/nsswitch.conf</H3>
Diese Datei wird auch als "Resolver-Bibliothek" bezeichnet. Der Begriff <i>Resolver</i>
bezieht sich nicht auf ein spezielles Programm, sondern auf  eine Sammlung
von Funktionen, die bei Linux zur Standard-C-Bibliothek geh&ouml;ren. Ihre
wichtigsten Routinen sind <i>gethostbyname(2)</i> und <i>gethostbyaddr(2)</i>,
die alle zu einem Namen geh&ouml;renden IP-Adressen zur&uuml;ckliefern und umgekehrt.
&uuml;ber die Datei <i>/etc/nsswitch.conf</i> k&ouml;nnen Sie einstellen, ob Sie die
gew&uuml;nschten Informationen in <i>/etc/hosts</i> nachschlagen, DNS-Server befragen
oder die <i>hosts</i>-Datenbank des Network Information Service (NIS) benutzen wollen.
<p>
In der Datei <i>/etc/nsswitch.conf</i> kann der Systemadministrator eine Vielzahl
verschiedener Datenbanken konfigurieren. Wir besprechen hier nur diejenigen
Optionen, die sich auf die Aufl&ouml;sung von Host- und Netzwerk-IP-Adressen beziehen.
Optionen in <i>/etc/nsswitch.conf</i> m&uuml;ssen in getrennten Zeilen erscheinen, wobei
die Argumente durch Leerzeichen oder Tabulatorzeichen voneinander getrennt sein
m&uuml;ssen. Ein Doppelkreuz (#) leitet einen Kommentar ein, der sich bis zum
Zeilenende erstreckt. Jede Zeile beschreibt einen bestimmten Dienst, z.B. die
Aufl&ouml;sung von Hostnamen. Das erste Feld jeder Zeile gibt den Namen der Datenbank
an und endet mit einem Doppelpunkt. Der Rest jeder Zeile enth&auml;lt Optionen,
die die Art des Zugriffs auf die betreffende Datenbank regeln. Die folgenden
Optionen sind verf&uuml;gbar:
<P>
<table border=1 cellpadding=3 cellspacing=0 width="80%">
<tr><td><tt>dns</tt></td><td>
Verwendet das Domain Name System (DNS) zur Aufl&ouml;sung der Adresse. Das macht
allerdings nur Sinn bei der Aufl&ouml;sung von Hostadressen, nicht von Netzadressen.
Der Mechanismus benutzt die Datei <i>/etc/resolv.conf</i>.
</td></tr>
<tr><td><tt>files</tt></td><td>
Durchsucht eine lokale Datei nach den Host- oder Netznamen und ihren zugeh&ouml;rigen
IP-Adressen. Diese Option verwendet die traditionellen Dateien <i>/etc/hosts</i>
und <i>/etc/networks</i>.
</td></tr>
<tr><td><tt>nis</tt> oder <tt>nisplus</tt></td><td>
Verwendet das Network Information System (NIS) zur Aufl&ouml;sung einer Host- oder
Netzadresse.
</td></tr>
</table>
<p>
In der Reihenfolge, in der die Dienste angegeben sind, werden sie auch abgefragt,
wenn ein Name aufgel&ouml;st werden soll. Anspruch genommen, in der sie aufgelistet sind.
Diese Liste befindet sich in der Datei <i>/etc/nsswitch.conf</i> in dem Abschnitt,
in dem die Beschreibung der Dienste erfolgt. Die Dienste werden von links nach rechts
abgefragt, und die Suche wird standardm&auml;&szlig;ig beendet, wenn ein Wert (oder Name)
erfolgreich aufgel&ouml;st wurde. Zum Beispiel:
<pre>
# /etc/nsswitch.conf
#
hosts:          dns files
networks:       files
</pre>
Dieses Beispiel veranla&szlig;t das System, Hosts zuerst im DNS zu suchen und wenn dort
nichts gefunden wird, die Suche in der Datei <i>/etc/hosts</i> fortzusetzen. Um
Netzwerknamen aufzul&ouml;sen, wird ausschlie&szlig;lich die Datei <i>/etc/networks</i>
benutzt.
<p>
Sie k&ouml;nnen das Suchverhalten noch genauer kontrollieren, indem Sie zus&auml;tzlich
Aktionen (action items) angeben, die festlegen, welche Aktion nach dem jeweils letzten
Namensaufl&ouml;sungsversuch durchgef&uuml;hrt werden soll. Auf diese Erweiterungen wird
an dieser Stelle nicht weiter eingegangen.
<p>

<H3>/etc/resolv.conf</H3>
Wenn Sie die Resolver-Bibliothek f&uuml;r die Verwendung von DNS konfigurieren,
m&uuml;ssen Sie ihr auch mitteilen, welche Server sie benutzen soll. Daf&uuml;r
gibt es eine separate Datei namens <i>/etc/resolv.conf</i>. Fehlt diese Datei
oder ist sie leer, nimmt der Resolver an, da&szlig; sich der Name-Server auf
Ihrem lokalen Host befindet.
Um einen Name-Server auf Ihrem lokalen Host laufen zu lassen, m&uuml;ssen Sie
ihn separat einrichten. Normalerweise verwendet man einen bereits vorhandenen
Name-Server. Bei einer Dialup-Verbindung ins Internet wird f&uuml;r gew&ouml;hnlich der
Name-Server des Providers in der Datei <i>/etc/resolv.conf</i> eintragen.
<p>
Die wichtigste Option in <i>/etc/resolv.conf</i> ist daher <i>nameserver</i>, welche
die Adresse eines Name-Servers angibt. Wenn Sie die Option mehrmals angeben,
werden die Server in der angegebenen Reihenfolge verwendet. Deshalb sollten Sie
unbedingt den zuverl&auml;ssigsten Server an erster Stelle eintragen. Wenn Sie
keinen Name-Server eintragen, nimmt der Resolver an, da&szlig; einer auf der lokalen
Maschine l&auml;uft. Gegenw&auml;rtig werden bis zu drei <i>nameserver</i>-Eintr&auml;ge
in <i>/etc/resolv.conf</i> unterst&uuml;tzt.
<p>
Zwei weitere Befehle, <i>domain</i> und <i>search</i>, geben Domainnamen an,
die der Resolver an einen Namen anh&auml;ngt, wenn die zugeh&ouml;rige Adresse beim ersten
Versuch nicht gefunden wird. Mit <i>domain</i> k&ouml;nnen Sie eine Default-Domain
angeben, die immer dann angeh&auml;ngt werden soll, wenn ein Name nicht aufgel&ouml;st
werden konnte. Wird dem Resolver z.B. der Name "<i>sleepy</i>" &uuml;bergeben, findet
dieser den Namen "<i>sleepy<b>.</b></i>" nicht im DNS, da es eine solche Top-Level-Domain
nicht gibt. Wird "<i>zwerge.local</i>" als Standarddom&auml;ne angegeben, wiederholt der
Resolver seine Anfrage und h&auml;ngt diese Standarddom&auml;ne an den Hostnamen an.
Die Abfrage nach "<i>sleepy.zwerge.local</i>" ist nun erfolgreich (nat&uuml;rlich
nur, wenn es einen Nameserver gibt).
<p>
Mit der Option <i>search</i> kann eine Suchliste angegeben werden, gewisserma&szlig;en
eine Verallgemeinerung der <i>domain</i>-Anweisung. W&auml;hrend bei <i>domain</i>
nur eine einzelne Domain angeben werden darf, akzeptiert <i>search</i> eine
ganze Liste davon, deren Eintr&auml;ge alle der Reihe nach durchprobiert werden,
bis ein g&uuml;ltiger DNS-Eintrag gefunden wird. Die einzelnen Namen der Liste
m&uuml;ssen durch Leerzeichen oder Tabulatoren voneinander getrennt werden.
<p>
Die Befehle <i>search</i> und <i>domain</i> schlie&szlig;en einander aus und d&uuml;rfen
h&ouml;chstens einmal auftauchen. Wenn keiner der beiden Befehle angegeben ist, versucht
der Resolver, die Default-Domain mit Hilfe der Systemfunktion <i>getdomainname(2)</i>
aus dem lokalen Hostnamen zu raten. Hat der Hostname keinen Domain-Teil, wird als
Default-Domain die Root-Domain (<i>.</i>) angenommen.
<p>
Werfen Sie einen Blick auf die Datei <i>resolv.conf</i> des Zwergenwaldes:
<pre>
# /etc/resolv.conf
# Unsere Domain
domain         zwerge.local
#
# Wir benutzen "doc" als zentralen Name-Server:
nameserver     172.20.20.1
</pre>
Wenn Sie in dieser Konfiguration die Adresse von "<i>dopey</i>" suchen, wird der
Resolver erst versuchen, "<i>dopey<b>.</b></i>" nachzuschlagen, und wenn das
fehlschl&auml;gt, "<i>dopey.zwerge.local</i>".
<p>

<H3>Netzwerk-Konfiguration f&uuml;r IP</H3>
Zur Konfiguration der Ethernet-Schnittstellen und Initialisierung der Routing-Tabelle
sind zwei Befehle von besonderer Bedeutung, n&auml;mlich <i>ifconfig</i> (Interface-Konfiguration)
und <i>route</i>.
<p>

<H4>Schnittstellenkonfiguration mit dem <TT>ifconfig</TT>-Kommando</H4>
Das Starten von TCP/IP erfolgt (unter Unix) durch Shell-Skripte, die je nach
Unix-Derivat anders hei&szlig;en und sich an ganz unterschiedlichen Stellen des jeweiligen
Dateisystems befinden k&ouml;nnen (Bei Linux beispielsweise im Verzeichnis <i>/etc/init.d</i>.
So unterschiedlich die Shell-Skripte auch sein m&ouml;gen, die Initialisierung
der Netzwerksoftware erfolgt in jedem Falle durch das <i>ifconfig</i>-Kommando. Hier
wird auch die Initialisierung der Netzwerkschnittstellen vorgenommen. Dabei gibt es
folgende Arten von Schnittstellen:
<UL>
<LI> das Loopback-Interface,
<LI> Broadcast-Interfaces und
<LI> Point-to-Point-Interfaces.
</UL>
Das Loopback-Interface ist eine spezielle Schnittstelle, die zum lokalen System
zur&uuml;ckgef&uuml;hrt. Dies bedeutet, da&szlig; alle Daten, die durch das Loopback-Interface
geschickt werden, wieder im lokalen System empfangen werden, Dieser Mechanismus
erlaubt eine Kommunikation von lokalen Prozessen &uuml;ber TCP/IP und wird insbesondere
von TCP/IP-Verwaltungsprozessen, aber auch von anderen Diensten genutzt (so z.B. bei
Datenbanken). Die Standard-Internet-Adresse der Loopback-Schnittstelle ist 127.0.0.1
und sollte, obwohl es theoretisch m&ouml;glich ist, nicht ver&auml;ndert werden.
<P>
<i>ifconfig</i> dient dazu, eine Schnittstelle f&uuml;r die Netzwerkschicht des Kernels sichtbar
zu machen. Das beinhaltet die Zuweisung einer IP-Adresse und verschiedener anderer Parameter
sowie die Aktivierung des Interface, damit der Kernel die IP-Pakete &uuml;ber diese
Schnittstelle senden und empfangen kann. Die einfachste Art, es aufzurufen, ist:
<pre>
ifconfig &lt;interface&gt; &lt;ip-addresse&gt; netmask &lt;maske&gt;
</pre>
Der Befehl weist "interface" die Adresse "ip-adresse" zu und aktiviert es. Alle anderen
Parameter werden auf Standardwerte gesetzt. Fehlt die Netzmaske (<TT>netmask &lt;maske&gt;</TT>),
wird sie aus der Netzwerkklasse der Adresse abgeleitet; f&uuml;r ein Klasse-B-Netz w&auml;re
das <i>255.255.0.0</i>. Oftmals besteht das Kommando aber zumindest auf der Netzmaske
als Parameter. Sp&auml;ter dazu mehr.
<p>
Initialisiert wird das Loopback-Interface durch das Kommando:
<PRE>
ifconfig lo 127.0.0.1
</PRE>
Sogenannte "Broadcast-Interfaces" sind die &uuml;blichen Schnittstellen zu lokalen Netzwerken,
&uuml;ber die mehrere Systeme erreichbar sind, und &uuml;ber die Broadcasts, also Nachrichten
an alle, verschickt werden. Es handelt sich dabei um Schnittstellen zu Ethernet und TokenRing.
Neben der Internet-Adresse werden bei der Initiatisierung des Broadcast-Interfaces auch
die Netzmaske und die Broadcast-Adresse angegeben:
<P>
<TT>ifconfig eth0 192.168.0.1 netmask 255.255.255.0 broadcast 192.168.0.255</TT>
<P>
Neben den Broadcast-Schnittstellen gibt es noch die sogenannten
Point-to-Point-Schnittstellen. Sie sind dadurch gekennzeichnet, da&szlig; man nur &uuml;ber sie
ein anderes System erreichen kann. Beispiele sind SLIP (Serial Line IP) und das
Point-to-Point-Protokoll PPP, die Verbindungen &uuml;ber die serielle Schnittstelle oder
per Modem/ISDN-Adapter WAN-Verbindungen zulassen. Die Initialisierung einer
Point-to-Point-Schnittstelle hat z.B. die folgende Form:
<P>
<TT>ifconfig ppp0 192.168.1.1 192.168.1.2 netmask 255.255.255.240</TT>
<P>
So eine PPP-Verbindung bildet ein eigenst&auml;ndiges Netzwerk. Sollen mehrere Verbindungen
kombiniert werden, so mu&szlig; eine Unterteilung in Subnetze erfolgen. Das hei&szlig;t, da&szlig; eine
entsprechende Netzmaske gew&auml;hlt werden mu&szlig;.
<P>

<i>ifconfig</i> kennt eine ganze Reihe von Optionen. Der allgemeine Programmaufruf lautet:
<pre>
ifconfig interface [address [parameters]]
</pre>
<i>interface</i> ist der Name der zu konfigurierenden Schnittstelle, und
<i>address</i> ist die IP-Adresse, die ihr zugewiesen werden soll. Sie
kann entweder als dotted quad angegeben werden oder als Name,
den <i>ifconfig</i> in <i>/etc/hosts</i> nachschl&auml;gt.
<p>
Ein Aufruf nur mit dem Interface-Namen gibt die Konfiguration des
Interface aus. Wird es ganz ohne Parameter aufgerufen, zeigt es alle
bisher konfigurierten Schnittstellen an; die Option <b>-a</b> erzwingt
zus&auml;tzlich die Anzeige der inaktiven. Beispiel:
<pre>
# ifconfig eth0
eth0      Link encap 10Mbps Ethernet  HWaddr 00:00:C0:90:B3:42
          inet addr 172.20.20.2 Bcast 172.20.20.255 Mask 255.255.255.0
          UP BROADCAST RUNNING  MTU 1500  Metric 0
          RX packets 3136 errors 217 dropped 7 overrun 26
          TX packets 1752 errors 25 dropped 0 overrun 0

</pre>
MTU gibt die maximale Blockgr&ouml;&szlig;e an.
Die Metrik wird von einigen Betriebssystemen verwendet, um die Kosten einer
Route zu berechnen. Linux benutzt diesen Wert bisher nicht, definiert ihn
aber trotzdem aus Gr&uuml;nden der Kompatibilit&auml;t.
Die Zeilen <tt>RX</tt> und <tt>TX</tt> zeigen an, wie viele Pakete empfangen
(RX - <i>receive</i>) bzw. gesendet wurden (TX - <i>transmit</i>), wie viele
Fehler dabei auftraten, wie viele Pakete verworfen wurden (dropped) und wie
viele wegen eines &uuml;berlaufs (overrun) verlorengingen. Ein &uuml;berlauf beim Empf&auml;nger
tritt dann auf, wenn Pakete schneller hereinkommen, als der Kernel die Interrupts
bedienen kann.
<p>
Die folgende Liste zeigt die Parameter, die <i>ifconfig</i> versteht; die Namen
der zugeh&ouml;rigen Flags stehen in Klammern. Optionen, die eine bestimmte Eigenschaft
des Interface aktivieren, k&ouml;nnen mit vorangestelltem Minuszeichen (-) auch benutzt
werden, um ihn wieder auszuschalten.
<p>
<table border=1 cellpadding=3 cellspacing=1 width="90%">
<tr><td><tt>up</tt></td><td>
Aktiviert ein Interface f&uuml;r die IP-Schicht des Kernels. Sie wird impliziert, wenn
auf der Kommandozeile eine Adresse angegeben ist. Sie kann auch dazu benutzt werden,
ein Interface zu reaktivieren, wenn es mit der <tt>down</tt>-Option tempor&auml;r
deaktiviert wurde. Entspricht den Flags <i>UP</i> und <i>RUNNING</i>.
</td></tr>
<tr><td><tt>down</tt></td><td>
Markiert eine Schnittstelle als inaktiv, d.h. unzug&auml;nglich f&uuml;r die Netzwerkschicht.
Dadurch wird jeglicher IP-Transport durch die Schnittstelle unterbunden. Beachten
Sie, da&szlig; dadurch automatisch alle Routing-Eintr&auml;ge gel&ouml;scht werden, die diese
Schnittstelle verwenden.
</td></tr>

<tr><td><tt>netmask</tt>&nbsp;Maske</td><td>
Weist des Interface eine Subnetzmaske zu. Sie kann entweder als eine
32-Bit-Hexadezimalzahl (mit f&uuml;hrender 0x) oder als dotted quad
(Beispiel: 255.255.255.0) angegeben werden.
</td></tr>
<tr><td><tt>pointopoint</tt>&nbsp;Adresse</td><td>
Wird f&uuml;r Punkt-zu-Punkt-Verbindungen benutzt, die nur zwei Hosts miteinander
verbinden. Sie wird beispielsweise f&uuml;r die Konfiguration von SLIP- und
PLIP-Schnittstellen ben&ouml;tigt und teilt dem Kernel die IP-Adresse des
anderen Systems mit. Falls eine Punkt-zu-Punkt-Adresse gesetzt wurde,
zeigt <i>ifconfig</i> das <i>POINTOPOINT</i>-Flag an ("pointopoint" wird
wirklich so geschrieben).
</td></tr>
<tr><td><tt>broadcast</tt>&nbsp;Adresse</td><td>
Die Broadcast-Adresse wird normalerweise aus der Netzwerknummer gebildet,
indem alle Bits des Hostanteils auf eins gesetzt werden. Einige IP-Implementierungen
verwenden dagegen eine Broadcast-Adresse, bei der die Bits des Hostteils auf null
gesetzt sind. Die Option <b>broadcast</b> dient dazu, Ihre Konfiguration an eine derartige
Umgebung anzupassen. Wenn dem Interface eine Broadcast-Adresse zugeordnet wurde,
gibt <i>ifconfig</i> das Flag <i>BROADCAST</i> aus.
</td></tr>
<tr><td><tt>metric</tt>&nbsp;Wert</td><td>
Dem Routing-Tabellen-Eintrag des Interface einen Metrikwert zuordnen. Dieser Wert
wird beispielsweise vom <i>Routing Information Protocol</i> (RIP) ber&uuml;cksichtigt, wenn
es Routing-Tabellen f&uuml;r Ihr Netz erstellt. Die Default-Metrik, die <i>ifconfig</i>
einem Interface zuweist, ist 0. Wenn Sie das Routing in Ihrem Netz nicht mit RIP
regeln, ben&ouml;tigen Sie diese Option nicht; aber auch sonst wird die Option
selten benutzt.
</td></tr>
<tr><td><tt>mtu</tt>&nbsp;Bytes</td><td>
Setzen der <i>Maximum Transmission Unit</i> (MTU), d.h. die maximale Anzahl von
Bytes, die das Interface in einer Transaktion behandeln kann. F&uuml;r Ethernets liegt
der Defaultwert bei 1500; f&uuml;r SLIP betr&auml;gt er 296.
</td></tr>
<tr><td><tt>arp</tt></td><td>
Kann nur f&uuml;r Broadcast-f&auml;hige Netz wie Ethernet verwendet werden. Erm&ouml;glicht
die Benutzung von ARP zur Zuordnung von IP-Adressen zu physikalischen Adressen.
F&uuml;r Broadcast-Netze wird sie per Voreinstellung eingeschaltet. Ist ARP
abgeschaltet, zeigt <i>ifconfig</i> das <b>NOARP</b>-Flag an.
<tt>-arp</tt> schaltet ARP explizit aus.
</td></tr>
<tr><td><tt>promisc</tt></td><td>
Versetzt die Schnittstelle in den promiscous mode. Auf Broadcast-Netzen hat
das zur Folge, da&szlig; die Schnittstelle alle Pakete unabh&auml;ngig davon empf&auml;ngt,
ob sie f&uuml;r einen anderen Host bestimmt sind oder nicht. Dadurch kann man den
Netzwerkverkehr mit Paketfiltern wie <i>tcpdump</i> analysieren.
<tt>-promisc</tt> schaltet den Modus ab.
</td></tr>

<tr><td><tt>allmulti</tt></td><td>
Multicast-Adressen sind wie Ethernet-Broadcast-Adressen, mit der Einschr&auml;nkung,
da&szlig; sie nicht automatisch jeden m&ouml;glichen Adressaten ber&uuml;cksichtigen, sondern
nur solche, die ausdr&uuml;cklich zum Empfang vorgesehen (programmiert) sind. Sie
eignen sich besonders f&uuml;r Anwendungen wie Ethernet-basierte Videokonferenzen
oder Audio&uuml;bertragungen &uuml;bers Netz, die nur an Interessierte gerichtet sind.
<tt>-allmulti</tt> schaltet Multicast-Adressen ab.
</td></tr>
</table>
<p>

<h4>Das route-Kommmando</h4>
<i>route</i> erlaubt es Ihnen, Routen in die Routing-Tabelle des Kernels einzutragen oder
aus ihr zu entfernen. Es kann aufgerufen werden als:
<pre>
route [add|del] [-net|-host] &lt;target&gt; [dev &lt;if&gt;]
</pre>
Dabei bestimmen die Argumente <b>add</b> bzw. <b>del</b>, ob die Route zu <i>target</i>
eingetragen bzw. aus <i>target</i> entfernt wird. Die Optionen <b>-net</b> und <b>-host</b>
teilen dem route-Kommando mit, ob target ein Netzwerk oder ein Hostrechner ist
(letzteres wird angenommen, wenn Sie hier nichts angeben). Das Argument <i><b>dev </b>if</i> ist optional
und erlaubt Ihnen die Angabe einer Netzwerkschnittstelle, an die die Route gerichtet werden soll.
Wenn Sie dem Kernel keine Informationen dar&uuml;ber geben, versucht er selbst, ein sinnvolles Argument
herauszufinden.
<p>

<h4>Den Rechner konfigurieren</h4>
Das allererste Interface, die aktiviert werden mu&szlig;, ist das Loopback-Interface:
<pre>
ifconfig lo 127.0.0.1
</pre>
<p>
Manchmal wird anstelle der IP-Adresse auch der Name <i>localhost</i> verwendet. Der Befehl
<i>ifconfig</i> sucht diesen Namen in der Datei <i>/etc/hosts</i>, wo er als Hostname f&uuml;r
<i>127.0.0.1</i> definiert sein mu&szlig;.
<p>
Zur Anzeige der Konfiguration eines Interface rufen Sie <i>ifconfig</i> mit dem Namen
des Interface auf. Ganz ohne Parameter wird die Konfiguration aller Interfaces gezeigt:
<pre>
ifconfig lo
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:3924  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          Collisions:0
</pre>
<p>
Nun fehlt noch ein Eintrag in der Routing-Tabelle, der festlegt, da&szlig; dieses Interface als
Route f&uuml;r das Zielsystem <i>127.0.0.1</i> dient. Dazu geben Sie folgendes ein:
<pre>
route add 127.0.0.1
</pre>
Es kann auch hier wieder anstelle der IP-Adresse der Namen <i>localhost</i> verwendet werden
(sofern er in <i>/etc/hosts</i> eingetragen ist).
<p>
Es w&auml;re auch m&ouml;glich, das Netz von <i>localhost</i> einzutragen:
<pre>
route add -net 127.0.0.0
</pre>
Als n&auml;chstes wird mit dem Programm <i>ping</i> getestet, ob alles einwandfrei funktioniert:
<PRE>
ping localhost
PING localhost (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=0.4 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=255 time=0.4 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=255 time=0.4 ms
^C
--- localhost ping statistics ---

3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.4/0.4/0.4 ms
</pre>
Pakete an <i>127.0.0.1</i> werden also korrekt ausgeliefert und es erfolgt sofort eine Antwort.
Das beweist, da&szlig; die erste Netzwerkschnittstelle erfolgreich konfiguriert wurde.
<p>
Die bisher beschriebenen Schritte reichen aus, um Netzwerk-Programme auf einem alleinstehenden
Rechner zu benutzen. Die oben angegebenen Zeilen m&uuml;ssen in das Netzwerk-Initialisierungsskript
eingetragen werden, damit sie beim Systemstart ausgef&uuml;hrt werden. In der Regel wird zumindest
die Konfiguration von "lo" beim Installieren des Systems bereits erledigt. Zur Einstimmung
war das obige aber keine schlechte &Uuml;bung. Nun sollte zum Beispiel <i>telnet localhost</i>
eine <i>telnet</i>-Verbindung aufbauen und Ihnen den Login-Prompt Ihres Systems geben.
<p>
Die Konfiguration von Ethernet-Schnittstellen geht fast genauso vonstatten wie eben. Man
braucht nur ein paar Parameter mehr, um auch Subnetze verwenden zu k&ouml;nnen.
<p>
Im Zwergenwald wird vom Klasse-B-Netz nur ein C-Subnetz verwendet. Um
dies dem Interface mitzuteilen, sieht der <i>ifconfig</i>-Aufruf so aus:
<pre>
ifconfig eth0 172.20.20.2 netmask 255.255.255.0
</pre>
oder unter Verwendung des Namens aus <i>/etc/hosts</I>:
<pre>
ifconfig eth0 doc netmask 255.255.255.0
</pre>
Dies weist des Interface <i>eth0</i> die IP-Adresse von <i>doc</i> (<i>172.20.20.2</i>) zu.
H&auml;tte man die Netzmaske weggelassen, w&auml;re sie von <i>ifconfig</i> aus der Netzklasse der
Adresse abgeleitet worden, was den inkorrekten Wert von <i>255.255.0.0</i> ergeben h&auml;tte.
Ein schneller Test ergibt jetzt:
<pre>
ifconfig eth0
eth0      Link encap 10Mps Ethernet HWaddr  00:00:C0:90:B3:42
          inet addr 172.20.20.2 Bcast 172.20.20.255 Mask 255.255.255.0
          UP BROADCAST RUNNING  MTU 1500  Metric 1
          RX packets 0 errors 0 dropped 0 overrun 0
          TX packets 0 errors 0 dropped 0 overrun 0
</pre>
<i>ifconfig</i> hat die Broadcast-Adresse (im <tt>Bcast</tt>-Feld angezeigt) automatisch auf
den passenden Wert gesetzt, n&auml;mlich die Netzwerknummer mit einem Hostteil, bei dem alle
Bits auf eins gesetzt sind. Au&szlig;erdem wurde die maximale &uuml;bertragungseinheit (MTU = <i>Maximum
Transmission Unit</i>, die maximale Gr&ouml;&szlig;e der IP-Pakete) auf das Ethernet-spezifische Maximum
von 1.500 Bytes eingestellt.
<p>
Wie bereits bei der Loopback-Schnittstelle mu&szlig; noch eine Route eingetragen werden. F&uuml;r den
Zwergenwald gilt:
<pre>
route add -net 172.20.20.0
</pre>
Damit ist eine Route definiert, die alle Pakete, die ans Netz 172.20.20.0
gerichtet sind an die Ethernetkarte schickt. Das wei&szlig; das System, weil die
Ethernetkarte ja die Adresse 172.20.20.2 hat, also die gleiche
Netzadresse. Dieser Befehl ist bei modernen Versionen von <b>ifconfig</b>
unn&ouml;tig geworden, weil diese Route eben automatisch bei der Konfiguration
angelegt wird.
<P>
Vielleicht haben Sie bemerkt, da&szlig; die Angabe des Interface fehlt. Der Kernel pr&uuml;ft alle bisher
konfigurierten Interfaces und vergleicht das Zielnetz (in unserem Fall <i>172.20.20.0</i>) mit
der Netznummer der Interface-Adresse, d.h. dem bitweisen UND der Interface-Adresse und der
Netzmaske. Die einzige Schnittstelle, bei der diese beiden Werte &uuml;bereinstimmen, ist <i>eth0</i>.
<p>
Die Option <b>-net</b> ist n&ouml;tig, da <i>route</i> sowohl Routen zu Netzwerken
als auch zu einzelnen Hosts einrichten kann. Wenn man <i>route</i> eine IP-Adresse
&uuml;bergibt, versucht das Kommando festzustellen, ob es sich dabei um eine Host- oder Netzadresse
handelt, indem es den Hostteil betrachtet. Ist der Hostteil null, wird angenommen, da&szlig; es sich um
eine Netz-Adresse handelt, andernfalls ist es eine Hostadresse. Deshalb w&uuml;rde <i>route</i> in
unserem Beispiel davon ausgehen, da&szlig; <tt>172.20.20.0</tt> eine Hostadresse ist (Netz:
<tt>172.20.0.0</tt>, Host: <tt>...20.0</tt>). Da ein Subnetz verwendet wird, braucht das
<i>route-</i>Kommando den Parameter "-net".
<p>
Unter Verwendung des Eintrags in <i>/etc/networks</i> wird das Kommando einfacher:
<pre>
route add zwergenwald
</pre>
<p>
Nun sollte man &uuml;berpr&uuml;fen, ob das Ethernet tats&auml;chlich arbeitet. W&auml;hlen Sie irgendeine
bereits konfigurierte Maschine auf Ihrem lokalen Ethernet, z.B. <i>grumpy</i>, und
geben Sie folgenden Befehl ein:
<pre>
# ping grumpy
PING grumpy: 64 byte packets
64 bytes from 172.20.20.1: icmp_seq=0. time=10. ms
64 bytes from 172.20.20.1: icmp_seq=1. time=7. ms
64 bytes from 172.20.20.1: icmp_seq=2. time=8. ms
^C

----doc.zwerge.local PING Statistics----

4 packets transmitted, 4 packets received, 0 packets lost
</pre>

Wenn <i>ping</i> keinerlei Antwort bekommt, sollten Sie die Schnittstellenkonfiguration
mit <i>netstat</i> &uuml;berpr&uuml;fen. Die Paketstatistiken, die <i>ifconfig</i> ausgibt, geben
an, ob &uuml;berhaupt Pakete &uuml;ber das Interface &uuml;bertragen wurden. Zus&auml;tzlich sollten Sie
auf beiden Maschinen mit <i>route</i> die Routing-Informationen &uuml;berpr&uuml;fen. Wenn
Sie <i>route</i> ohne weitere Parameter aufrufen, gibt es die Routing-Tabellen aus.
Die Option <i>-n</i> sorgt daf&uuml;r, da&szlig; es Adressen numerisch anstelle der
symbolischen Hostnamen darstellt:
<pre>
route -n
Kernel routing table
Destination  Gateway  Genmask         Flags Metric Ref Use    Iface
127.0.0.1    *        255.255.255.255 UH    1      0   112    lo
172.20.20.0   *       255.255.255.0   U     1      0    10    eth0
</pre>
<p>

Die Spalte "Flags" enth&auml;lt eine Liste von Flags f&uuml;r jedes Interface. <i>U</i> ist
f&uuml;r aktive Schnittstellen immer gesetzt. Ein Flag <i>H</i> in dieser Spalte besagt,
da&szlig; die Zieladresse einen einzelnen Host bezeichnet. Wenn eine eingetragene Route
benutzt wird, &auml;ndert sich der Wert im <i>Use</i>-Feld st&auml;ndig.
<P>
Bisher wurde eine Maschine auf einem isolierten Ethernet eingerichtet (z.B. in
einem Heimnetz). Der Regelfall ist allerdings, da&szlig; mehrere Netze durch Gateways
miteinander verbunden sind (man will ja auch "nach drau&szlig;en"). Diese Gateways
verbinden zwei oder mehrere Ethernets miteinander, oder sie stellen das Tor zum
Internet bereit. Um einen Gateway zu nutzen, mu&szlig; der Netzwerkschicht zus&auml;tzliche
Routing-Informationen zur Verf&uuml;gung stehen.
</p>
<p>
Zum Beispiel sind die Ethernets des Zwergenwaldes und des Feenreichs durch solch
ein Gateway miteinander verbunden, n&auml;mlich <i>doc</i>, der bereits konfiguriert
sei. Auf allen Maschinen des Zwergenwaldes mu&szlig; nur noch eine weitere Route
eingetragen werden, die angibt, da&szlig; alle Maschinen im Netzwerk der Feen &uuml;ber
<i>doc</i> erreichbar sind. Der entsprechende Aufruf von <i>route</i> sieht so aus
(sofern <tt>feenreich</tt> in <i>/etc/networks</i> eingetragen wurde):
<pre>
route add feenreich gw doc
</pre>
Dabei gibt <i>gw</i> an, da&szlig; das folgende Argument ein Gateway bezeichnet.
Nat&uuml;rlich mu&szlig; jedes System im Feen-Netz, zu dem Sie Verbindung aufnehmen wollen,
einen analogen Routing-Eintrag f&uuml;r das Zwergen-Netz haben. Sonst k&ouml;nnten Sie
nur Daten vom Zwergen-Netz an das Feen-Netz senden, die Rechner im Feen-Netz
w&auml;ren aber zu keiner Antwort f&auml;hig.
<p>
Das war nun ein Gateway, das Pakete zwischen zwei isolierten Netzen bef&ouml;rdert.
Nehmen Sie nun an, da&szlig; <i>doc</i> au&szlig;erdem eine Verbindung ins Internet hat.
Dann w&auml;re es w&uuml;nschenswert, da&szlig; Pakete f&uuml;r <i>beliebige</i> Zieladressen, die
nicht im Zwergen-Netz liegen, an <i>doc</i> weitergereicht werden. Das erreicht
man, indem <i>doc</i> zum Default-Gateway wird:
<pre>
route add default gw doc                 oder
route add default gw 172.20.20.1         bei Angabe der IP-Adresse
</pre>
Die Netzwerkadresse <i>default</i> ist eine Abk&uuml;rzung f&uuml;r <i>0.0.0.0</i>, die
Default-Route. Sie pa&szlig;t zu jeder Zieladresse und wird immer dann benutzt, wenn
keine andere eingetragene Route pa&szlig;t.
<p>
Es ist ziemlich einfach, eine Maschine als Gateway einzurichten. Nehmen wir an,
wir bef&auml;nden uns wieder auf <i>doc</i>, der mit zwei Ethernet-Karten ausgestattet
ist, die jeweils mit einem der beiden Netze verbunden sind. Man mu&szlig; nur beide
Schnittstellen getrennt konfigurieren und ihnen eine Adresse auf dem jeweiligen
Subnetz zuzuweisen. Dabei ist es recht n&uuml;tzlich, zus&auml;tzlich zum offiziellen
Hostnamen <i>doc</i> zwei Namen f&uuml;r die beiden Schnittstellen in
<i>/etc/hosts</i> zu definieren:
<pre>
172.20.20.1      doc.zwerge.local    doc   doc-if1
172.20.21.1      doc-if2
</pre>
<p>
Mit diesen Eintr&auml;gen lautet die Befehlsreihenfolge f&uuml;r die Einrichtung der
beiden Interfaces:
<pre>
ifconfig eth0 doc-if1 ...
route add zwergenwald
ifconfig eth1 doc-if2 ...
route add feenreich
</pre>
Damit Pakete &uuml;berhaupt zwischen den verschiedenen Netzwerkschnittstellen vermittelt
werden, bedarf es in neueren Kerneln des Kommandos
<pre>
echo '1' > /proc/sys/net/ipv4/ip_forward
</pre>
Wenn es dann nicht funktioniert, &uuml;berpr&uuml;fen Sie, ob Ihr Kernel mit Unterst&uuml;tzung
f&uuml;r IP-Forwarding &uuml;bersetzt wurde.
<P>
Sie brauchen nicht einmal eine zweite Netzwerkkarte, denn es gibt sogenannte "Device-Aliase".
Dies sind virtuelle Ger&auml;te, die mit der gleichen physischen Hardware verbunden sind, jedoch
gleichzeitig aktiviert werden k&ouml;nnen, um unterschiedliche IP-Adressen zu haben. Sie werden
normalerweise mit dem Ger&auml;tennahmen gefolgt von einem Doppelpunkt und einer Zahl dargestellt
(zum Beispiel <i>eth0:1</i>). Wenn Sie einen Alias verwenden, k&ouml;nnen weder das Interface
noch der Alias zur Verwendung von DHCP konfiguriert werden. <i>eth0:1</i> ist der erste Alias
f&uuml;r <i>eth0</i>. Der zweite Alias h&auml;tte den Namen <i>eth0:2</i>, usw. Die Befehle
um beide Netze &uuml;ber eine Netzwerkkarte zu routen, w&uuml;rden lauten:
<pre>
ifconfig eth0 doc-if1 ...
route add zwergenwald
ifconfig eth0:1 doc-if2 ...
route add feenreich
</pre>
<P>
Die Fehlermeldungen des route-Kommandos sind relativ kryptisch. Bei Linux kann - im Gegensatz zu
anderen Unixen - die Metrik-Angabe entfallen. Man kann mehrere Routen zu einem Ziel (mit identischer
Netzmaske) eingeben, sofern jeweils ein anderer Gateway angegeben wird.
<P>
<H4>Fehlermeldungen des route-Kommandos:</H4>
<ul>
<li><b>SIODELRT</b> ist eine Fehlermeldung beim L&ouml;schen einer Route (<b>DEL</b>eting a <b>R</b>ou<b>T</b>e)
<li><b>SIOADDRT</b> ist eine Fehlermeldung beim Anlegen einer Route (<b>ADD</b>ing a <b>R</b>ou<b>T</b>e)
</ul>
<DL>
<P><DT><i>SIOCADDRT: Network is unreachable</i>
<DD>
<TT>route add default gw 1.2.3.4</TT><br>
Die angebene Adresse geh&ouml;rt nicht zum eigenen Netzwerk und so kann der Rechner keine
Pakete dorthin weiterleiten.

<P><DT><i>SIOCADDRT: File exists</i>
<DD>Die angegebene Route existiert bereits.

<P><DT><i>SIOCADDRT: No such device</i>
<DD>Es wurde das Schl&uuml;sselwort <i>gw</i> vor der Default-Gateway-Adresse vergessen; also nicht:<br>
<TT>route add -net 10.2.2.76/24  10.1.1.22</TT><BR>
sondern:<br>
<TT>route add -net 10.2.2.76/24  gw 10.1.1.22</TT>

<P><DT><i>SIOCDELRT No such process</i>
<DD>Versuch, eine Route zu l&ouml;schen, die nicht existiert.

<P><DT><i>SIOCADDRT: Operation not supported by device</i>
<DD>Es wurde das Schl&uuml;sselwort <i>gw</i> oder die Gateway-Adresse vergessen; also nicht:<br>
<TT>route add -net 10.0.0.0/8 10.1.1.254</TT> oder<br>
<TT>route add -net 172.23.24.128/25</TT><br>
sondern:<br>
<TT>route add -net 10.0.0.0/8 gw  10.1.1.254</TT> oder<br>
<TT>route add -net 172.23.24.128/25 gw 10.1.1.22</TT>

<P><DT><i>SIOCADDRT: Operation not permitted</i>
<DD>Sie arbeiten nicht mit <i>root</i>-Berechtigung.

<P><DT><i>SIOCADDRT: Invalid argument</i>
<DD>Falsche Kommandosyntax (z.B. vergessene Netzmaske); also nicht:<br>
<TT>route add -net 10.2.2.0 gw 10.1.1.254</TT> oder<br>
<TT>route del -net 172.23.0.0</TT><br>
sondern:<br>
<TT>route add -net 10.2.2.0 netmask 255.255.255.0 gw 10.1.1.254</TT> oder<br>
<TT>route add -net 10.2.2.0/24 gw 10.1.1.254</TT> bzw.<br>
<TT>route del -net 172.23.0.0/16</TT> oder<br>
<TT>route del -net 172.23.0.0 netmask 255.255.0.0</TT>

<P><DT><i>route: netmask doesn't match route address</i>
<DD>Die Netzmaske passt nicht zur Host- und Gateway-Adresse.

<P><DT><i>route: netmask 00ffffff doesn't make sense with host route</i>
<DD>Meist wurde der Parameter <i>-net</i> vergessen. Das Kommando nimmt
dann an, dass man eine Host-Route angeben will. Oder man hat bei einer
Host-Route eine Netzmaske angegeben.

<P><DT><i><i>addr</i>: Unknown host</i>
<DD>Meist wurde eine falsche Netzmaske angegebn, die das Kommando falsch
interpretiert.

<P><DT><i>route: bogus netmask 255.255.255.25</i>
<DD>Die Netzmaske ist falsch angegeben worden (z.B. '25' oder '2555' statt '255').
</DL>
<p>
Anmerkung: Die Syntax des route-Kommandos variiert von System zu System.
<P>

<h4>Linux Netzwerk-Konfiguration mit <tt>ip</tt></h4>
Das Kommando <tt>ip</tt> ersetzt die bisherigen Kommandos <tt>ifconfig</tt> und <tt>route</tt>:
<ul><li><tt>ip address &lt;parameter&gt;</tt> richtet die Netzwerkschnittstellen ein (ersetzt <tt>ifconfig</tt>),</li>
<li><tt>ip route &lt;parameter&gt;</tt> richtet das Routing ein (ersetzt <tt>route</tt>),</li>
<li><tt>ip rule &lt;parameter&gt;</tt> richtet Policy Routing ein (erweitertes Routing in Linux) und</li>
<li><tt>ip neigh &lt;parameter&gt;</tt>: Verwaltet die ARP-Tabelle (ersetzt das Kommando <tt>arp</tt>).</li>
</ul>
<p>
Der <tt>ip</tt>-Aufruf zeigt wie <tt>ifconfig</tt>, <tt>route</tt> und <tt>arp</tt> den aktuellen Zustand an. 
Der Befehl horcht auf folgende Syntax:
<pre>
ip [Optionen] Objekt [Kommando [Argumente]]
</pre>
Nicht umsonst ist die  "IP Command Reference" mehr als 60 Seiten dick (<a href="http://linux-ip.net/gl/ip-cref/">
http://linux-ip.net/gl/ip-cref/</a>).

<tt>ip</tt> kann auch komplexe Vorg&auml;nge erledigen, weshalb man beispielsweise auch kein IP-Aliasing mehr 
verwenden muss, um einer Schnittstelle mehrere IP-Adressen zuzuweisen. Statt mit "eth0" eth0:1" zu hantieren 
weisen Sie zwei IP-Adressen an eth0 folgendermaßen zu:
<pre>
ip address add 129.187.206.140/24 dev eth0
ip address add 129.187.206.148/24 dev eth0
</pre>
Man kann auch einen Alias zuweisen, um die Abw&auml;rtskompatibilit&auml;t zu den alten Tools zu erhalten:
<pre>
ip address add 129.187.206.140/24 dev eth0
ip address add 129.187.206.148/24 dev eth0 label eth0:1
</pre>

Es folgt ein Beispiel f&uuml;r die Ausgabe der IP-Adressen mit dem Befehl <tt>ip address show</tt>:
<pre>
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0e:0c:07:e7:72 brd ff:ff:ff:ff:ff:ff
    inet 129.187.206.140/24 brd 129.187.206.255 scope global eth0
    inet 129.187.206.148/24 brd 129.187.206.255 scope global secondary eth0:1
    inet 129.187.206.149/24 brd 129.187.206.255 scope global secondary eth0:2
    inet 129.187.206.152/24 brd 129.187.206.255 scope global secondary eth0:3
    inet 129.187.206.153/24 brd 129.187.206.255 scope global secondary eth0:4
    inet 129.187.206.154/24 brd 129.187.206.255 scope global secondary eth0:5
    inet 129.187.206.156/24 brd 129.187.206.255 scope global secondary eth0:6
    inet 129.187.206.157/24 brd 129.187.206.255 scope global secondary eth0:7
    inet 129.187.206.158/24 brd 129.187.206.255 scope global secondary eth0:8
    inet6 fe80::20e:cff:fe07:e772/64 scope link
       valid_lft forever preferred_lft forever
</pre>
zugewiesene Adressen lassen sich auch ganz einfach l&ouml;schen:
<pre>
ip address del 129.187.206.157/24 dev eth0
ip address del 129.187.206.158/24 dev eth0
</pre>

Zus&auml;tzlich erlaubt es <tt>ip</tt>, den Namen der Netzwerkkarte selbst zu &auml;ndern. Das sollte man 
aber nur bei deaktivierten Karten machen, da unerwartete Effekte auftreten, wenn der Name einer 
aktivierten und benutzten Karte ge&auml;ndert wird. Um »eth0« in »test0« umzubenennen, gen&uuml;gen die 
folgenden Zeilen:
<pre>
ip link set dev eth0 down
ip link set dev eth0 name test0
ip link set dev test0 up
</pre>
<p>
Manchmal sind die Fehlermeldungen von <tt>ip</tt> etwas irref&uuml;hrend, zum Beispiel:
<pre>
ip address add 129.187.206.159/24 dev eth0 label eth0:1
RTNETLINK answers: File exists
</pre>
Die Fehlermeldung bedeutet, dass eine Adresse oder Route zu einer bereits konfigurierten 
Schnittstelle hinzugef&uuml;gt wurde - einen entsprechende Datei gibt es nicht.
<p>
Der Befehl <tt>ip</tt> erlaubt auch fortgeschrittenes Routing wie z. B. Policy-Routing. 
Die Routen k&ouml;nnen mit folgendem Kommando angezeigt werden:
<pre>
ip route show
129.187.206.0/24 dev eth0  proto kernel  scope link  src 129.187.206.140
default via 129.187.206.254 dev eth0
</pre>
Die erste Zeile ist eine Regel, die aussagt, dass alles nach 129.187.206.0 &uuml;ber 129.187.206.140 versandt 
werden muss (das ist ja auch die "Basisadresse" f&uuml;r eth0 im obigen Beispiel).
Die zweite Zeile ist die Regel f&uuml;r die Defaultroute. Der Host 129.187.206.254 stellt dabei den Gateway dar.
<p>
Angelegt werden die Routen mittels <tt>ip route add</tt> und dann der Angabe die praktisch
der Ausgabe von <tt>ip route show</tt> entspricht:
<pre>
ip route add 127.0.0.0/8 dev lo scope link
ip route add 129.187.206.0/24 dev eth0 proto kernel scope link src 129.187.206.140
ip route add default via 129.187.206.254 dev eth0
</pre>
Oft reicht f&uuml;r die zweite Zeile auch schon <tt>ip route add 129.187.206.0/24 dev eth0 scope link</tt>.
Nachfolgend weitere Beispiele, wie Routing mit <tt>ip route</tt> konfiguriert werden kann:
<ul>
<li>Einrichten der Standard-Route auf 129.187.206.254 als Gateway:
<br /><tt>ip route add default via 129.187.206.254 dev eth0</tt>

<li>Schicken der Pakete in das Netz 192.168.150.0 &uuml;ber die zweite Netzwerkschnittstelle eth1:
<br /><tt>ip route add 192.168.150.0/24 dev eth1</tt>

<li>Schicken dder Pakete des Subnetzes 192.168.200.0/24 &uuml;ber ein Gateway:
<br /><tt>ip route add 192.168.200.0/24 via 192.168.150.1</tt>

<li>L&ouml;schen der vorherigen Route aus der Routing-Tabelle:
<br /><tt>ip route del 192.168.200.0/24</tt>
</ul>
<p>


<h4>Offene Ports und Anwendungen finden mit netstat</h4>
Ein offener Port im Status "Listen" ist ein potientielles Einfallstor
f&uuml;r Eindringlinge. Auch Trojaner installieren gerne "Backdoors" und
&ouml;ffnen dazu einen freien Port. Daher ist es sehr zu empfehlen, sich
von Zeit zu Zeit die offenen Ports seiner Systeme anzusehen.
<p>
F&uuml;r eine Kontrolle der offenen Ports ruft man "netstat&nbsp;-nlp" auf.
</p>

<pre>
netstat -npl
Proto Recv-Q Send-Q Local Address        Foreign Address   State   PID/Program name
tcp        0      0 72.139.238.24:80     0.0.0.0:*         LISTEN  25671/apache
tcp        0      0 72.139.238.24:21     0.0.0.0:*         LISTEN  16417/ftpd
tcp        0      0 72.139.238.24:22     0.0.0.0:*         LISTEN  1345/sshd
tcp        0      0 72.139.238.24:25     0.0.0.0:*         LISTEN  26007/exim4
tcp        0      0 72.139.238.24:443    0.0.0.0:*         LISTEN  1022/apache-ssl
</pre>

<p>
Das System zeigt mit diesen Parameter nur Ports im Status "Listen" an.
Zus&auml;tzlich wird in der letzten Spalte die Prozessnummer und der Name
des zust&auml;ndigen D&auml;mons angezeigt. Alternativ kann unter Linux auch das
Kommando "lsof" benutzt werden. Mit dem Aufruf
<pre>
lsof -i | grep -e LISTEN
</pre>
wird ebenfalls eine Liste der Ports im Status "Listen" angezeigt.
<p>

<h4>Einsatz von nmap</h4>
Zur Kontrolle der offenen Ports eines Host &uuml;ber das Netzwerk ben&ouml;tigt
man einen Portscanner, z.B. nmap von Fyodor. Der Portscanner nmap kennt
eine Unmenge von Optionen. F&uuml;r einen ersten Scan nach offenen TCP-Ports
wird lediglich der Parameter "-sT" und die IP-Adresse des Zielsystems
ben&ouml;tigt. Damit scannt nmap alle well know TCP-Ports (1-1024) und alle
Ports aus der Datei etc/services.

<pre>
nmap -sT 192.168.1.1

Starting nmap 3.20 ( www.insecure.org/nmap/ ) at 2004-10-16 23:17 CEST
Interesting ports on Router (192.168.1.1):
(The 1610 ports scanned but not shown below are in state: closed)
Port       State       Service
80/tcp     open        http

Nmap run completed -- 1 IP address (1 host up) scanned in 6.533 seconds
</pre>

Der hier untersuchte IP-Host bietet einen Dienst an: HTTP auf TCP-Port 80.
Auf der Maschine l&auml;uft also h&ouml;chstwarscheinlich ein Webserver. Um alle TCP-Ports
von 1 bis 65535 zu untersuchen ruft man nmap mit den Optionen "-sT -p 1-65535" auf.
Mit der Option "-sU" sucht nmap nach offenen UDP-Ports. UDP-Scanning ist allerdings
oftmals sehr langsam. Ursache hierf&uuml;r ist eine Begrenzung der Anzahl der ICMP-Meldungen
die ein Host pro Zeiteinheit versendet. Viele Systeme begrenzen die ICMP-Meldungen nach
RFC 1812. nmap erkennt dieses Verhalten und arbeitet entsprechen langsamer um keine
Meldungen zu verlieren.
<p>

<h4>tcpdump</h4>
Wenn Probleme in einem Netz auftauchen, so kann mit Hilfe des Programms
"tcpdump" jedes einzelne Paket des Netzes protokolliert und analysiert
werden. Dazu wird die Netzwerkkarte in den <i>promisquous-mode</i>
geschaltet.
"tcpdump" zeigt jetzt die empfangenen Paket-Header an und erm&ouml;glicht so
eine Diagnose der aufgetretenen Fehler. Die Anwendung ist ziemlich
kompliziert und w&uuml;rde den Rahmen dieses Kapitels sprengen. Es gen&uuml;gt, zu
wissen, da&szlig; es dieses Programm gibt und da&szlig; es folgenderma&szlig;en aufgerufen
wird.
<ul><b>tcpdump</b> <tt>-i</tt> <i>Interface</i></ul>
Damit werden alle Pakete des genannten Interfaces abgeh&ouml;rt. Das Interface
wird mit seinem symbolischen Namen angegeben, also beispielsweise
<i>eth0</i>.
<p>
<b>tcpdump</b> hat eine eigene Art Abfragesprache, die Befehle erm&ouml;glicht
wie
<pre>
  tcpdump host blackhole
</pre>
Zeigt nur Pakete an den oder vom Rechner blackhole.
<pre>
  tcpdump host doc and grumpy
</pre>
Zeigt nur Pakete, die zwischen den Rechnern doc und grumpy ausgetauscht werden.
<P>


<H3>Die ARP-Tabelle</H3>
Bei einigen Netzproblemen kann es aufschlu&szlig;reich sein, einen Blick auf
die ARP-Tabelle des Kernels zu werfen oder sie sogar zu ver&auml;ndern.
Die Kommandozeilenoptionen von ARP lauten:
<pre>
arp [-v] [-t hwtype] -a [hostname]
arp [-v] [-t hwtype] -s hostname hwaddr
</pre>
Alle hostname-Argumente k&ouml;nnen als symbolische Hostnamen oder als IP-Adressen angegeben werden.
<p>
Der erste Aufruf gibt den ARP-Eintrag f&uuml;r die angegebene IP-Adresse bzw. Hostnamen aus.
Fehlt <i>hostname</i>, werden Informationen &uuml;ber alle bekannten Hosts ausgegeben.
Zum Beispiel ergibt die Ausgabe von <i>arp</i> auf <i>www.netzmafia.de</i> etwa folgendes:
<pre>
arp
Address                  HWtype  HWaddress           Flags Mask  Iface
129.187.206.254          ether   00:04:DE:FE:78:00   C           eth0
ns.e-technik.fh-muenche  ether   00:07:E9:24:EC:15   C           eth0
proxy1.e-technik.fh-mue  ether   00:07:E9:24:EC:15   C           eth0
web1.e-technik.fh-muenc  ether   00:07:E9:24:EB:F5   C           eth0
</pre>
Die Ausgabe kann mit der <b>-t</b>-Option auch auf bestimmte Hardwaretypen beschr&auml;nkt werden.
Als Argument geben Sie <i>ether</i>, <i>ax25</i> oder <i>pronet</i> an, was f&uuml;r 10 Mbps Ethernet,
AMPR AX.25 und IEEE 802.5 Token Ring steht.
<p>
Die Option <b>-s</b> dient dazu, die Hardwareadresse von <i>hostname</i> manuell in die
ARP-Tabelle einzutragen. Das Argument <i>hwaddr</i> spezifiziert die Hardwareadresse,
die normalerweise als Ethernet-Adresse aus sechs Byte in hexadezimaler Notation angegeben ist.
Sie k&ouml;nnen solche Adressen auch bei anderen Hardwaretypen verwenden, wenn Sie zus&auml;tzlich die
Option <b>-t</b> angeben.
Die Festverdrahtung von Hardwareadressen im ARP-Cache ist eine drastische Ma&szlig;nahme, um Maschinen
aus Ihrem Ethernet daran zu hindern, sich als jemand anderes auszugeben.
<p>
Wenn Sie <i>arp</i> mit der Option <b>-d</b> aufrufen, entfernt es alle Eintr&auml;ge f&uuml;r einen bestimmten
Host. Es kann dazu benutzt werden, das Interface anzuweisen, eine bereits angeforderte Hardwareadresse
einer IP-Adresse nochmals anzufordern, und ist besonders dann n&uuml;tzlich, wenn ein fehlerhaft konfiguriertes
System falsche ARP-Informationen sendet (nat&uuml;rlich mu&szlig; zuerst das fehlerhafte System erneut konfiguriert
werden).
<p>


<CENTER><TABLE BORDER=0 WIDTH="100%">
<TR>
<TD ALIGN=LEFT VALIGN=BOTTOM><IMG SRC="left.gif" BORDER=0> <A HREF="twisted.html">Zum vorhergehenden Abschnitt</A></TD>
<TD ALIGN=CENTER VALIGN=BOTTOM><IMG SRC="up.gif" BORDER=0> <A HREF="index.html">Zum Inhaltsverzeichnis</A></TD>
<TD ALIGN=RIGHT VALIGN=BOTTOM><IMG SRC="right.gif" BORDER=0> <A HREF="netz9.html">Zum n&auml;chsten Abschnitt</A></TD>
</TR></TABLE></CENTER>
<P><HR>
<h6><i>Copyright &copy; Hochschule M&uuml;nchen, FK 04, Prof. J&uuml;rgen Plate</i><br>
Letzte Aktualisierung: <SCRIPT LANGUAGE="JavaScript">document.write(document.lastModified);</SCRIPT></I></H6>
</BODY>
</HTML>