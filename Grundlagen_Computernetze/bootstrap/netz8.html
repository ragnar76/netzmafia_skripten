<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta NAME="robots" CONTENT="all">
<meta NAME="revisit-after" CONTENT="10 days">
<meta NAME="Reply-To" CONTENT="webmaster@netzmafia.de">

<meta NAME="keywords" CONTENT="LAN WAN TCP/IP Computernetze Ethernet Vernetzung Router Hub Switch Protokolle">
<meta NAME="description" CONTENT="Praxisorientierte Einführung in den Aufbau und die Funktionsweise von Computernetzen.">
<title>Grundlagen Computernetze</title>
</head>
<BODY TEXT="#000000" BGCOLOR="#FFFFFF" LINK="#0000FF" ALINK="#FF0000" VLINK="#FF00FF">
<CENTER><TABLE BORDER=0 WIDTH="90%" >
<TR><TD ALIGN=LEFT><img src="images/eyes.png"></TD>
<TD ALIGN=RIGHT><H3>Grundlagen Computernetze</H3>
<BR><B><I>Prof. Jürgen Plate</I></B></TD></TR>
</TABLE></CENTER>
<HR>

<A NAME="8.1"></A>
<h1 align=center>TCP/IP</h1>

Die Protokolle der TCP/IP-Familie wurden in den 70-er Jahren für den
Datenaustausch in heterogenen Rechnernetzen (d. h. Rechner verschiedener
Hersteller mit unterschiedlichen Betriebssystemen) entwickelt. TCP steht
für 'Transmission Control Protocol' (Schicht 4) und IP für 'Internet
Protocol' (Schicht 3).  Die Protokollspezifikationen sind in sogenannten
RFC-Dokumenten (RFC - Request for Comment) festgeschrieben und veröffentlicht.
Aufgrund ihrer Durchsetzung stellen sie Quasi-Standards dar.
<P>
<CENTER><img src="images/tcpipiso.png"></CENTER>
<P>
Die Schichten 5 - 7 des OSI-Standards werden hier in einer Anwendungsschicht
zusammengefaßt, da die Anwendungsprogramme alle direkt mit der
Transportschicht kommunizieren.
<P>
In Schicht 4 befindet sich außer TCP, welches gesicherten Datentransport
(<B>verbindungsorientiert</B>, mit Flußkontrolle (d. h.
Empfangsbestätigung, etc.)  durch Windowing ermöglicht,
auch UDP (User Datagram Protocol), in welchem verbindungsloser und ungesicherter
Transport festgelegt ist. Beide Protokolle erlauben durch die Einführung
von sogenannten Ports den Zugriff mehrerer Anwendungsprogramme gleichzeitig
auf ein- und dieselbe Maschine.
<P>
In Schicht 3 ist das <B>verbindungslose</B> Internet-Protokoll (IP) angesiedelt.
Datenpakete werden auf den Weg geschickt, ohne daß auf eine
Empfangsbestätigung gewartet werden muß. IP-Pakete dürfen unter
bestimmten Bedingungen (TTL=0, siehe unten) sogar vernichtet werden.
In Schicht 3 werden damit auch die IP-Adressen festgelegt. Hier findet auch das Routing,
das heißt die Wegsteuerung eines Paketes von einem Netz ins andere
statt. Ebenfalls in diese Ebene integriert sind die ARP-Protokolle (ARP
- Address Resolution Protocol), die zur Auflösung (= Umwandlung) einer
logischen IP-Adresse in eine physikalische (z. B. Ethernet-) Adresse dienen
und dazu sogenannte Broadcasts (Datenpakete, durch die alle angeschloßenen
Stationen angesprochen werden) verwenden. ICMP, ein Protokoll, welches den
Austausch von Kontroll- und Fehlerpaketen im Netz ermöglicht, ist ebenfalls
in dieser Schicht realisiert. <BR>
<P>
Die Schichten 1 und 2 sind gegenüber Schicht 3 protokolltransparent.
 Sie können durch standardisierte Protokolle (z. B. Ethernet (CSMA/CD),
FDDI, SLIP (Serial Line IP), PPP (Point-to-Point Protocol)) oder andere
Übertragungsverfahren realisiert werden.
<P>
<CENTER><img src="images/tcpstac.png"></CENTER>
<P>
Zur TCP/IP-Familie gehören mehrere Dienstprogramme der höheren
OSI-Schichten (5 - 7), z. B.: <BR>
<UL>
<LI>Telnet (RFC 854)<BR>
Ein virtuelles Terminal-Protokoll, um vom eigenen Rechensystem einen interaktiven
Zugang zu einem anderen System zu realisieren. <BR>
<LI>FTP (RFC 959)<BR>
Dieses (File-Transfer-) Protokoll ermöglicht, die Dateidienste eines
Fremdsystems interaktiv zu benutzen sowie die Dateien zwischen den Systemen
hin und her zu kopieren. <BR>
<LI>NFS (RFC 1094)<BR>
Das Network File System ermöglicht den Zugriff auf Dateien an einem
entfernten System so, als wären sie auf dem eigenen.  Man nennt dies
auch einen transparenten Dateizugriff.  NFS basiert auf den zur TCP/IP-Familie
gehörenden UDP- (User- Datagramm-) Protokollen (ebenfalls Schicht 4),
RFC 768. Im Unterschied zu TCP baut UDP keine gesicherten virtuellen Verbindungen
zwischen kommunizierenden Hosts auf. Aufgrund dieser Eigenschaft ist es
für den Einsatz in lokalen Netzen vorgesehen. <BR>
<LI>NNTP (RFC 977)<BR>
Das Network News Transfer Protocol spezifiziert Verteilung, Abfrage, Wiederauffinden
und das Absetzen von  News-Artikeln innerhalb eines Teils oder der gesamten
Internet-Gemeinschaft. Die Artikel werden in regional zentralen Datenbasen
gehalten. Einem Benutzer ist es möglich, aus dem gesamten Angebot nur
einzelne Themen zu abonnieren. <BR>
<LI>SMTP (RFC 821/822)<BR>
Das Simple-Mail-Transfer-Protokoll (RFC 821) ist ein auf der IP-Adressierung
sowie auf der durch den RFC 822 festgelegten Namensstruktur basierendes
Mail-Protokoll. <BR>
<LI>DNS (RFC 920)<BR>
Der Domain Name Service unterstützt die Zuordnung von Netz- und Host-Adressen
zu Rechnernamen. Dieser Service ist z. B. erforderlich für die Anwendung
von SMTP sowie in zunehmendem Maße auch für Telnet und FTP.
Aus Sicherheitsgründen wendet sich der fremde Host an den DNS, um zu
prüfen, ob der IP-Adresse des ihn rufenden Rechners auch ein (Domain-)Name
zugeordnet werden kann.  Falls nicht, wird der Verbindungsaufbau abgelehnt.
</UL>
<P>

<H2><A NAME="8.1">Die TCP/IP-Protokolle</A></H2>
Der große Vorteil der TCP/IP-Protokollfamilie ist die einfache Realisierung
von Netzwerkverbunden. Einzelne Lokale Netze werden über Router oder
Gateways verbunden. Einzelne Hosts können daher über mehrere Teilnetze
hinweg miteinander kommunizieren.<BR>
IP als Protokoll der Ebene 3 ist die unterste Ebene, die darunter liegenden
Netzebenen können sehr unterschiedlich sein:
<UL>
<LI>LANs (Ethernet, Token-Ring, usw.)<BR>
<LI>WANs (X.25, usw.)<BR>
<LI>Punkt-zu-Punkt-Verbindungen (SLIP, PPP)<BR>
</UL>
<P>
<table border=1 CELLPADDING=3>
<tr>
   <th colspan="9">Internet-Protokolle</th>
</tr><tr>
   <td align="center" colspan="2" width="16%"><small><i>OSI-Schicht</i></small></td>
   <td align="center" colspan="6" width="72%"><small><i>Internet Protokoll Suite</i></small></td>
   <td align="center" width="12%"><small><i>DOD Schicht</i></small></td>
</tr><tr>
   <td align="center" width="4%"><small>7</small></td>
   <td align="center" width="12%"><small>Anwendung</small></td>
   <td align="center" width="12%"><small>File Transfer</small></td>
   <td align="center" width="12%"><small>Electronic<BR>Mail</small></td>
   <td align="center" width="12%"><small>Terminal Emulation</small></td>
   <td align="center" width="12%"><small>Usenet News</small></td>
   <td align="center" width="12%"><small>World Wide Web</small></td>
   <td align="center" width="12%"><small>Domain Name Service</small></td>
   <td align="center" width="12%"><small>Art der<BR>Kommuni-<BR>kation</small></td>
</tr><tr>
   <td align="center"><small>6</small></td>
   <td align="center"><small>Darstellung</small></td>
   <td align="center" rowspan="2"><small>File Transfer Protocol (FTP)<br>RFC 959</small></td>
   <td align="center" rowspan="2"><small>Simple Mail Transfer Protocol (SMTP)<br>RFC 821</small></td>
   <td align="center" rowspan="2"><small>Telnet Protocol (Telnet)<br>RFC 854</small></td>
   <td align="center" rowspan="2"><small>Usenet News Transfer Protocol (NNTP)<br>RFC 977</small></td>
   <td align="center" rowspan="2"><small>Hypertext Transfer Protocol (HTTP)<br>RFC 2616</small></td>
   <td align="center" rowspan="2"><small>Domain Name Service (DNS)<br>RFC 1034</small></td>
   <td align="center" rowspan="2"><small>Applikation</small></td>
</tr><tr>
   <td align="center"><small>5</small></td>
   <td align="center"><small>Sitzung</small></td>
</tr><tr>
   <td align="center"><small>4</small></td>
   <td align="center"><small>Transport</small></td>
   <td align="center" colspan="5"><small>Transmission Control Protocol (TCP)<br>RFC 793</small></td>
   <td align="center"><small>User Datagram Protocol (UDP)<br>RFC 768</small></td>
   <td align="center"><small>Host to Host Kommunikation</small></td>
</tr><tr>
   <td align="center"><small>3</small></td>
   <td align="center"><small>Netzwerk</small></td>
   <td align="center"><small>Address Resolution Protocol (ARP)<br>RFC 826</small></td>
   <td align="center" colspan="4"><small>Internet Protocol (IP)<br>RFC 791</small></td>
   <td align="center"><small>Internet Control Messsage Protocol<br>RFC 792</small></td>
   <td align="center"><small>Internet</small></td>
</tr><tr>
   <td align="center"><small>2</small></td>
   <td align="center"><small>Sicherung</small></td>
   <td align="center" colspan="2"><small>Ethernet</small></td>
   <td align="center"><small>Token Ring</small></td>
   <td align="center"><small>DQDB</small></td>
   <td align="center"><small>FDDI</small></td>
   <td align="center"><small>ATM</small></td>
   <td align="center"><small>lokales Netzwerk</small></td>
</tr><tr>
   <td align="center"><small>1</small></td>
   <td align="center"><small>Physikalische Übertragung</small></td>
   <td align="center"><small>Twisted Pair</small></td>
   <td align="center"><small>Lichtwellenleiter</small></td>
   <td align="center" colspan="2"><small>Coaxkabel</small></td>
   <td align="center"><small>Funk</small></td>
   <td align="center"><small>Laser</small></td>
   <td align="center"><small>Netzzugriff</small></td>
</tr></table>
<P>
Es ist offensichtlich, daß die Gateways neben dem Routing weitere
nichttriviale Funktionen haben, wenn sie zwischen den unterschiedlichsten
Teilnetzen vermitteln (z. B. unterschiedliche Protokolle auf Ebene 2, unterschiedliche
Datenpaketgröße, usw.).<BR>
<P>
Aus diesem Grund existieren in einem Internet drei unabhängige Namens-
bzw. Adressierungsebenen:
<UL>
<LI>Physikalische Adressen (z. B. Ethernet-Adresse)<BR>
<LI>Internet-Adressen (Internet-Nummer, IP-Adresse)<BR>
<LI>Domain-Namen<BR>
</UL>
<P>
Die Ethernet-Adresse wurde bereits behandelt, auf die anderen beiden Ebenen
wird in den folgenden Abschnitten eingegangen. Die Umsetzung der höchsten
Ebene (Domain-Namen) in IP-Adressen erfolgt durch das oben erwähnte
DNS, worauf die Dienstprogramme der Schichten 5-7 zurückgreifen.
<P>

<H2><A NAME="8.2">ARP</A></H2>
Die Umsetzung einer IP-Adresse in eine Hardware-Adresse erfolgt durch
Tabellen und auf Hardware-Ebene (z. B. Ethernet) automatisch über
ARP (Adress Resolution Protocol). Dazu ein Beispiel:
<P>
Die Station A will Daten an eine Station B mit der Internetadresse I(B)
senden, deren physikalische Adresse P(B) sie noch nicht kennt. Sie sendet
einem ARP-Request an alle Stationen im Netz, der die eigene physikalische
Adresse und die IP-Adresse von B enthält.
<P>
<CENTER><img src="images/arp1.png"></CENTER>
<P>
Alle Stationen erhalten und überprüfen den ARP-Request und die
angesprochene Station B antwortet, indem sie einen ARP-Reply mit ihrer
eigenen physikalischen Adresse an die Station A sendet. Letztere speichert
die Zuordnung in einer Tabelle (Address Resolution Cache).
<P>
<CENTER><img src="images/arp2.png"></CENTER>
<P>
Auch für die Umkehrfunktion gibt es eine standardisierte Vorgehensweise,
den RARP (Reverse ARP). Hier sendet die Station A unter Angabe ihrer physikalischen
Adresse P(A) einen RARP-Request. Wenn im Netz nur eine Station als RARP-Server
eingerichtet ist (eine Station, die alle Zuordnungen von P(x) &lt;--&gt;
I(x) "kennt"), antwortet diese mit einem RARP-Reply an die anfragende
Station, der I(A) enthält. Diese Funktion ist z. B. für sogenannte
"Diskless Workstations" wichtig, die ihre gesamte Software von
einem Server laden.<BR>
<P>
<center><img src="images/arp.png" ALT=""></center>
<P>
ARP ist für den Benutzer unsichtbar, so dass das Vorhandensein dieses Protokolls  
meist nur bemerkt wird, wenn seltene Fehler auftreten. Die Dauer der Gültigkeit 
eines ARP-Eintrags (normalerweise wenige Minuten) kann ein Problem darstellen,  
wenn falsche Einträge vorhanden sind. Solange ein fehlerhafter Eintrag existiert, 
kann mit dem betreffenden Host nicht kommuniziert werden. Die Fehlfunktion wird 
häufig nicht dem ARP-Protokoll zugeschrieben, sondern dem Netz oder einem Fehler 
in der Netzwerkimplementierung. Darüber hinaus ermöglicht nicht jedes 
Betriebssystem das Erzeugen eines korrigierten Eintrags oder einer Anforderung.
Mit ARP-Spoofing ist es möglich, absichtlich eine falsche Hardwareadresse in 
einem Netz zu verteilen. Dadurch kann der Datenverkehr für einen Rechner auf 
einen anderen umgelenkt und eventuell von diesem sogar verändert werden.
<P>
<h4>Proxy ARP</h4>
Proxy ARP erlaubt es einem Router, ARP-Anforderungen für Hosts zu beantworten.
Die Hosts befinden sich dabei in durch einen Router getrennten Netzen, verwenden 
jedoch den gleichen IP-Adressenbereich. Bei der Kommunikation ist für die Hosts 
der Router <i>transparent</i>, das heißt, er braucht nicht speziell angesprochen 
zu werden, sondern die Hosts können wie gewöhnlich Pakete über verschiedene Netze 
hinweg versenden.
<p>
Sendet Computer 1 eine ARP-Anforderung an Computer 2, reagiert der dazwischen 
liegende Router anstelle des Computers 2 mit einer ARP-Antwort und der MAC-Adresse
des Ports am Router, auf dem die Anfrage empfangen wurde. Der anfragende Computer 1 
sendet dann seine Daten an den Router, der sie dann an Computer 2 weiterleitet.
<P>

<h4>Gratuitous ARP</h4>
Gratuitous ARP (engl. "unaufgefordertes ARP") bezeichnet eine spezielle 
Verwendung von ARP. Dabei sendet ein Host ein ARP-Anforderungs-Broadcast, bei dem 
er seine eigene IP-Adresse als Quell- und Ziel-IP-Adresse einträgt. Damit teilt 
er seine ggf. neue MAC-Adresse unaufgefordert mit. Das kann mehreren Zwecken dienen:
<P>
<ul>
<li>Normalerweise darf keine Antwort kommen, denn eine IP-Adresse muss in einem 
Netz eindeutig sein. Bekommt er trotzdem eine Antwort, ist das für den Administrator 
ein Hinweis darauf, dass ein Host nicht richtig konfiguriert ist.</li>
<li>Jeder Host aktualisiert seinen ARP-Cache. Das ist beispielsweise dann nützlich, 
wenn die Netzwerkkarte eines Rechners ausgetauscht wurde und die anderen Hosts 
über die neue MAC-Adresse informiert werden sollen. Gratuitous ARP geschieht deshalb 
normalerweise beim Booten eines Computers.</li>
<li>Wenn zwei Server aus Gründen der Ausfallsicherheit als Server und Ersatzserver 
aufgebaut sind (Hochverfügbarkeit, HA-Server) und sich daher eine IP-Adresse teilen.
Wird der aktive Verkehr vom einem auf den anderen Server umgeschaltet, ist 
die IP-Adresse über eine andere MAC-Adresse erreichbar. Diese neue MAC-IP-Adresskombination
muss bekannt gemacht werden. Sonst bekommt niemand den Wechsel mit.</li>
<li>In einem Mobile IP-Szenario sendet der <i>Home Agent</i> einen <i>Gratuitous ARP</i>, 
wenn sich der <i>Mobile Host</i> aus dem Heimatnetz entfernt, um die Pakete stellvertretend 
für diesen zu empfangen. Analog sendet der <i>Mobile Host</i> einen <i>Gratuitous ARP</i>, 
sobald er sich wieder im Netz befindet.</li>
</ul>
<P>

<H2><A NAME="8.3">IP - Internet Protocol</A></H2>
Auf der Netzwerkschicht aufbauend liegt die Internet-Schicht, die die erste
Abstraktionsschicht vom Transportmechanismus darstellt. Auf dieser Schicht 3 stellt
das Internet-Protokoll (IP) den grundlegenden Netzdienst zur Verfügung,
den Versand von Datenpaketen, sogenannten Datagrammen, über verschiedene Netze
hinweg. Die Netzwerkschicht hat keine Information darüber, von welcher Art
die Daten sind, die sie befördert. Nehmen wir als Beispiel das Ethernet:
Von der Ethernet-Karte werden die vom Netz kommenden Daten an die Treibersoftware
für die Karte weitergereicht. Diese interpretiert einen Teil dieser Daten als
IP-Header und den Rest als Datenteil eines IP-Paketes. Auf diese Weise ist der
IP-Header innerhalb eines Ethernet-Paketes eingekapselt. Aber auch das IP-Paket
selbst enthält wieder ein Datenpaket für eine höhere Protokollebene
(TCP), dessen Header auf der IP-Ebene als Bestandteil der Daten erscheint. Man kann
sich das so vorstellen, wie die russischen Puppen, die ineinandergeschachtelt sind.
Die kleinste Puppe ganz innen repräsentiert die Nutzdaten, alle außen herum
geschachtelten Puppen sind 'Protokoll-Verpackung'.
<P>
<center><img src="images/schichten.png"></center>
<P>
IP ist ein <B>verbindungsloses Protokoll</B>. Es ist also nicht notwendig, eine
IP-Verbindung zu einem Rechner zu 'öffnen', bevor man Daten zu diesem Rechner
senden kann, sondern es genügt, das IP-Paket einfach abzusenden und darauf zu
vertrauen, daß es schon ankommen wird. Bei einem verbindungsorientierten
Protokoll wird beim Öffnen einer Verbindung getestet, ob der Zielrechner
überhaupt erreichbar ist. Ein verbindungsloses Protokoll macht das nicht und
kann demnach auch nicht garantieren, daß ein Datenpaket überhaupt beim
Empfänger ankommt. IP garantiert auch nicht, daß von einem einmal
abgeschickten Datenpaket nur eine Kopie beim Empfänger ankommt oder daß
in einer bestimmten Reihenfolge abgeschickte Datenpakete auch wieder in dieser
Reihenfolge empfangen werden.<BR>
Normalerweise laufen die IP-Pakete über mehrere Zwischenstationen, bis sie
am Zielrechner ankommen. Bricht irgendwann während der Übertragung ein
Übertragungsweg zusammen, so wird ein neuer Weg zum Ziel gesucht und benutzt.
Da der neue Weg zeitlich länger oder kürzer sein kann als der alte, kann
man keine allgemeingültigen Aussagen darüber machen, in welcher Reihenfolge
IP-Pakete beim Empfänger eintreffen. Es kann auch sein, daß bei dieser
Umschalterei IP-Pakete verlorengehen oder sich verdoppeln. Das Beheben der so
entstehenden Probleme überläßt das IP-Protokoll anderen,
höherliegenden Schichten.
<P>
Das Internet-Protokoll ist somit ein <B>verbindungsloser</B> Dienst
mit einem 'Unreliable Datagram Service', d. h. es wird auf der IP-Ebene
weder die Richtigkeit der der Daten noch die Einhaltung von Sequenz, Vollständigkeit
und Eindeutigkeit der Datagramme überprüft. Ein zuverlässiger
verbindungsorientierter Dienst wird in der darüberliegenden TCP-Ebene
realisiert.
<P>
Ein IP-Datagramm besteht aus einem Header und einem nachfolgenden Datenblock,
der seinerseits dann z. B. in einem Ethernet-Frame "verpackt"
wird. Die maximale Datenlänge wird auf die maximale Rahmenlänge
des physikalischen Netzes abgestimmt. Da nicht ausgeschlossen werden kann,
daß ein Datagramm auf seinem Weg ein Teilnetz passieren muß,
dessen Rahmenlänge niedriger ist, müssen zum Weitertransport mehrere
(Teil-)Datagramme erzeugt werden. Dazu wird der Header im Wesentlichen repliziert
und die Daten in kleinere Blöcke unterteilt. Jedes Teil-Datagramm hat
also wieder einen Header. Diesen Vorgang nennt man Fragmentierung. Es handelt
sich um eine rein netztechnische Maßnahme, von der Quell- und Zielknoten
nichts wissen müssen. Es gibt natürlich auch eine umgekehrte Funktion,
"Reassembly", die kleine Datagramme wieder zu einem größeren
packt. Geht auf dem Übertragungsweg nur ein Fragment verloren, muß
das gesamte Datagramm wiederholt werden. Es gilt die Empfehlung, daß
Datagramme bis zu einer Länge von 576 Bytes unfragmentiert übertragen
werden sollten.<BR>
<P>

<H4>Format des IP-Headers</H4>
<P>
<center><img src="images/ip.png" ALT=""></center>
<P>
<DL>
<DT>Version
<DD>Kennzeichnet die IP-Protokollversion

<DT>IHL (Internet Header Length)
<DD>Die Angabe der Länge des IP-Headers erfolgt
in 32-Bit-Worten (normalerweise 5). Da die Optionen nicht unbedingt auf
Wortlänge enden, wird der Header gegebenenfalls aufgefüllt.

<DT>Type of Service
<DD>Alle Bits haben nur "empfehlenden" Charakter. 'Precedence' bietet
die Möglichkeit, Steuerinformationen vorrangig zu befördern.

<DT>Total Length
<DD>Gesamtlänge des Datagramms in Bytes (max. 64 KByte).

<DT>Identification
<DD>Dieses und die beiden folgenden Felder steuern die Reassembly. Eindeutige
Kennung eines Datagramms. Anhand dieses Feldes und der 'Source Address'
ist die Zusammengehörigkeit von Fragmenten zu detektieren.

<DT>Flags
<DD>Die beiden niederwertigen Bits haben folgende Bedeutung:
<UL>
<LI>Don't fragment: Für Hosts, die keine Fragmentierung unterstützen
<LI>More fragments: Zum Erkennen, ob alle Fragmente eines Datagramms empfangen wurden
</UL>

<DT>Fragment Offset
<DD>Die Daten-Bytes eines Datagramms werden numeriert und auf die Fragmente
verteilt. Das erst Fragment hat Offset 0, für alle weiteren erhöht
sich der Wert um die Länge des Datenfeldes eines Fragments. Anhand
dieses Wertes kann der Empfänger feststellen, ob Fragmente fehlen.
Beispiel siehe unten.

<DT>Time-to-live (TTL)
<DD>Jedes Datagramm hat eine vorgegebene maximale Lebensdauer, die hier angegeben
wird. Auch bei Routing-Fehlern (z. B. Schleifen) wird das Datagramm irgendwann
aus dem Netz entfernt. Da Zeitmessung im Netz problematisch ist, und keine
Startzeit im Header vermerkt ist, decrementiert jeder Gateway dieses Feld
--&gt; de-facto ein 'Hop Count'.

<DT>Protocol
<DD>Da sich unterschiedliche Protokolle auf IP stützen, muß das übergeordnete
Protokoll (ULP, Upper Layer Protocol) angegeben werden. Wichtige ULPs sind
<UL>
<LI>1:   ICMP Internet Control Message P.
<LI>3:   GGP  Gateway-to-Gateway P.
<LI>6:   TCP  Transmission Control P.
<LI>8:   EGP  Exterior Gateway P.
<LI>17:   UDP  User Datagram P.
</UL>

<DT>Header Checksum
<DD>16-Bit-Längsparität über den IP-Header (nicht die Daten)

<DT>Source Address
<DD>Internet-Adresse der Quellstation

<DT>Destinantion Address
<DD>Internet-Adresse der Zielstation

<DT>Options
<DD>Optionales Feld für weitere Informationen (deshalb gibt es auch die
Header-Länge). Viele Codes sind für zukünftige Erweiterungen
vorgesehen. Die Optionen dienen vor allem der Netzsteuerung, der Fehlersuche
und für Messungen. Die wichtigsten sind:
<UL>
<LI>Record Route: Weg des Datagramms mitprotokollieren
<LI>Loose Source Routing: Die sendende Station schreibt einige Zwischenstationen
vor (aber nicht alle)
<LI>Strict Source Routing: Die sendende Station schreibt alle Zwischenstationen
vor.
<LI>Timestamp Option: Statt seiner IP-Adresse (wie bei Record Route) trägt
jeder Gateway den Bearbeitungszeitpunkt ein (Universal Time).
</UL>

<DT>Padding
<DD>Füllbits
</DL>
<P>
Die Hauptaufgabe von IP ist es also, die Unterschiede zwischen den verschiedenen,
darunterliegenden Netzwerkschichten zu verbergen und eine einheitliche Sicht auf die
verschiedensten Netztechniken zu präsentieren. So gibt es IP nicht nur in Netzen,
sondern auch als SLIP (Serial Line IP) oder PPP (Point to Point Protocol) für
Modem- oder ISDN-Verbindungen. Zur Vereinheitlichung gehören auch die
Einführung eines einheitlichen Adressierungsschemas und eines
Fragmentierungsmechanismus, der es ermöglicht, große
Datenpakete durch Netze mit kleiner maximaler Paketgröße
zu senden: Normalerweise existiert bei allen Netzwerken eine maximale
Größe für ein Datenpaket. Im IP-Jargon nennt man
diese Grenze die 'Maximum Transmisson Unit' (MTU). Natürlich ist
diese Obergrenze je nach verwendeter Hardware bzw. Übertragungstechnik
unterschiedlich. Die Internet-Schicht teilt IP-Pakete, die größer
als die MTU des verwendeten Netzwerks sind, in kleinere Stücke,
sogenannte Fragmente, auf. Der Zielrechner setzt diese Fragmente dann wieder zu
vollständigen IP-Paketen zusammen, bevor er sie an die darüberliegenden
Schichten weitergibt. Der Fragement Offset gibt an, an welcher Stelle in Bezug auf
den IP-Datagramm-Anfang das Paket in das Datagramm einzuordnen ist. Aufgrund des
Offset werden die Pakete in die richtige Reihenfolge gebracht. Dazu ein Beispiel:
<P>
Es soll ein <B>TCP</B>-Paket mit einer Länge von 250 Byte über
<B>IP</B> versandt werden. Es wird angenommen, daß ein IP-Header eine Länge von
20 Byte hat und eine maximale Länge von 128 Byte pro Paket nicht überschritten
werden darf Der Identifikator des Datagramms beträgt 43 und der Fragmentabstand wird
in 8-Byte-Schritten gezählt. Das Datenfragment muß also durch 8 dividierbar
sein.
<P>
<CENTER><img src="images/fragment.png"></CENTER>
<P>
Da alle Fragmente demselben Datagramm angehören, wird der Identifikator für alle
Fragmente beibehalten. Im ersten Fragment ist das Fragment Offset natürlich noch
Null, das MF-Bit jedoch auf 1 gesetzt, um zu zeigen, daß noch Fragmente
folgen. Im IP-Header des zweiten Fragments beträgt das Fragment Offset 13
(104/8 = 13) und zeigt die Position des Fragments im Datagramm an. Das MF-Bit ist
noch immer 1, da noch ein Datenpaket folgt. Der Header des dritten Fragments
enthält dann ein MF-Bit mit dem Wert 0, denn es handelt sich um das letzte
Datenpaket zum Datagramm 43. Das Fragment Offset ist auf 26 gesetzt, da vorher schon
208 Daten-Bytes (8 * 26 = 208) übertragen wurden.<BR>
Sobald das erste Fragment (gleich welches) im Empfänger ankommt,
wird ein Timer gesetzt. Sind innerhalb der dort gesetzten Zeit nicht alle Pakete zu einem
Datagramm eingetroffen, wird angenommen, daß Fragmente verlorengingen. Der
Empfänger verwirft dann alle Datenpakete mit diesem Identifikator.
<P>
Was geschieht aber, wenn der Kommunikationspartner nicht erreichbar ist? Wie schon
erwähnt, durchläuft ein Datagramm mehrere Stationen. Diese Stationen sind in
der Regel Router oder Rechner, die gleichzeitig als Router arbeiten. Ohne
Gegenmaßnahme würde das Datenpaket für alle Zeiten durch das Netze
der Netze irren. Dazu gibt es im IP-Header neben anderer Verwaltungsinfo auch ein
Feld mit dem Namen TTL (Time To Live). Der Wert von TTL kann zwischen 0 und 255
liegen. Jeder Router, der das Datagramm transportiert, vermindert den Wert dieses
Feldes um 1. Ist der Wert von TTL bei Null angelangt, wird das Datagramm vernichtet.
<P>
Die Adressen, die im Internet verwendet werden, bestehen aus einer 32 Bit langen Zahl.
Damit sich die Zahl leichter darstellen läßt, unterteilt man sie in 4 Bytes
(zu je 8 Bit). Diese Bytes werden dezimal notiert und durch Punkte getrennt (a.b.c.d).
Zum Beispiel:
<pre>
    141.84.101.2
    129.187.10.25
</pre>
Bei dieser Adresse werden zwei Teile unterscheiden, die Netzwerkadresse und die
Rechneradresse, wobei unterschiedlich viele Bytes für beide Adressen verwendet
werden:<br>
Die Bereiche für die Netzwerkadresse ergeben sich durch die Zuordnung der
ersten Bits der ersten Zahl (a), die eine Erkennung der Netz-Klassen
möglich machen.
<p>
<H4>Netzklassen</H4>
<P>
<CENTER><img src="images/netzklassen.png"></CENTER>
<P>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADDING=4>
<TR><TD VALIGN="TOP" >&nbsp;</TD>
<TD VALIGN="TOP" ><b>Klasse A</b> - Netz</TD>
<TD VALIGN="TOP" ><b>Klasse B</b> - Netz</TD>
<TD VALIGN="TOP" ><b>Klasse C</b> - Netz</TD>
</TR>
<TR><TD VALIGN="TOP" >Netz-ID</TD>
<TD VALIGN="TOP">8 Bit = 1 Byte</TD>
<TD VALIGN="TOP">16 Bit = 2 Byte</TD>
<TD VALIGN="TOP">24 Bit = 3 Byte</TD>
</TR>
<TR><TD VALIGN="TOP" >Host-ID</TD>
<TD VALIGN="TOP">24 Bit = 3 Byte</TD>
<TD VALIGN="TOP">16 Bit = 2 Byte</TD>
<TD VALIGN="TOP">8 Bit = 1 Byte</TD>
</TR>
<TR><TD VALIGN="TOP" >Netzmaske</TD>
<TD VALIGN="TOP">255.0.0.0</TD>
<TD VALIGN="TOP">255.255.0.0</TD>
<TD VALIGN="TOP">255.255.255.0</TD>
</TR>
<TR><TD VALIGN="TOP" >Adressklassen-ID<BR>
(= Feste Bits im 1. Byte, 1. Quad)</TD>
<TD VALIGN="TOP">0</TD>
<TD VALIGN="TOP">10</TD>
<TD VALIGN="TOP">110</TD>
</TR>
<TR><TD VALIGN="TOP" >Wertebereich (theoretisch)</TD>
<TD VALIGN="TOP">0.0.0.0 bis 127.255.255.255</TD>
<TD VALIGN="TOP">128.0.0.0 bis 191.255.255.255</TD>
<TD VALIGN="TOP">192.0.0.0 bis 223.255.255.255</TD>
</TR>
<TR><TD VALIGN="TOP" >Anzahl der Netze</TD>
<TD VALIGN="TOP">128 (= 2<B><SUP>7</B></SUP>)</TD>
<TD VALIGN="TOP">16384 (= 2<B><SUP>6</B></SUP>*256 <BR>= 64*256)</TD>
<TD VALIGN="TOP">2097152 (= 2<B><SUP>5</B></SUP>*256*256 <BR>= 32*256*256)</TD>
</TR>
<TR><TD VALIGN="TOP" >Anzahl der Rechner <BR>im Netz</TD>
<TD VALIGN="TOP">16777216 (= 256<B><SUP>3</B></SUP>)</TD>
<TD VALIGN="TOP">65536 (= 256<B><SUP>2</B></SUP>)</TD>
<TD VALIGN="TOP">256 (= 256<B><SUP>1</B></SUP>)</TD>
</TR>
</TABLE>
<p>

<H4>Besondere Adreßklassen</H4>
<P>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADDING=4>
<TR><TD VALIGN="TOP" >&nbsp;</TD>
<TD VALIGN="TOP" ><B>Klasse D</B></TD>
<TD VALIGN="TOP" ><B>Klasse E</B></TD>
</TR>
<TR><TD VALIGN="TOP" >Adressklassen-ID</TD>
<TD VALIGN="TOP">4 Bit = "1110"</TD>
<TD VALIGN="TOP">5 Bit = "11110"</TD>
</TR>
<TR><TD VALIGN="TOP" >keine Netz-ID, sondern:</TD>
<TD VALIGN="TOP">28 Bit-Identifikator</TD>
<TD VALIGN="TOP">27 Bit-Identifikator</TD>
</TR>
<TR><TD VALIGN="TOP" >Wertebereich</TD>
<TD VALIGN="TOP">224.0.0.0 bis 239.255.255.255</TD>
<TD VALIGN="TOP">240.0.0.0 bis 247.255.255.255</TD>
</TR>
<TR><TD VALIGN="TOP" >Anwendungen</TD>
<TD VALIGN="TOP">für Multicast-Gruppen</TD>
<TD VALIGN="TOP">reservierte Adressen für Zukünftiges</TD>
</TR>
</TABLE>
<p>
Grundsätzlich gilt:
<UL>
<LI>Alle Rechner mit der gleichen Netzwerkadresse gehören zu einem
Netz und sind untereinander erreichbar.
<LI>Zur Koppelung von Netzen unterschiedlicher Adresse wird eine spezielle Hardware-
oder Softwarekomponente, ein sogenannter Router, benötigt.
<LI>Je nach Zahl der zu koppelnden Rechner wird die Netzwerkklasse gewählt.
</UL>
In einem Netz der Klasse C können z. B. 254 verschiedene Rechner gekoppelt
werden (Rechneradresse 1 bis 254). Die Hostadresse 0 wird für die Identifikation
des Netzes benötigt und die Adresse 255 für Broadcast-(Rundruf-)Meldungen.
<P>
<CENTER><img src="images/aufteilung.png"></CENTER>
<P>
<UL>
<LI>Die Netzwerkadresse 127.0.0.1 bezeichnet jeweils den lokalen Rechner (loopback address).
Sie dient der Konsistenz der Netzwerksoftware (jeder Rechner ist über
seine Adresse ansprechbar) und dem Test (eigentlich wird hier ein ganzes C-Netz
belegt, nämlich 127.0.0.x).
</UL>
<P>
Damit man nun lokale Netze ohne Internetanbindung mit TCP/IP betreiben kann, ohne
IP-Nummern beantragen zu müssen und um auch einzelne Rechnerverbindungen
testen zu können, gibt es einen ausgesuchten Nummernkreis, der von keinem
Router nach außen gegeben wird. Diese "privaten" Adressen sind im RFC 1597
festgelegt. Es gibt ein Class-A-Netz, 16 Class-B-Netze und 255 Class-C-Netze:
<UL>
<LI>Class-A-Netz: 10.0.0.0 - 10.255.255.255
<LI>Class-B-Netze: 172.16.0.0 - 172.31.255.255
<LI>Class-C-Netze: 192.168.0.0 - 192.168.255.255
</UL>
<P>
Zusätzlich hat die IANA auch das folgende Class-B-Netz für private
Netze reserviert, das schon von Apple- und Microsoft-Clients verwendet wird, sofern
kein DHCP-Server zur Verfügung steht. Das Verfahren heißt APIPA (Automatic 
Private IP Addressing):
<UL>
<LI>169.254.0.0 - 169.254.255.255
</UL>
<P>
Weitere Adressen mit speziellen Aufgaben sind:
<UL>
<LI>100.64.0.0 - 100.127.255.255: Adressbereich für Carrier Grade NAT (CGN, RFC 6264). Aus diesem 
Bereich teilen Internet-Provider ihren Kunden Adressen zu, wenn ihnen die öffentlichen 
IP-Adressen ausgegangen sind.
<LI>192.0.0.0 - 192.0.0.255 sind reserviert. Das Netz wird bei Bedarf 
in das Vergabeverfahren übernommen. 
<LI>192.0.2.0 - 192.0.2.255, 198.51.100.0 - 198.51.100.255 und 203.0.113.0 - 203.0.113.255 
sind reserviert als Beispieladressen in Dokumentationen (wie die Domain-Namen "example.com" 
und "example.net"). Adressen aus diesem Bereich dürfen nicht im öffentlichen Internet
auftauchen.
<LI>192.88.99.0 - 192.88.99.255 sind Adressen für die Verbindung von IPv6-Netzwerken 
über IPv4 ("6to4 anycast address").
<LI>198.18.0.0 - 198.19.255.255 sind Adressen für den Test von Netzwerkkomponenten.
</UL
<P>
Der für IP reservierte Adressraum reicht nicht mehr aus, um alle
Endgeräte anzusteuern. Mögliche Abhilfen:
<ul>
<li>Dynamische Vergabe von IP-Adressen: Dieses Verfahren wird beim Dial-In beim
Provider verwendet. Es eignet sich auch im lokalen Netz, wenn davon auszugehen ist,
daß immer nur ein Teil der Rechner in Betrieb ist. Der Benutzer bekommt für
die Dauer einer Verbindung eine IP-Adresse zugeteilt. Das bekannteste Verfahren
heißt DHCP (dynamic host configuration protocol).
<li>Weiterentwicklung des IP-Protokolls: Mit IP Version 6 wird ein auf 128 Bit
erweiterter Adressraum geschaffen. Damit stehen genügend Adressen zur Vefügung.
<li>Network Address Translation (NAT): Über ein Gateway wird im Internet
eine andere IP-Adresse verwendet als im lokalen Netz (private Adressräume).
Die Umsetzung erlaubt sogar, ein komplettes privates Netz (siehe oben) mit einer
einzigen externen IP-Adresse zu betreiben.
</ul>
<P>

<H3>Network Address Translation (NAT) und IP-Masquerading</H3>
Die begrenzte Verfügbarkeit von IP-Adressen hat dazu geführt, daß
man sich Gedanken über verschiedene Möglichkeiten machen mußte,
wie man mit den existierenden Adressen ein größeres Umfeld abdecken
kann.
Eine Möglichkeit, um private Netze (und dazu gehört letztendlich auch
ein privater Anschluß mit mehr als einem PC) unter Verwendung möglichst
weniger Adressen an das Internet anzukoppeln stellen <B>NAT</B>, <B>PAT</B>
und <B>IP Masquerading</B>. Alle Verfahren bilden private Adressen gemäß
RFC 1918 oder einen proprietären (nicht registrierten) Adreßraum eines
Netzes auf öffentliche registrierte IP-Adressen ab.
<UL>
<LI>NAT (Network Address Translation)<BR>
Beim NAT (Network Address Translation) werden die Adressen eines privaten Netzes
über Tabellen öffentlich registrierten IP-Adressen zugeordnet. Der
Vorteil besteht darin, daß Rechner, die in einem privaten Netz miteinander
kommunizieren, keine öffentlichen IP-Adressen benötigen.
IP-Adressen interner Rechner, die eine Kommunikation mit Zielen im Internet aufbauen,
erhalten in dem Router, der zwischen dem Internet Service Provider (ISP) und dem
privaten Netzwerk steht, einen Tabelleneintrag. Durch diese Eins-zu-Eins-Zuordnung
sind diese Rechner nicht nur in der Lage, eine Verbindung zu Zielen im Internet
aufzubauen, sondern sie sind auch aus dem Internet erreichbar. Die interne Struktur
des Firmennetzwerkes bleibt jedoch nach außen verborgen.
<P>
<CENTER><img src="images/nat.png"></CENTER>
<P>

<LI>IP Masquerading<BR>
IP Masquerading, das manchmal auch als PAT (Port and Address Translation) bezeichnet
wird, bildet <B>alle</B> Adressen eines privaten Netzwerkes auf <B>eine</B> einzelne
öffentliche IP-Adresse ab. Dies geschieht dadurch, daß bei einer existierenden
Verbindung zusätzlich zu den Adressen auch die Portnummern ausgetauscht werden.
Auf diese Weise benötigt ein gesamtes privates Netz nur eine einzige registrierte
öffentliche IP-Adresse.
Der Nachteil dieser Lösung besteht darin, daß die Rechner im privaten Netzwerk
<B>nicht</B> aus dem Internet angewählt werden können. Diese Methode eignet
sich daher hervorragend, um zwei und mehr Rechner eines privaten Anschlusses per
DFÜ-Netzwerk oder ISDN-Router an das Internet zu koppeln.
<P>
<CENTER><img src="images/pat.png"></CENTER>
<P>
IP Masquerading rückt mit dieser Funktionalität sehr nahe an Proxy- und
Firewall-Lösungen heran, wobei ein Proxy explizit für ein Protokoll
(z. B. HTTP) existieren und aufgerufen werden muß.
</UL>
<P>

<H3>Subnetze</H3>
Nachdem nun klar ist, was ein Netz der Klasse A oder B ist, soll auf die Bildung
von Subnetzen hingewiesen werden. Diese dienen dazu, ein bestehendes Netz
in weitere, kleinere Netze zu unterteilen.
<ul>
<LI>Subnetze sind Strukturierungsmöglichkeit für Netze, ohne
daß man zusätzliche Klasse-A-, Klasse-B- oder Klasse-C-IP-Adressen braucht.
<li>Die Standardprozedur, um ein Netz in Unternetze (Subnetze) zu teilen,
nennt man "Subnetting".
<li>Die Hostadresse des A-, B- oder C-Netzes teilt sich in die Bereiche
Subnetzadresse (Subnet-ID, Teilnetz-ID) und Hostadresse (verbleibende, verkürzte
Host-ID). Ein Teil des Hostadressbereiches wird also genutzt, um die Subnetze zu
unterscheiden.
<li>Die Netzadresse und den Subnetzanteil des Hostadressraumes bezeichnet man als
"erweiterte Netzadresse" (extended network prefix).
<LI>Die interne Subnetz-Struktur von A-, B- oder C-Netzen ist nach außen hin
unsichtbar.
<li>Damit Router in der Lage sind, Datagramme in das richtige Netz zuzustellen,
müssen sie bei der IP-Adresse den Netz- und Hostanteil unterscheiden können.
<li>Dies geschieht traditionell durch die Netzmaske bzw. Subnetzmaske (subnet mask).
</ul>

Die Subnetzmaske dient dem Rechner dazu, die Zuordnung von Netzwerk-Teil und
Host-Teil vorzunehmen. Sie hat denselben Aufbau wie eine IP-Adresse (32 Bit bzw.
4 Byte). Per Definition sind alle Bit des "Netzwerk-Teils" auf 1 zu setzen,
alle Bit des "Host-Teils" auf 0. Für die o.a. Adreßklassen hat die
Subnetzmaske demnach folgendes Aussehen:
<P>
<table ALIGN=CENTER WIDTH="80%" border=1 cellpadding=4>
<tr>
<th>Adreß-Klasse</td>
<th>Subnetzmaske (binär)</td>
<th>Subnetzmaske (dezimal)</td>
</tr>
<tr>
<td>Class A</td>
<td><TT>11111111.00000000.00000000.00000000</TT></td>
<td><TT>255.0.0.0</TT></td>
</tr>
<tr>
<td>Class B</td>
<td><TT>11111111.11111111.00000000.00000000</TT></td>
<td><TT>255.255.0.0</TT></td>
</tr>
<tr>
<td>Class C</td>
<td><TT>11111111.11111111.11111111.00000000</TT></td>
<td><TT>255.255.255.0</TT></td>
</tr>
</table>
<br>
Diese Subnetzmaske (auch "Default Subnetzmaske" genannt) kann manuell
überschrieben werden.
<P>
Eine Subnet-Maske für ein Netz der Klasse
C lautet daher 255.255.255.0. Das bedeutet, daß die ersten drei Bytes die
Netzadresse angeben und das vierte Byte die Rechner adressiert. Eine Subnetz-Maske
mit dem Wert 255.255.0.0 würde folglich ein Netz der Klasse B angeben und
für ein C-Netz steht die Maske 255.255.255.0.

<H4>Aufteilung in Subnetze </H4>
<p>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADDING=4>
<TR><TD VALIGN="TOP" >Netzwerk-<br>anteil in Bit</TD>
<TD VALIGN="TOP" >Hostanteil<BR>in Bit</TD>
<TD VALIGN="TOP" >Subnetz-<br>anzahl *)</TD>
<TD VALIGN="TOP" >Hostanzahl **)</TD>
<TD VALIGN="TOP" >Subnetzmaske</TD>
</TR>
<TR><TD VALIGN="TOP"><B>8</B></TD>
<TD VALIGN="TOP"><B>24</B></TD>
<TD VALIGN="TOP"><B>1</B></TD>
<TD VALIGN="TOP"><B>16777216</B></TD>
<TD VALIGN="TOP"><B>255.0.0.0 &nbsp; &nbsp; &nbsp; Klasse A</B></TD>
</TR>
<TR><TD VALIGN="TOP">9</TD>
<TD VALIGN="TOP">23</TD>
<TD VALIGN="TOP">2</TD>
<TD VALIGN="TOP">128*65536</TD>
<TD VALIGN="TOP">255.<B>128</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">10</TD>
<TD VALIGN="TOP">22</TD>
<TD VALIGN="TOP">4</TD>
<TD VALIGN="TOP">64*65536</TD>
<TD VALIGN="TOP">255.<B>192</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">11</TD>
<TD VALIGN="TOP">21</TD>
<TD VALIGN="TOP">
8</TD>
<TD VALIGN="TOP">32*65536</TD>
<TD VALIGN="TOP">255.<B>224</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">12</TD>
<TD VALIGN="TOP">20</TD>
<TD VALIGN="TOP">16</TD>
<TD VALIGN="TOP">16*65536</TD>
<TD VALIGN="TOP">255.<B>240</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">13</TD>
<TD VALIGN="TOP">19</TD>
<TD VALIGN="TOP">32</TD>
<TD VALIGN="TOP">8*65536</TD>
<TD VALIGN="TOP">255.<B>248</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">14</TD>
<TD VALIGN="TOP">18</TD>
<TD VALIGN="TOP">64</TD>
<TD VALIGN="TOP">4*65536</TD>
<TD VALIGN="TOP">255.<B>252</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP">15</TD>
<TD VALIGN="TOP">17</TD>
<TD VALIGN="TOP">128</TD>
<TD VALIGN="TOP">2*65536</TD>
<TD VALIGN="TOP">255.<B>254</B>.0.0</TD>
</TR>
<TR><TD VALIGN="TOP"><B>16</B></TD>
<TD VALIGN="TOP"><B>16</B></TD>
<TD VALIGN="TOP"><B>1</B></TD>
<TD VALIGN="TOP"><B>65536</B></TD>
<TD VALIGN="TOP"><B>255.255.0.0 &nbsp; &nbsp; &nbsp; Klasse B</B></TD>
</TR>
<TR><TD VALIGN="TOP">17</TD>
<TD VALIGN="TOP">15</TD>
<TD VALIGN="TOP">2</TD>
<TD VALIGN="TOP">128*256</TD>
<TD VALIGN="TOP">255.255.<B>128</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">18</TD>
<TD VALIGN="TOP">14</TD>
<TD VALIGN="TOP">4</TD>
<TD VALIGN="TOP">64*256</TD>
<TD VALIGN="TOP">255.255.<B>192</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">19</TD>
<TD VALIGN="TOP">13</TD>
<TD VALIGN="TOP">8</TD>
<TD VALIGN="TOP">32*256</TD>
<TD VALIGN="TOP">255.255.<B>224</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">20</TD>
<TD VALIGN="TOP">12</TD>
<TD VALIGN="TOP">16</TD>
<TD VALIGN="TOP">16*256</TD>
<TD VALIGN="TOP">255.255.<B>240</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">21</TD>
<TD VALIGN="TOP">11</TD>
<TD VALIGN="TOP">32</TD>
<TD VALIGN="TOP">8*256</TD>
<TD VALIGN="TOP">255.255.<B>248</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">22</TD>
<TD VALIGN="TOP">10</TD>
<TD VALIGN="TOP">64</TD>
<TD VALIGN="TOP">4*256</TD>
<TD VALIGN="TOP">255.255.<B>252</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP">23</TD>
<TD VALIGN="TOP">9</TD>
<TD VALIGN="TOP">128</TD>
<TD VALIGN="TOP">2*256</TD>
<TD VALIGN="TOP">255.255.<B>254</B>.0</TD>
</TR>
<TR><TD VALIGN="TOP"><B>24</B></TD>
<TD VALIGN="TOP"><B>8</B></TD>
<TD VALIGN="TOP"><B>1</B></TD>
<TD VALIGN="TOP"><B>256</B></TD>
<TD VALIGN="TOP"><B>255.255.255.0 &nbsp; &nbsp; &nbsp; Klasse C</B></TD>
</TR>
<TR><TD VALIGN="TOP">25</TD>
<TD VALIGN="TOP">7</TD>
<TD VALIGN="TOP">2</TD>
<TD VALIGN="TOP">128</TD>
<TD VALIGN="TOP">255.255.255.<B>128</B></TD>
</TR>
<TR><TD VALIGN="TOP">26</TD>
<TD VALIGN="TOP">6</TD>
<TD VALIGN="TOP">4</TD>
<TD VALIGN="TOP">64</TD>
<TD VALIGN="TOP">255.255.255.<B>192</B></TD>
</TR>
<TR><TD VALIGN="TOP">27</TD>
<TD VALIGN="TOP">5</TD>
<TD VALIGN="TOP">8</TD>
<TD VALIGN="TOP">32</TD>
<TD VALIGN="TOP">255.255.255.<B>224</B></TD>
</TR>
<TR><TD VALIGN="TOP">28</TD>
<TD VALIGN="TOP">4</TD>
<TD VALIGN="TOP">16</TD>
<TD VALIGN="TOP">16</TD>
<TD VALIGN="TOP">255.255.255.<B>240</B></TD>
</TR>
<TR><TD VALIGN="TOP">29</TD>
<TD VALIGN="TOP">3</TD>
<TD VALIGN="TOP">32</TD>
<TD VALIGN="TOP">8</TD>
<TD VALIGN="TOP">255.255.255.<B>248</B></TD>
</TR>
<TR><TD VALIGN="TOP">30</TD>
<TD VALIGN="TOP">2</TD>
<TD VALIGN="TOP">64</TD>
<TD VALIGN="TOP">4</TD>
<TD VALIGN="TOP">255.255.255.<B>252</B></TD>
</TR>
</TABLE>
<p>
<H4>Anmerkungen:</H4>
<UL>
<B>*)&nbsp;</B> Die erste und letzte bei der Unterteilung entstehenden Adressen
dürfen nicht verwendet werden (Verwechslung mit Netz- und Broadcast-Adresse
des übergeordneten Netzes). Die Anzahl der Subnetze verringert sich somit
jeweils um zwei:<br>
Ist der Netzwerkanteil der IP-Adresse <B>n</B> Bits, dann erhält man
<B>(2<SUP>n</SUP>) - 2</B> Subnetze.
<P>
<B>**)</B> Die Rechneranzahl verringert sich ebenfalls um zwei wegen Subnetz-Adresse
(alle Rechnerbits auf 0) und Broadcast-Adresse (alle Rechnerbits auf 1):<BR>
Ist der Hostanteil der IP-Adresse <B>m</B> Bits, dann erhält man
<B>(2<SUP>m</SUP>) - 2</B> Hosts pro Subnetz.
</UL>
<p>
Besitzt breispielsweise ein Unternehmen ein Netz der Klasse C, möchte
man dieses vielleicht in zwei Segmente unterteilen, die voneinander getrennt sind.
Der Broadcastverkehr des ersten Segments kann so das andere nicht beeinträchtigen.
In diesem Fall kommt die Subnetz-Maske zum Einsatz, welche die Rechneradressen in
zwei Bereiche gliedert. Sollen die Rechner in vier gleich große Subnetze mit
je 64 Knoten eingeteilt werden, lautet die Subnetz-Maske 255.255.255.192. Es
gilt die folgende Formel für das <I>Maskier-Byte:</I>
<P>
Bytewert = 256 - (Anzahl der Knoten in einem Segment)
<P>
Als das Subnetting erstmals standardisiert wurde, war es verboten die Subnetze zu
nutzen, in denen alle Subnetzbits den Wert 0 oder 1 hatten (siehe Anmerkungen oben).
Damit ergeben sich im Beispiel nur zwei Subnetze mit je 62 Hosts. Inzwischen beherrschen
fast alle Systeme korrektes Subnetting ("classless" routing).
<P>
<H4>Beispiel: Aufteilung in 4 Subnetze</H4>
Ein Netz der Klasse C soll in vier gleich große Subnetze geteilt werden. Die
Netzadresse beträgt 192.168.98.0. Der Administrator wählt daher zur
Unterteilung die Subnetz-Maske 255.255.255.192. Die vier Rechner mit den IP-Adressen
192.168.98.3, 192.168.98.73. 192.168.98.156 und 192.168.98.197 befinden sich daher
in vier Subnetzen zwischen denen geroutet werden muß. Broadcasts in Subnetz 1
werden somit nicht in die anderen Subnetze übertragen. Es ist nun zum Beispiel
für das Unternehmen möglich, die Rechner des Vertriebs in Subnetz 1, die
des Einkaufs in Subnetz 2, jene der Entwicklung in Subnetz 3 und ein Netz aus
Demorechnern in Subnetz 4 zu organisieren. Damit ist gesichert, daß
Störungen in einzelnen Subnetzen auch lokal auf diese beschränkt
bleiben. Sie schlagen nicht auf die Datenstruktur des ganzen Unternehmens durch.
<P>
<CENTER><img src="images/subnetting.png"></CENTER>
<P>
Allgemein ergibt sich für ein C-Netz folgende Aufstellung:
<P>
<H4>Subnetze eines C-Netzes</H4>
In Klammern die reduzierte Anzahl der Subnetze (Anzahl - 2). Die rot unterlegten
Möglichkeiten sind dann in der Praxis nicht einsetzbar.
<P>
<table ALIGN=CENTER WIDTH="80%" border=1 cellpadding=4>
  <tr>
    <td align="center">Subnetzbits</td>
    <td align="center">Hostbits</td>
    <td align="center">mögliche Subnetze</td>
    <td align="center">Hostadressen</td>
    <td align="center">Subnetzmaske</td>
  </tr>
  <tr>
    <td align="center"><font color="#CC0000">1</font></td>
    <td align="center"><font color="#CC0000">7</font></td>
    <td align="center"><font color="#CC0000">2 (0)</font></td>
    <td align="center"><font color="#CC0000">126 (0)</font></td>
    <td align="center"><font color="#CC0000">255.255.255.128</font></td>
  </tr>
  <tr>
    <td align="center">2</td>
    <td align="center">6</td>
    <td align="center">4 (2)</td>
    <td align="center">62</td>
    <td align="center">255.255.255.192</td>
  </tr>
  <tr>
    <td align="center">3</td>
    <td align="center">5</td>
    <td align="center">8 (6)</td>
    <td align="center">30</td>
    <td align="center">255.255.255.224</td>
  </tr>
  <tr>
    <td align="center">4</td>
    <td align="center">4</td>
    <td align="center">16 (14)</td>
    <td align="center">14</td>
    <td align="center">255.255.255.240</td>
  </tr>
  <tr>
    <td align="center">5</td>
    <td align="center">3</td>
    <td align="center">32 (30)</td>
    <td align="center">6</td>
    <td align="center">255.255.255.248</td>
  </tr>
  <tr>
    <td align="center">6</td>
    <td align="center">2</td>
    <td align="center">64 (62)</td>
    <td align="center">2</td>
    <td align="center">255.255.255.252</td>
  </tr>
  <tr>
    <td align="center"><font color="#CC0000">7</font></td>
    <td align="center"><font color="#CC0000">1</font></td>
    <td align="center"><font color="#CC0000">128</font></td>
    <td align="center"><font color="#CC0000">0</font></td>
    <td align="center"><font color="#CC0000">255.255.255.254</font></td>
  </tr>
</table>
<P>

<H4>Beispiel: Aufteilung in 8 (6) Subnetze</H4>
Von den acht variabel verwendbaren Bits nutzt er also die drei höchstwertigen
Bits für das Subnetz und die fünf letzten Bits für die Hostadresse.
Die erste Adresse jedes Subnetz ist die Adresse in der alle Hostbits den Wert 0 haben.
<p>
<table ALIGN=CENTER WIDTH="80%" border=1 cellpadding=4>
  <tr>
    <td>&nbsp;</td>
    <td colspan="3">Subnetzbits</td>
    <td colspan="5">Hostbits</td>
    <td>dezimal</td>
  </tr>
  <tr>
    <td>Dezimale Wertigkeit des Bit</td>
    <td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td><td>&nbsp;</td>
  </tr>
  <tr>
    <td><font color="#cc0000">erstes Subnetz</font></td>
    <td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td>
  </tr>
  <tr>
    <td>zweites Subnetz</td>
    <td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>32</td>
  </tr>
  <tr>
    <td>drittes Subnetz</td>
    <td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>64</td>
  </tr>
  <tr>
    <td>viertes Subnetz</td>
    <td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>96</td>
  </tr>
  <tr>
    <td>fünftes Subnetz</td>
    <td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>128</td>
  </tr>
  <tr>
    <td>sechstes Subnetz</td>
    <td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>160</td>
  </tr>
  <tr>
    <td>siebtes Subnetz</td>
    <td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>192</td>
  </tr>
  <tr>
    <td><font color="#cc0000">achtes Subnetz</font></td>
    <td><font color="#cc0000">1</font></td><td><font color="#cc0000">1</font></td><td><font color="#cc0000">1</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">224</font></td>
  </tr>
</table>
<p>Damit sind die acht zur Verfügung stehenden Subnetze bekannt:<BR>
<PRE>
<font color="#cc0000">192.168.0.0/27</font>
192.168.0.32/27
192.168.0.64/27
192.168.0.96/27
192.168.0.128/27
192.168.0.160/27
192.168.0.192/27
<font color="#cc0000">192.168.0.224/27</font>
</PRE>
<H4>Anmerkung:</H4>
<UL>
Die Zahl hinter dem Schrägstrich (oben ist das die 27) gibt an,
wieviele Bits der 32 Bit langen IP-Adresse als Netzanteil verwendet werden.
</UL>
<P>
Diese Subnetze können jetzt einzelnen Netzen zugeordnet werden. Die folgende Tabelle
zeigt die Netz- und Broadcastadressen von jedem einzelnen Subnetz und die Rechneradressen.
<p>
<table ALIGN=CENTER WIDTH="80%" border=1 cellpadding=4>
  <tr>
    <td>Subnetz</td>
    <td colspan=3>IP-Adressen (letztes Oktett)</td>
  </tr>
  <tr>
    <td>&nbsp;</td><td>Netz</td><td>Hosts</td><td>Broadcast</td>
  </tr>
  <tr>
    <td><font color="#cc0000">erstes Subnetz</font></td><td><font color="#cc0000">0</font></td><td><font color="#cc0000">1-30</font></td><td><font color="#cc0000">31</font></td>
  </tr>
  <tr>
    <td>zweites Subnetz</td><td>32</td><td>33-62</td><td>63</td>
  </tr>
  <tr>
    <td>drittes Subnetz</td><td>64</td><td>65-94</td><td>95</td>
  </tr>
  <tr>
    <td>viertes Subnetz</td><td>96</td><td>97-126</td><td>127</td>
  </tr>
  <tr>
    <td>fünftes Subnetz</td><td>128</td><td>129-158</td><td>159</td>
  </tr>
  <tr>
    <td>sechstes Subnetz</td><td>160</td><td>161-190</td><td>191</td>
  </tr>
  <tr>
    <td>siebtes Subnetz</td><td>192</td><td>193-222</td><td>223</td>
  </tr>
  <tr>
    <td><font color="#cc0000">achtes Subnetz</font></td><td><font color="#cc0000">224</font></td><td><font color="#cc0000">225-254</font></td><td><font color="#cc0000">255</font></td>
  </tr>
</table>
<p>
Als kleine Hilfe gibt es hier noch einen Subnetz-Rechner
als Javascript-Programm. Eingegeben wird eine IP-Netzadresse
in CIDR-Form (<B>C</B>lassless <B>I</B>nter-<B>D</B>omain <B>R</B>outing,
z.B. 10.1.2.0/24). Nach dem Klick auf "Berechnen" erscheinen
im unteren Feld die Werte der Netzadresse, der Subnet-Maske und
der Bereich der zugehörigen IP-Adressen, wobei die erste Adresse
des angebenen Bereichs die Netzadresse darstellt und die letzte Adresse
die Broadcast-Adresse.

<P>
<DIV ALIGN=CENTER>
<form name="CIDR">
<table bgcolor="#000000" border=0 cellpadding="1" cellspacing="0">
<tr><td>
 <table bgcolor="#DDDDDD" border=0 cellpadding="5" cellspacing="0">
 <tr>
 <td bgcolor="#DDDDDD">CIDR: </td>
 <td><input name="Eingabe" size="20" value="192.168.1.0/24">
     <input type="button" value="Berechnen" onclick="CalcSubnet()">
 <td>
 </tr><tr>
 <td bgcolor="#DDDDDD">IP-Bereich: </td>
 <td><textarea cols="40" rows="3" name="Result" onfocus="blur()"></textarea></td>
 </tr>
 </table>
</td></tr></table>
</form>

<script type="text/javascript">
// IP-Bereiche umrechnen
function CalcSubnet()
  {
  document.CIDR.Result.value;
  Eingabe = document.CIDR.Eingabe.value;
  if (Eingabe != "")
    {
    Wert = Eingabe.split("/");
    if (Wert.length != 2)
      {
      alert("Eingabe: IP-Adresse/Netzanteil\nz.B. 192.168.233.0/24");
      return;
      }
    else
      {
      IP = Wert[0].split(".");
      if (IP.length != 4)
        {
        alert("Fehlerhafte Eingabe der IP-Nummer! \nEine IP-Adresse besteht aus 4 Zahlen (0=< Zahl <=255), getrennt durch Punkte\nz.B. 192.168.233.0");
        return;
        }
      }
    }
  NETZ = "";
  LAST = "";
  MASK = "";
  NetNum = parseInt(Wert[1]);
  if (isNaN(NetNum))
    {
    alert("Fehlerhafter Netzanteil!\nKeine Zahl!");
    return;
    }
  if (NetNum < 0 || NetNum > 32)
    {
    alert("Netzanteil /" + NetNum +" ist nicht erlaubt (0=< Netzanteil =<32)");
    return;
    }
  for (i=0; i<4; i++)
    {
    if (CalcPart(IP[i]))
      {
      alert("Fehlerhafte Eingabe der IP-Nummer '" + IP[i] +"' im "+ (i+1) +". Byte!  \nEine IP-Adresse besteht aus 4 Zahlen (0=< Zahl <=255), getrennt durch Punkte\nz.B. 192.168.233.0");
      return;
      }
    if (i < 3)
      { NETZ += "."; LAST += "."; MASK += "." };
    }
  document.CIDR.Result.value = "Netz:  " + NETZ + "\nMaske: " + MASK + "\nRange: " + NETZ + " - " + LAST;
  }

function CalcPart(Part)
  {
  if (isNaN(Part)) return 1;
  var m = parseInt(Part);
  if (isNaN(m)) return 1;
  if(m < 0 || m > 255) return 1;
  var cumm =+ m;
  if (NetNum >= 8)
    { NETZ += cumm; LAST += cumm; MASK += "255"; }
  else
    {
    if (NetNum < 0)
      { NETZ += "0"; LAST += "255"; MASK += "0"; }
    else
      {
      var f = 256, ZifNet = 0, ZifLast = 0, ZifMask = 0;
      while (f > 1)
        {
        f = f/2;
        NetNum -= 1;
        if (NetNum >= 0)
          {
          if (m >= f)
            { m -= f; ZifNet += f; ZifLast += f; }
          ZifMask += f;
          }
        else
          {
          if (m > f) { m -= f; }
          ZifLast += f;
          }
        }
      NETZ += ''+ZifNet; LAST += ''+ZifLast; MASK += ''+ZifMask;
      }
    }
  NetNum -= 8;
  return 0;
  }
// --></script>
</DIV>
<P>

<H2><A NAME="8.4">ICMP - Internet Control Message Protocol</A></H2>
ICMP erlaubt den Austauch von Fehlermeldungen und Kontrollnachrichten auf
IP-Ebene. ICMP benutzt das IP wie ein ULP, ist aber integraler Bestandteil
der IP-Implementierung. Es macht IP nicht zu einem 'Reliable Service', ist
aber die einzige Möglichkeit Hosts und Gateways über den Zustand
des Netzes zu informieren (z. B. wenn ein Host temporär nicht erreichbar
ist --&gt; Timeout).
<P>
Die ICMP-Nachricht ist im Datenteil des IP-Datagramms untergebracht, sie
enthält ggf. den IP-Header und die ersten 64 Bytes des die Nachricht
auslösenden Datagramms (z. B. bei Timeout).
<P>
<center><img src="images/icmp.png" ALT=""></center>
<P>
Die fünf Felder der ICMP-Message haben folgende Bedeutung:
<DL>
<DT>Type
<DD>Identifiziert die ICMP-Nachricht
<UL>
<LI> 0   Echo reply
<LI> 3   Destination unreachable
<LI> 4   Source quench
<LI> 5   Redirect (Change a Route)
<LI> 8   Echo request
<LI>11   Time exceeded for a datagram
<LI>12   Parameter Problem on a datagram
<LI>13   Timestamp request
<LI>14   Timestamp reply
<LI>15   Information request
<LI>16   Information reply
<LI>17   Address mask request
<LI>18   Address mask reply
</UL>
<DT>Code
<DD>Detailinformation zum Nachrichten-Typ

<DT>Checksum
<DD>Prüfsumme der ICMP-Nachricht (Datenteil des IP-Datagramms)

<DT>Identifier und Sequence-Nummer
<DD>dienen der Zuordnung eintreffender Antworten
zu den jeweiligen Anfragen, da eine Station mehrere Anfragen aussenden kann
oder auf eine Anfrage mehrere Antworten eintreffen können.
</DL>
<P>
Wenden wir uns nun den einzelnen Nachrichtentypen zu:
<DL>
<DT>Echo request/reply
<DD>Überprüfen der Erreichbarkeit eines Zielknotens. Es können
Testdaten mitgeschickt werden, die dann unverändert zurückgeschickt
werden (--&gt; Ping-Kommando unter UNIX).

<DT>Destination unreachable
<DD>Im Codefeld wird die Ursache näher beschrieben:
     0    Network unreachable
     1    Host unreachable
     2    Protocol unreachable
     3    Port unreachable
     4    Fragmentation needed
     5    Source route failed

<DT>Source quench
<DD>Wenn mehr Datagramme kommen als eine Station verarbeiten kann, sendet sie
diese Nachricht an die sendende Station.

<DT>Redirect
<DD>wird vom ersten Gateway an Hosts im gleichen Teilnetz gesendet, wenn es
eine bessere Route-Verbindung über einen anderen Gateway gibt. In der
Nachricht wird die IP-Adresse des anderen Gateways angegeben.

<DT>Time exceeded
<DD>Für diese Nachricht an den Quellknoten gibt es zwei Ursachen:
<UL>
<LI>Time-to-live exceeded (Code 0): Wenn ein Gateway ein Datagramm eliminiert,
dessen TTL-Zähler abgelaufen ist.
<LI>Fragment reassembly time exceeded (Code 1): Wenn ein Timer abläuft,
bevor alle Fragmente des Datagramms eingetroffen sind.
</UL>
<DT>Parameter problem on a Datagramm
<DD>Probleme bei der Interpretation des IP-Headers. Es wird ein Verweis
auf die Fehlerstelle und der fragliche IP-Header zurückgeschickt.

<DT>Timestamp request/reply
<DD>Erlaubt Zeitmessungen und -synchronisation im Netz. Drei Zeiten werden gesendet
(in ms seit Mitternacht, Universal Time):
<UL>
<LI>Originate T.:  Sendezeitpunkt des Requests (vom Absender)
<LI>Receive T.:    Ankunftszeit (beim Empfänger)
<LI>Transmit T.:   Sendezeitpunkt des Reply (vom Empfänger)
</UL>

<DT>Information request/reply
<DD>Mit dieser Nachricht kann ein Host die Netid seines Netzes erfragen, indem
er seine Netid auf Null setzt.

<DT>Address mask request/reply
<DD>Bei Subnetting (siehe unten) kann ein Host die Subnet-Mask erfragen.
</DL>
<P>
Für den User nutzbar ist ICMP vor allem für die Kommandos <i>ping</i>
und <i>traceroute</i> (bei Windows "tracert"). Diese Kommandos senden ICMP-Echo-Requests
aus und warten auf den ICMP-Echo-Reply. So kann man die Erreichbarkeit eines
Knotens feststellen. Will man alle Knoten im lokalen Netz erkennen genügt ein
<i>ping</i> auf die Broadcast-Adresse, z. B.:
<pre>
ping 192.168.33.255
</pre>
Zum Anzeigen der Arp-Tabelle gibt es unter Windows wie unter Linux das <i>arp</i>-Kommando,
mit <i>arp -a</i> erhält man eine Liste der aktuell gespeicherten MAC-Adressen und
deren Zuordnung zu IP-Adressen.
<P>
Führt man das obige <i>ping</i>-Kommando und das <i>arp</i>-Kommando nacheinander
aus, erhält man eine liste der IP- umd MAC-Adressen der aktiven lokalen Knoten, z.B.:
<PRE>
ping -b -c1 192.168.33.255
arp -a
</PRE>
<P>


<H2><A NAME="8.5">UDP - User Datagram Protocol</A></H2>
UDP ist ein einfaches Schicht-4-Protokoll, das einen nicht zuverlässigen,
verbindungslosen Transportdienst ohne Flußkontrolle zur Verfügung
stellt. UDP ermöglicht zwischen zwei Stationen mehrere unabhängige
Kommunikationsbeziehungen (Multiplex-Verbindung): Die Identifikation der
beiden Prozesse einer Kommuninkationsbeziehung geschieht (wie auch bei TCP,
siehe unten) durch Port-Nummern (kurz "Ports"), die allgemein
bekannten Anwendungen fest zugeordnet sind. Es lassen sich aber auch Ports
dynamisch vergeben oder bei einer Anwendung durch verschiedene Ports deren
Verhalten steuern. Die Transporteinheiten werden 'UDP-Datagramme' oder 'User
Datagramme' genannt. Sie haben folgenden Aufbau:
<P>
<center><img src="images/udp.png" ALT=""></center>
<P>
<DL>
<DT>Source Port
<DD>Identifiziert den sendenden Prozeß (falls nicht benötigt, wird
der Wert auf Null gesetzt).

<DT>Destination Port
<DD>Identifiziert den Prozeß des Zielknotens.

<DT>Length
<DD>Länge des UDP-Datagramms in Bytes (mindestens 8 = Headerlänge)

<DT>UDP-Checksum
<DD>Optionale Angabe (falls nicht verwendet auf Null gesetzt) einer Prüfsumme.
Zu deren Ermittlung wird dem UDP-Datagramm ein Pseudoheader von 12 Byte
vorangestellt (aber nicht mit übertragen), der u. a. IP-Source-Address,
IP-Destination-Address und Protokoll-Nummer (UDP = 17) enthält.
</DL>
<P>

<H2><A NAME="8.6">TCP - Transmission Control Protocol</A></H2>
Welches übergeordnete Protokoll der Transportschicht das Datenpaket
erhält, steht im 'Protokoll'-Feld eines jeden IP-Paketes. Jedes Protokoll
der Transportschicht bekommt eine eindeutige Identifikationsnummer zugewiesen,
anhand der die IP-Schicht entscheiden kann, wie weiter mit dem Paket zu verfahren
ist. Eines der wichtigsten Protokolle der Transportschicht ist TCP.
<P>
Die Aufgabe von TCP ist es, die oben geschilderten Defizite von IP zu verbergen.
Für den TCP-Benutzer soll es nicht mehr sichtbar sein, daß die
darunterliegenden Protokollschichten Datenpakete versenden, sondern es soll der
Benutzer mit einem Byte-Strom wie bei einer normalen Datei (oder einem Terminal)
arbeiten können. TCP garantiert vor allen Dingen den korrekten Transport der
Daten - jedes Paket kommt nur einmal, fehlerfrei und in der richtigen Reihenfolge an.
Zusätzlich können bei TCP mehrere Programme die Verbindung zwischen
zwei Rechnern quasi-gleichzeitig nutzen. TCP teilt die Verbindung in viele
virtuelle Kanäle ("Ports") auf, die zeitmultiplex mit Daten versorgt werden.
Nur so ist es möglich, daß beispielsweise mehrere Benutzer eines
Rechners zur selben Zeit das Netz in Anspruch nehmen können oder daß man
mit einer einzigen Wählverbindung zum Provider gleichzeitig E-Mail empfangen und
Dateien per FTP übertragen kann.
<p>
Dieses Protokoll implementiert also einen verbindungsorientierten, sicheren Transportdienst
als Schicht-4-Protokoll. Die Sicherheit wird durch positive Rückmeldungen
(acknowledgements) und Wiederholung fehlerhafter Blöcke erreicht. Fast
alle Standardanwendungen vieler Betriebssysteme nutzen TCP und das darunterliegende
IP als Transportprotokoll, weshalb man die gesamte Protokollfamilie allgemein
unter 'TCP/IP' zusammenfaßt. TCP läßt sich in lokalen und
weltweiten Netzen einsetzen, da IP und die darunterliegenden Schichten mit
den unterschiedlichsten Netzwerk- und Übertragungssystemen arbeiten
können (Ethernet, Funk, serielle Leitungen, ...). Zur Realisierung
der Flußkontrolle wird ein Fenstermechanismus (sliding windows)
verwendet (variable Fenstergröße). TCP-Verbindungen sind
vollduplex. Wie bei allen verbindungsorientierten Diensten muß zunächst
eine virtuelle Verbindung aufgebaut und bei Beendigung der Kommunikation
wieder abgebaut werden. "Verbindungsaufbau" bedeutet hier eine
Vereinbarung beider Stationen über die Modalitäten der Übertragung
(z. B. Fenstergröße, Akzeptieren eines bestimmten Dienstes, usw.).
Ausgangs- und Endpunkte einer virtuellen Verbindung werden wie bei UDP durch
Ports identifiziert. Allgemein verfügbare Dienste
werden über 'well known' Ports (--&gt; feste zugeordnete Portnummer)
erreichbar. Andere Portnummern werden beim Verbindungsaufbau vereinbart.
<P>

Damit die ständige Bestätigung jedes Datensegments den Transport nicht
über Gebühr hemmt, werden zwei Tricks verwendet. Zum einen kann die
Empfangsbetätigung einem Segment in Gegenrichtung mitgegeben werden - das spart ein
separates Quittungssegment. Zweitens muß nicht jedes Byte sofort bestätigt
werden, sondern es gibt ein sogenanntes 'Fenster'.
Die Fenstergröße gibt an, wieviele Bytes gesendet werden dürfen,
bis die Übertragung quittiert werden muß. Erfolgt keine Quittung,
werden die Daten nochmals gesendet. Die empfangene Quittung enthält
die Nummer des Bytess, das als nächstes vom Empfänger erwartet
wird - womit auch alle vorhergehenden Bytes quittiert sind. Die Fenstergröße
kann dynamisch mit der Quittung des Empfängers geändert
werden. Werden die Ressourcen knapp, wird die Fenstergröße verringert.
Beim Extremfall Null wird die Übertragung unterbrochen, bis der Empfänger
erneut quittiert. Neben einem verläßlichen Datentransport ist
so auch die Flußkontrolle gewährleistet.
<P>
<center><img src="images/windows.png" ALT=""></center>
<P>
Das Prinzip des Fenstermechanismus ist eigentlich ganz einfach. Wenn man das Bild
betrachtet, ergibt sich folgende Sachverhalt:
<UL>
<LI> Die Fenster größe im Beispiel beträgt drei Bytes.
<LI>Byte 1 wurde von der Datenquelle gesendet und vom Empfänger quittiert.
<LI>Die Quelle hat die Bytes 2, 3 und 4 gesendet, sie wurden aber vom
Empfänger noch nicht quittiert (Quittung eventuell noch unterwegs).
<LI>Byte 5 wurde von der Quelle noch nicht gesendet. Er geht erst dann auf
die Reise, wenn die Quittung für Byte 2 (oder höher) eingetroffen ist.
</UL>
<P>
Das TCP-Paket wird oft auch als 'Segment' bezeichnet. Jedem TCP-Block ist ein
Header vorangestellt, der aber wesentlich umfangreicher als die bisherigen ist:
<P>
<center><img src="images/tcp.png" ALT=""></center>
<P>
<DL>
<DT>Source Port
<DD>Identifiziert den sendenden Prozeß.

<DT>Destination Port
<DD>Identifiziert den Prozeß des Zielknotens.

<DT>Sequence Number
<DD>TCP betrachtet die zu übertragenden Daten als numerierten Bytestrom,
wobei die Nummer des ersten Bytes beim Verbindungsaufbau festgelegt wird.
Dieser Bytestrom wird bei der Übertragung in Blöcke (TCP-Segmente)
aufgeteilt. Die 'Sequence Number' ist die Nummer des ersten Datenbytes im
jeweiligen Segment (--&gt; richtige Reihenfolge über verschiedene Verbindungen
eintreffender Segmente wiederherstellbar).

<DT>Acknowledgement Number
<DD>Hiermit werden Daten von der Empfängerstation bestätigt, wobei
gleichzeitig Daten in Gegenrichtung gesendet werden. Die Bestätigung
wird also den Daten "aufgesattelt" (Piggyback). Die Nummer bezieht
sich auf eine Sequence-Nummer der empfangenen Daten; alle Daten bis zu dieser
Nummer (ausschließlich) sind damit bestätigt --&gt; Nummer des
nächsten erwarteten Bytes. Die Gültigkeit der Nummer wird durch
das ACK-Feld (--&gt; Code) bestätigt.

<DT>Data Offset
<DD>Da der Segment-Header ähnlich dem IP-Header Optionen enthalten kann,
wird hier die Länge des Headers in 32-Bit-Worten angegeben.

<DT>Res.
<DD>Reserviert für spätere Nutzung

<DT>Code
<DD>Angabe der Funktion des Segments:
<UL>
<LI>URG  Urgent-Pointer (siehe unten)
<LI>ACK  Quittungs-Segment (Acknowledgement-Nummer gültig)
<LI>PSH  Auf Senderseite sofortiges Senden der Daten (bevor Sendepuffer
gefüllt ist) und auf Empfangsseite sofortige Weitergabe an die Applikation
(bevor Empfangspuffer gefüllt ist) z. B. für interaktive Programme.
<LI>RST  Reset, Verbindung abbauen
<LI>SYN Das 'Sequence Number'-Feld enthält die initiale Byte-Nummer
(ISN) --&gt; Numerierung  beginnt  mit ISN + 1. In der Bestätigung
übergibt die Zielstation ihre ISN (Verbindungsaufbau).
<LI>FIN Verbindung abbauen (Sender hat alle Daten gesendet), sobald der
Empfänger alles korrekt empfangen hat und selbst keine Daten mehr loswerden
will.
</UL>

<DT>Window
<DD>Spezifiziert die Fenstergröße, die der Empfänger bereit
ist anzunehmen - kann dynamisch geändert werden.

<DT>Checksum
<DD>16-Bit Längsparität über Header und Daten.

<DT>Urgent Pointer
<DD>Markierung eines Teils des Datenteils als dringend. Dieser wird unabhängig
von der Reihenfolge im Datenstrom sofort an das Anwenderprogramm weitergegeben
(URG-Code muß gesetzt sein).  Der Wert des Urgent-Pointers markiert
das letzte abzuliefernde Byte; es hat die Nummer &lt;Sequence Number&gt;
+ &lt;Urgent Pointer&gt;.

<DT>Options
<DD>Dieses Feld dient dem Informationsaustausch zwischen beiden Stationen auf
der TCP-Ebene, z. B. die Segmentgröße (die Ihrerseits von der
Größe des IP-Datagramms abhängen sollte, um den Durchsatz
im Netz optimal zu gestalten).
</DL>
<P>

<H4>Ablauf einer TCP-Session</H4>
Im Gegensatz zu IP ist TCP <B>verbindungsorientiert</B>. Das muß so sein,
denn TCP-Verbindungen sollen ja für den Benutzer prinzipiell wie Dateien zu
handhaben sein. Das bedeutet, eine TCP-Verbindung wird wie eine Datei geöffnet und
geschlossen, und man kann ihre Position innerhalb des Datenstroms bestimmen, genau
wie man bei einer Datei die Position der Lese- oder Schreibposition angeben kann.
TCP sendet die Daten auch in größeren Einheiten, um den Verwaltungsaufwand
durch Header- und Kontrollinformationen klein zu halten. Im Gegensatz zu
den IP-Paketen bezeichnet man die Einheiten der Transportschicht als "Segmente".
Jedes gesendete TCP-Segment hat eine eindeutige Folgenummer, welche die Position
seines ersten Bytes im Byte-Strom der Verbindung angibt. Anhand dieser Nummer
kann die Reihenfolge der Segmente korrigiert und doppelt angekommene Segmente
können aussortiert werden. Da die Länge des Segments aus dem IP-Header
bekannt ist, können auch Lücken im Datenstrom entdeckt werden, und der
Empfänger kann verlorengegangene Segmente neu anfordern.
<P>
Beim Öffnen einer TCP-Verbindung tauschen beide Kommunikationspartner
Kontrollinformationen aus, die sicherstellen, daß der jeweilige Partner
existiert und Daten annehmen kann. Dazu schickt die Station A ein Segment mit der
Aufforderung, die Folgenummern zu synchronisieren. <BR>
Das einleitende Paket mit gesetztem SYN-Bit ("Synchronise-" oder "Open"-Request)
gibt die Anfangs-"Sequence Number" des Client bekannt. Diese Anfangs-"Sequence
Number wird zufällig bestimmt. Bei allen nachfolgenden Paketen ist das
ACK-Bit ("Acknowledge", "Quittung") gesetzt. Der Server antwortet mit ACK, SYN
und der Client bestätigt mit ACK. Das sieht dann so aus:
<P>
<CENTER><img src="images/tcp-hs1.png"></CENTER>
<P>
Die Station B weiß jetzt, daß
der Sender eine Verbindung öffnen möchte und an welcher
Position im Datenstrom der Sender anfangen wird zu zählen. Sie
bestätigt den Empfang der Nachricht und legt ihrerseits eine
Folgenummer für Übertragungen in Gegenrichtung fest.
<P>
<CENTER><img src="images/tcp-hs2.png"></CENTER>
<P>
Station A bestätigt nun den Empfang der Folgenummer von B und beginnt
dann mit der Übertragung von Daten.
<P>
<CENTER><img src="images/tcp-hs3.png"></CENTER>
<P>
Diese Art des Austausches von Kontrollinformationen, bei der jede Seite die Aktionen
der Gegenseite bestätigen muß, ehe sie wirksam werden können,
heißt "Dreiwege-Handshake". Auch beim Abbau einer Verbindung wird auf diese
Weise sichergestellt, daß beide Seiten alle Daten korrekt und vollständig
empfangen haben. Im zeitlichen Zusammenhang stellt sich eine TCP/IP-Verbindung
folgendermaßen dar:
<P>
<center><img src="images/tcpip2.png"></center>
<P>
Das folgende Beispiel zeigt die Arbeitsweise des TCP/IP - Protokolls. Es wird
eine Nachricht von einem Rechner im grünen Netz zu einem Rechner im orangen
Netz gesendet.
<P>
<TABLE BORDER=0 CELLPADDING=5>
<TR>
<TD VALIGN=TOP><img src="images/tcpbsp1.png"></TD>
<TD VALIGN=TOP>
Die Nachricht wird in mehrere Pakete aufgeteilt und auf der besten Route
auf die Reise geschickt. Das verbindungslose IP-Protokoll sorgt zusammen mit
den Routern für den Weg.</TD>
</TR><TR>
<TD VALIGN=TOP>
Da eine Strecke überlastet ist, werden die Pakete 3, 4 und 5 auf einer
anderen Strecke weiter transportiert. Dieser Transport erfolgt zufälligerweise
schneller als jener der Pakete 1 und 2.</TD>
<TD VALIGN=TOP><img src="images/tcpbsp2.png"></TD>
</TR><TR>
<TD VALIGN=TOP><img src="images/tcpbsp3.png"></TD>
<TD VALIGN=TOP>
Die Pakete wandern ihrem Bestimmungsnetz entgegen. Das erste Paket ist
bereits angekommen. Paket 3 kommt vor Paket 2 am Ziel an.</TD>
</TR><TR>
<TD VALIGN=TOP>
Die Pakete 1, 2 und 3 sind - in falscher Reihenfolge - am Zielrechner angekommen.
Auf der Strecke, auf der Pakete 4 und 5 transportiert werden, tritt eine Störung
auf.</TD>
<TD VALIGN=TOP><img src="images/tcpbsp4.png"></TD>
</TR><TR>
<TD VALIGN=TOP><img src="images/tcpbsp5.png"></TD>
<TD VALIGN=TOP>
Paket 4 ist bei der Störung verloren gegangen. Paket 5 wird auf einer
anderen Route zum Zielnetz geschickt (wären die Routen statisch am Router
eingetragen, ginge auch Paket 5 verloren).</TD>
</TR><TR>
<TD VALIGN=TOP>
Alle überlebenden Pakete sind am Zielrechner angekommen. Das TCP-Protokoll
setzt die Pakete wieder in der richtigen Reihenfolge zusammen und fordert das
fehlende Paket 4 nochmals beim Sender an. Für den Empfänger ergibt sich
ein kontinuierlicher Datenstrom.</TD>
<TD VALIGN=TOP><img src="images/tcpbsp6.png"></TD>
</TR>
</TABLE>
<P>

<H4>TCP-Zustandsübergangsdiagramm</H4>
Den gesamte Lebenszyklus einer TCP-Verbindung beschreibt die folgende Grafik in einer
relativ groben Darstellung.
<P>
<center><img src="images/tcpzust.png"></center>
<P>
Erklärung der Zustände:
<UL>
<li> LISTEN: Warten auf ein Connection Request.
<li> SYN-SENT: Warten auf ein passendes Connection Request,
nachdem ein SYN gesendet wurde.
<li>SYN-RECEIVED: Warten auf Bestätigung des Connection Request
Acknowledgement, nachdem beide Teilnehmer ein Connection Request
empfangen und gesendet haben.
<li>ESTABLISHED: Offene Verbindung.
<li>FIN-WAIT-1: Warten auf ein Connection Termination Request des Kommunikationspartners
oder auf eine Bestätigung des Connection Termination, das vorher gesendet wurde.
<li>FIN-WAIT-2: Warten auf ein Connection Termination Request des Kommunikationspartners.
<li>CLOSE-WAIT: Warten auf ein Connection Termination Request (CLOSE) der darüberliegenden
Schicht.
<li>CLOSING: Warten auf ein Connection Termination Request des Kommunikationspartners.
LAST-ACK: Warten auf die Bestätigung des Connection Termination Request, das zuvor an
den Kommunikationspartner gesendet wurde.
</ul>
<P>

<H3>Zeitüberwachung</H3>

In allen Protokollimplementierungen spielt die Zeit eine wichtige Rolle. So werden
alle Abläufe zeitlich überwacht. Dazu werden in der Protokollimplementierung
sogenannte "Timer" gestartet, deren Timeout zur Fehlerbehandlung führt.
<p>

<H4>Paketwiederholungs-Wecker oder Retransmission Timeout</H4>

In Weitverkehrsnetzen mit unterschiedlichsten Verbindungsarten, die noch dazu
zeitlichen Schwankungen unterworfen sind, ist die Wahl der Wartezeit auf
Bestätigungen schwierig.
Der Retransmission Timeout (RTO) läuft ab, wenn der vorgegebene Zeitraum
zwischen dem Aussenden eines TCP-Pakets bis zum Eintreffen der dazugehörigen
Quittung überschritten wird. In diesem Fall muß das Paket noch einmal
gesendet werden. Allerdings darf der Zeitraum nicht fest definiert sein, da man
sonst TCP nicht über Netzwerke mit unterschiedlichen Laufzeiten betreiben
könnte - wenn man z.B. Ethernet und eine serielle Verbindung über mehrere
Gateways miteinander vergleicht, ergibt sich ein tausendfacher Unterschied in der
Übertragungsrate. Daher wird in TCP bei jedem Paket die Zeit gemessen, die
zwischen Senden und Empfangen einer Quittung vergeht, die sogenannte <i>Round Trip Time
(RTT)</i>. Die so gemessene Zeit wird über eine Formel umgerechnet, die Spitzen
nach oben und unten herausfiltert, sich aber auch allmählich an eine
verlängerte oder verkürzte Laufzeit anpaßt. Das Ergebnis ist die
<i>Smoothed Round Trip Time (SRTT)</i>, d.h. die mittlere Zeit, die für einen
Paketaustausch verstreicht. Diese Zeit wird nochmals skaliert, um weiteren Spielraum
für unvorhergesehene Verzögerungen zu schaffen.
<PRE>
SRTT:     S = aS + (1 - a)R
RTO:      T = min[U, max[L,ßS]]
          (L &lt; T &lt; U)
</PRE>
 S Smoothed Round Trip Time<BR>
 R Round Trip Time<BR>
 T Retransmission Timeout (z.B. 30 Sekunden)<BR>
 U Zeitobergrenze (z.B. 1 Sekunde)<BR>
 L Zeituntergrenze (z.B. 1 Minute)<BR>
 a Smoothing Factor (z.B. 0.9)<BR>
 ß Scaling Factor (z.B. 2.0)<BR>
<P>
Die beiden Formeln werden durch den RFC 793 spezifiziert: zunächst den SRTT-Filter,
danach die Ermittlung des RTO. Falls nach der Wiederholung des Pakets der Wiederholungstimer
ein weiteres Mal abläuft, wird der RTO in der Regel bis zu zwölfmal exponentiell
erhöht. Erst wenn auch diese Erhöhung keinen Effekt zeigt, gilt die Verbindung als
unterbrochen.
<P>

<H4>Persistance Timer</H4>
Beim Austausch von Daten über TCP ist es im Prinzip möglich, daß
das Empfangsfenster gerade auf 0 steht - und genau in diesem Moment ein Paket
verlorengeht, das das Fenster wieder öffnen sollte. Als Ergebnis warten
dann beide TCPs bis in alle Ewigkeit aufeinander. Ein Gegenmittel dazu ist der
Persistenz-Timer, der in bestimmten Zeitabschnitten kleine TCP-Pakete
(1 Byte) abschickt und damit überprüft, ob die Empfängerseite wieder
bereit ist. Ist das Empfangsfenster nach wie vor 0, kommt eine negative Quittung
zurück; ist es größer, können nach der positiven Quittung
weitere Daten gesendet werden.
<P>

<H4>Stillhaltezeit oder Quiet Time</H4>
Jede Möglichkeit der Verwechslung von Verbindungen durch im Netz herumirrende
überholte TCP-Pakete sollte verhindert werden. Daher werden nach dem Abbau
von TCP-Verbindungen Portnummern erst wieder freigegeben, wenn eine bestimmte Zeitspanne,
die zweimal die "Maximum Segment Lifetime" (MSL) beträgt, vergangen ist. Die MSL
entspricht der Zeit, in UNIX die im TTL-Feld von IP eingetragen wird.
Der UNIX-Anwender bemerkt diese Wartezeit, wenn er eine Verbindung zwischen
gleichen Partnern (d.h. gleichen Portnummern) sofort nach dem Abbruch wieder
eröffnen will. Das System teilt ihm dann mit, daß die verwendete
Portnummer noch belegt ist. Erst nach Ablauf von ca. 30 Sekunden ist ein erneuter
Verbindungsaufbau möglich.
<P>

<H4>Keep Alive Timer und Idle Timer</H4>
Dabei handelt es sich um zwei nicht in der TCP-Spezifikation vorgesehene Wecker, die
aber in UNIX-Systemen implementiert sind. Beide stehen miteinander in Verbindung.
Der Keep Alive Timer bewirkt, daß in regelmäßigen Zeitabständen
ein leeres Paket abgeschickt wird, um das Bestehen der Verbindung zum Partner zu
überprüfen. Antwortet der Partnerrechner nicht, wird die Verbindung
nach Ablauf des Idle Timers abgebrochen. Eine Applikation aktiviert diese Timer mit
der KEEP_ALIVE-Option über die Socket-Schnittstelle.
In der folgenden Tabelle sind die Werte für die oben genannten Timer angegeben.
Dazu ist zu bemerken, daß die Dauer der Timer implementationsabhängig ist
und nicht immer auf die unten angegebenen Werte eingestellt sein muß.
<P>

<TABLE BORDER=1 CELLPADDING=3 CELLSPACING=0>
<TR><TH COLSPAN=2>Einstellungen der TCP-Timer (implementationsabhängig)</TH></TR>
<TR><TH>Timer</TH><TH>Dauer [s]</TH></TR>
<TR><TD>Retransmission Timeout</TD><TD>dynamisch</TD></TR>
<TR><TD>Persistance Timer</TD><TD>5</TD></TR>
<TR><TD>Quiet Timer</TD><TD>30</TD></TR>
<TR><TD>Keep Alive Timer</TD><TD>45</TD></TR>
<TR><TD>Idle Timer</TD><TD>360</TD></TR>
</TABLE>
<P>


<H3>Algorithmen zur Steigerung der Effizienz</H3>

Zwischen einer TCP-Implementierung nach Spezifikation und einem optimierten TCP-Subsystem,
wie man es in UNIX-Systemen vorfindet, liegt ein weiter Weg. Zahllose Verbesserungen
sind in den Jahren in die UNIX-TCP-Implementierungen eingeflossen und neue Algorithmen
in Nachfolgeversionen integriert worden:
<P>

<H4>Acknowledgement Delay</H4>
Normalerweise sendet der Empfänger nach Erhalt eines Pakets ein Antwortpaket,
in dem die Größe des Empfangsfensters verkleinert und die Daten quittiert
werden. Nach Übergabe der Daten an den empfangenden Prozeß werden die Datenpuffer
im System frei, was ein Absenden eines Pakets mit einer Vergrößerung des
Empfangsfensters zur Folge hat. Hat das Programm die Daten verarbeitet, folgt in der
Regel kurz danach eine Antwort, es sind also für eine Transaktion in der Regel drei
Pakete notwendig. Man hat aber festgestellt, daß in manchen Fällen, z.B. beim
Telnet- oder SSH-Betrieb, ein Verzögern des Quittungspakets um 0,2 Sekunden
Vorteile bringt: nach dieser kurzen Wartezeit können alle drei Informationen -
Empfangsfenster, Quittung und Antwort - in einem einzigen Paket versendet werden. Damit
Datentransfers, die hohen Durchsatz benötigen, nicht gebremst werden, unterbleibt die
Verzögerung, wenn das Empfangsfenster um mindestens 35% oder zwei maximale Pakete
verändert wurde.
<P>


<H4>Silly Window Syndrome Avoidance</H4>
In bestimmten Situationen werden Empfangsfensterangaben versendet, die derart klein sind,
daß das Netzwerk und Rechner von den vielen Quittungspaketen über Gebühr
belastet werden. Um das zu verhindern, wird das Empfangsfenster nur dann wieder
vergrößert, wenn ausreichend Platz (mehr als 1/4 des Datenpuffers oder ein
maximales Paket) zur Verfügung steht. Desgleichen verhält sich auch der
Sender konservativ und sendet nur, wenn das angebotene Fenster ausreichend groß ist.
<P>

<H4>Nagle Algorithmus oder Small Packet Avoidance</H4>
Benannt nach seinem Erfinder John Nagle, versucht dieser Algorithmus, das Versenden von 
kleinen TCP-Paketen zu verhindern. Wenn bestimmte Anwendungen nur sehr kleine Pakete
versenden, ist der Header meist größer als die Nutzdaten. Daher versucht der Algorithmus 
mehrere Pakete zusammenzufassen. Das erste Paket wird immer sofort ausgesendet, weitere Daten 
aber auf Senderseite so lange gepuffert, bis ein volles Paket geschickt werden kann oder 
eine Quittung für das vorhergehende Paket eingetroffen ist. Ist ein Paket nicht voll, 
dann wird es gesendet, wenn keine unbestätigten Pakete mehr unterwegs sind. Probleme ergeben 
sich jedoch bei Anwendungen, die viele kleine Nachrichten abschicken, ohne eine Antwort 
zurückzuerhalten (z. B. SSH). In diesem Fall lässt sich der Nagle-Algorithmus 
abschalten. 

<H4>Slow Start with Congestion Avoidance</H4>
Diese miteinander verbundenen Algorithmen, manchmal auch als Jacobson-Algorithmen
bezeichnet, sind erst in jüngster Zeit bekannt geworden und in erster
Linie für langsame Netzwerke und den Betrieb von Netzen mit Gateways von
Bedeutung.  Man hatte in den letzten Jahren beobachtet, daß das Internet mit
steigender Belastung immer weniger Datendurchsatz lieferte und zum Teil sogar
nahezu zusammenbrach. Als man die Vorgänge näher betrachtete, wurde
festgestellt, daß mehr als die Hälfte der Daten Wiederholungen
verlorengegangener TCP-Pakete waren. Was war geschehen? Ein Netzwerkpfad -
Datenpuffer vom Sender über mögliche Gateways bis hin zum
Empfänger - kann nur eine endliche Datenmenge aufnehmen.
Wenn ein Gateway oder ein Host sehr durch Verkehr belastet sind, kann es
vorkommen, daß nicht genügend Pufferplatz zur Aufnahme von Paketen
vorhanden ist. In diesem Fall werden die Pakete vom Gateway verworfen,
woraufhin der Absender des Pakets nach Ablauf des Retransmission Timeouts
eine Wiederholung vornimmt und dadurch insgesamt die Belastung des Netzes weiter
unnötig steigert. Der Slow Start-Algorithmus versucht nun zu ermitteln, wieviele
Daten zu einem Zeitpunkt in Richtung Empfänger unterwegs sein können, ohne
daß es dabei zu Verlusten kommt. Erreicht wird das über eine allmähliche
Steigerung der ausgesendeten Datenmenge bis zu einem Punkt, an dem sich ein
gleichmässiger Datenfluß ohne Wiederholungen ergibt. Wo früher
die Menge der auszusendenden Daten durch die Größe bestimmt wurde,
ist jetzt die Aufnahmekapazität des Netzwerkpfads, das sogenannte "Congestion Window",
die bestimmende Größe, wobei das Congestion Window immer kleiner oder gleich
dem Empfangsfenster (Receive Window) ist. Hat sich das Congestion Window eingependelt,
wird es erst wieder verändert, wenn auftretende Wiederholungen ein Ansteigen der
Netzwerklast signalisieren: in diesem Fall tritt die "Congestion Avoidance" in Kraft.
Gleichzeitig wird durch ständiges vorsichtiges Vergrößern des Congestion
Windows versucht, unter Umständen freiwerdende Ressourcen zu benutzen. Aufgrund des
konservativen Verhaltens läßt sich der Durchsatz um bis zu 30% steigern und
die Anzahl der wiederholten Pakete um über 50% senken. In Verbindung mit diesen
beiden Algorithmen wurde auch die Ermittlung des Retransmission Timeouts verbessert.
Dieser Wert paßt sich jetzt schneller an Veränderungen in der RTT an und
verhindert zusätzliche Paketwiederholungen.
<P>


<H3>Ports für jeden Dienst</H3>
Server-Prozesse lauschen bei UDP und TCP auf bestimmten Portnummern. Per
Übereinkunft werden dazu Ports niedriger Nummern verwendet. Für
die Standarddienste sind diese Portnummern in den RFCs festgeschrieben.
Ein Port im "listen"-Modus ist gewissermaßen eine halboffene Verbindung.
Nur Quell-IP und Quellport sind bekannt. Der Serverprozeß kann vom
Betriebssystem dupliziert werden, so daß weitere Anfragen auf diesem
Port behandelt werden können.
<P>
<ul>
<li>Die Portnummern werden auf dem Host-System konfiguriert und haben zwei Funktionen:
  <ul>
  <li>Allgemein verfügbare Dienste werden über 'well known' Ports
       (--&gt; feste, per RFC zugeordnete Portnummer) erreichbar. Sie stehen
       also für ein Protokoll, das über die Nummer direkt
       angesprochen wird
  <li>oder sie werden beim Verbindungsaufbau vereinbart und einem
       Server-Programm zugewiesen
  </ul>
<li>Die Portangabe ist nötig, wenn mehrere Serverprogramme auf dem
adressierten Rechner laufen.
<li>Die Portnummer steht im TCP-Header und ist 16 Bit groß. Theoretisch
können also bis zu 65535 TCP-Verbindungen auf einem Rechner mit einer einzigen
IP-Adresse aufgebaut werden.
<li>Portnummern werden oft auch bei der Konfiguration von Internet-Clients
als Parameter gefordert.
<li>Die Client-Prozesse verwenden normalerweise freie Portnummern, die vom
lokalen Betriebssystem zugewiesen werden (Portnummer &gt; 1024).
</ul>
<p>
<center><img src="images/ports.png"></center>
<p>
Die "well known" Portnummern (0 bis 1023), die weltweit eindeutig adressiert
werden müssen, werden durch die IANA (Internet Assigned Numbers Authority)
vergeben. Einige Beispiele für TCP-Ports (UDP verwendet eine andere
Zuordnung):
<p>
<table border=1 cellspacing=0 cellpadding=3 align=center>
<tr><th>Portnummer</th><th>Protokoll</th></tr>
<tr><td>20</td><td>FTP (Daten)</td></tr>
<tr><td>21</td><td>FTP (Befehle)</td></tr>
<tr><td>22</td><td>Secure Shell</td></tr>
<tr><td>23</td><td>Telnet</td></tr>
<tr><td>25</td><td>SMTP</td></tr>
<tr><td>53</td><td>DNS-Server</td></tr>
<tr><td>80</td><td>HTTP (Proxy-Server)</td></tr>
<tr><td>110</td><td>POP3</td></tr>
<tr><td>143</td><td>IMAP</td></tr>
</table>
<p>
Eine vollständige Portliste erhält man bei
<a href="http://www.isi.edu/in-notes/iana/assignments/port-numbers" target=_blank>http://www.isi.edu/in-notes/iana/assignments/port-numbers</a>.
<p>
<table border=1 cellspacing=0 cellpadding=3 align=center width="80%">
 <tr>
  <td valign=top>Well Known Ports</td>
  <td valign=top>1&nbsp;&nbsp;1023</td>
  <td valign=top>Diese Ports sind fest einer Anwendung oder einem Protokoll
  zugeordnet. Die feste Zuordnung ermöglicht eine einfachere Konfiguration.
  Die Verwaltung dieser Ports übernimmt die Internet Assigned Numbers Authority
  (IANA).</td>
 </tr>
 <tr>
  <td valign=top>Registered Ports</td>
  <td valign=top>1024&nbsp;&nbsp;49151</td>
  <td valign=top>Diese Ports sind für diverse Dienste vorgesehen.</td>
 </tr>
 <tr>
  <td valign=top>Dynamically Allocated Ports</td>
  <td valign=top>49152&nbsp;&nbsp;65535</td>
  <td valign=top>Diese Ports werden dynamisch zugewiesen. Jeder Client kann
  diese Ports nutzen. Wenn ein Prozess einen Port benötigt, fordert er diesen
  bei seinem Host an.</td>
 </tr>
</table>
<p>
IP-Adresse und Portnummer definieren einen Kommunikationsendpunkt, der in der
TCP/IP-Welt "Socket" genannt wird.
Die Grenze zwischen der Anwendungsschicht und der Transportschicht ist in den meisten
Implementierungen zugleich die Grenze zwischen dem Betriebssystem und den
Anwendungsprogrammen. Im OSI-Modell ist diese Grenze in etwa die Grenze zwischen
den Schichten 4 und 5. Daher ordnet man IP meist ungefähr in die Ebene 3 und
TCP ungefähr in Ebene 4 des OSI-Modells ein. Da TCP/IP jedoch älter und
einfacher als das OSI-Modell ist, kann diese Einordnung nicht genau passen.
<P>

<H4>Port-Scans</H4>
Beim Scanning wird versucht, offene Ports eines Rechners zu ermitteln. Das ist
meist auch der erste Schritt eines Angreifers, der in einem Rechner eindringen will.
Deshalb dient ein Portscan auch dazu, die Sicherheit des eigenen Systems zu
überprüfen. Bei den Scanning-Methoden wurden Verfahren entwickelt, bei denen
versucht wird, den Scanvorgang auf dem gescannten Rechern unentdeckt zu lassen.
<UL>
<LI><I>TCP-Connect-Scan</I><BR>
Bei dieser Methode wird versucht, eine Verbindung zu einem Port auf
dem Zielrechner aufzubauen. Der Scanner läßt einen vollständigen
Dreiwege-Handshake zu, bevor er die Verbindung wieder unterbricht.
Diese Art der Scans ist allerdings sehr leicht zu entdecken und
kann auch leicht mit Hilfe von Firewalls abgeblockt werden.
<P>
<LI><I>TCP-SYN-Scan</I><BR>
Diese Methode wird oft als "Half-Open-Scan" bezeichnet. Der Scanner sendet
ein SYN-Packet an den Zielrechner, wie bei einem ganz normalen Verbindungsaufbau.
Wenn der Zielrechner mit einem RST antwortet, weiß der Scanner, daß dieser
Port geschlossen ist. Antwortet der Zielrechner jedoch mit einem SYN/ACK, handelt
es sich um einem offenen Port. In diesem Falle wird die Verbindung vom Scanner sofort
mit einem RST beendet. Diese Art des Scannens ist nicht ganz so leicht auf dem
Zielrechner zu entdecken wie der Connect Scan.
<P>

<LI><I>Stealth FIN-Scan</I><BR>
Stealth Scans sollen vom Zielrechner nicht entdeckt werden. Allerdings
gibt es Programme, die genau solche Scans entdecken. Beim "Stealth FIN Scan"
wird nur ein Packet mit einem FIN-Flag, ohne begleitendes ACK-Flag gesendet.
Diese Art von Paket ist unzulässig. Wenn der Port offen ist, wird das Paket des
Scanners vom Zielrechner ignoriert. Wenn der Port geschlossen ist, antwortet der
Zielrechner mit einem RST-Paket.
<P>
<LI><I>Stealth Xmastree-Scan</I><BR>
Bei diesem Scan sind die FIN-, URG-, und PUSH-Flags alle gemeinsam gesetzt. Auch
dieses Paket ist unzulässig. Wenn der Port offen ist, wird das Paket des
Scanners vom Zielrechner ignoriert. Wenn der Port geschlossen ist, antwortet der
Zielrechner mit einem RST-Paket.
<P>
<LI><I>Stealth Null-Scan</I><BR>
Bei diesem Scan sind alle Flags auf Null gesetzt. Alles Weitere wie oben.
<P>
<LI><I>ACK-Scan</I><BR>
Dieser Scan wird verwendet, um Firewalls zu testen ob sie mit "stateful inspection"
arbeiten (z.B. Firewall 1) oder ob es sich nur um einfache Packetfilter handelt,
die eingehende SYN Packete verwerfen. Der ACK-Scan sendet
ein Packet mit gesetztem ACK-Flag und zufälliger Sequenznummer an die Ports.
Wenn das Paket von der Firewall durchgelassen wird, sendet der Server ein RST, da
das Paket nicht zuzuordnen ist. In diesem Fall wird der Port als "ungefiltert"
klassifiziert. Wenn die Firewall den Status einer Verbindung überwacht, wird
das Paket ohne eine Antwort vom Zielrechner abgewiesen oder es wird dem
Scanner mit einer ICMP Destination unreachable Nachricht geantwortet.
</UL>
<P>

<H2><A NAME="8.7">PPP</A></H2>
Das <B>Point to Point Protocol</B> (PPP) findet gegenwärtig vielfachen
Einsatz. Es arbeitet mit drei Teilprotokollen:
<UL>
<LI> Das Data Link Layer Protocol ermöglicht die Übertragung
(Encapsulation) von Datagrammen über serielle Verbindungen mit Hilfe von HDLC.
<LI> Das Link Control Protocol (LCP) steuert Aufbau, Konfiguration und
Test der Verbindung.
<LI> Das Network Control Protocol (NCP) ermöglicht die Übertragung
von Konfigurationsdaten für verschiedene Protokolle der Vermittlungsschicht.
</UL>
PPP ist geeignet für den simultanen Einsatz verschiedener Protokolle der
Vermittlungsschicht, es ist also ein so genanntes "Multi-Protokoll-Protokoll".
Es ist ein zustandsorientiertes Protokoll:
<P>
<CENTER><img src="images/ppp2.png"></CENTER>
<P>
PPP ist ein verbindungsorientiertes Protokoll und unterscheidet drei Phasen
Verbindungsaufbau, Datenübertragung und Verbindungsabbau. Die Realisierung
dieser Phasen unter Berücksichtigung der Teilprotokolle von PPP zeigt
das Bild unten.
<OL>
<LI> Der anrufende PPP-Knoten sendet LCP-Rahmen zum Aufbau und zur Konfiguration der
Verbindung (Data Link). Die LCP-Pakete verfügen über ein Feld mit
Konfigurations-Optionen. Zu diesen Optionen zählen beispielsweise die
Maximum Transmission Unit (MTU). Hierbei handelt es sich um die Angabe, ob
bestimmte PPP-Felder komprimiert werden, oder das Link Authentication Protocol
(LAP).
<LI>In einer optionalen Phase wird überprüft, ob die Qualität der
Verbindung für den Aufbau einer Übertragung der Pakete der Vermittlungsschicht
ausreicht.
<LI> Es folgt eine Authentifizierungsphase.
<LI> Der anrufende PPP-Knoten sendet NCP-Rahmen zur Auswahl und Konfiguration des zu
übertragenden Protokolls der Vermittlungsschicht.
<LI> Nun können die Daten übertragen werden.
<LI> Die Verbindung bleibt bis zur Beendigung durch LCP- oder NCP-Rahmen bestehen
oder bis ein externes Ereignis auftritt. Zu diesen kann eine Unterbrechung durch den
Anwender, der Abbruch der Übertragung oder der Ablauf eines "Inactivity Timers"
zählen.
</OL>
<P>
<CENTER><img src="images/ppp3.png"></CENTER>
<P>
PPP unterstützt verschiedene Protokolle zur Authentifizierung. Dabei realisieren
alle Protokolle nur eine einseitige Authentifizierung. Dies bedeutet, dass sich der
anrufende Knoten bzw. dessen Anwender authentifizieren und der angerufene Knoten diese
Authentifizierung überprüfen muss. Der angerufene Knoten authentifiziert
sich durch seine Verfügbarkeit unter dieser physischen Verbindung. Die
wichtigsten Authentifizierungsprotokolle sind:
<UL>
<LI>das Password Authentication Protocol (PAP),
<LI>das Shiva Password Authentication Protocol(SPAP),
<LI>das Challenge Handshake Authentication Protocol (CHAP) sowie
<LI>eine Variante des CHAP, das Microsoft-CHAP (MS-CHAP), das in zwei Versionen vorliegt.
</UL>
<P>
Die Authentifzierungsprotokolle mit der größten Verbreitung sind PAP und CHAP. Auch
MS-CHAPv2 ist recht häufig anzutreffen. Die meisten ISPs fragen beim einwählenden Host
zunächst CHAP an.
<P>
<B>PAP</B> unterstützt ein so genanntes Zwei-Wege-Handshake. Die Kombination "Username/Password"
wird vom anrufenden Knoten so lange übertragen, bis die Authentifizierung bestätigt
oder abgelehnt wird. Im Falle der Ablehnung wird die Verbindung abgebrochen. Dieses Vorgehen
bietet allerdings nur eine geringe Sicherheit: Das Passwort wird unverschlüsselt übertragen.
Es ist eine beliebige Anzahl von Wiederholungen möglich. Und schließlich werden
Häufigkeit und Geschwindigkeit der Versuche vom anrufenden Knoten bestimmt, so dass ein
Brute-Force-Angriff möglich wird.
<P>
<B>CHAP</B> bietet ein erhöhtes Sicherheitsniveau im Rahmen eines so genannten Drei-Wege-Handshakes.
Der anrufende Knoten darf erst die Authentifizierung beginnen, wenn er vom angerufenen Knoten dazu
aufgefordert wurde. Auf diese Weise werden Häufigkeit und Geschwindigkeit der Versuche vom
angerufenen Knoten bestimmt. Zusätzlich wird die Kombination "Username/Password" nur im Rahmen
einer Ein-Wege-Hash-Funktion (Message Digest 5, MD5) übertragen. Die Überprüfung
kann also nicht nur beim Verbindungsaufbau, sondern auch periodisch während der Verbindung
stattfinden.
<P>

<H2><A NAME="8.8">IP Next Generation</A></H2>
von Heiko Holtkamp (<a href="http://www.rvs.uni-bielefeld.de/~heiko/tcpip/tcpip.pdf">
http://www.rvs.uni-bielefeld.de/~heiko/tcpip/tcpip.pdf</a>)
<P>
Das rasche (exponentielle Wachstum) des Internet zwingt dazu, das Internet Protokoll
in der Version 4 (IPv4) durch ein Nachfolgeprotokoll (IPv6 Internet Protocol
Version 6) zu ersetzen.
<P>
Vinton Cerf (der 'Vater' des Internet) bezeichnet in einem Interview mit der Zeitschrift
c't das Internet <I>"(...) als die wichtigste Infrastruktur für alle Arten
von Kommunikation."</I>. Auf die Frage, wie man sich die neuen Kommunikationsdienste
des Internet vorstellen könne, antwortete Cerf:
<P>
<BLOCKQUOTE>
<I>"Am spannendsten finde ich es, die ganzen Haushaltsgeräte ans Netz anzuschließen. Ich denke
dabei nicht nur daran, daß der Kühlschrank sich in Zukunft mit der Heizung austauscht, ob es in der
Küche zu warm ist. Stromgesellschaften könnten beispielsweise Geräte wie Geschirrspülmaschinen
kontrollieren und ihnen Strom genau dann zur Verfügung stellen, wenn gerade keine Spitzennachfrage herrscht.
Derartige Anwendungen hängen allerdings davon ab, daß sie zu einem erschwinglichen Preis angeboten werden.
Das ist nicht unbedingt ferne Zukunftsmusik; die Programmierer müßten eigentlich nur damit anfangen,
endlich Software für intelligente Netzwerkanwendungen zu schreiben. Und natürlich muß die Sicherheit
derartiger Systeme garantiert sein. Schließlich möchte ich nicht, daß die Nachbarkinder mein Haus
programmieren!"</I>
</BLOCKQUOTE>
<P>
Auf die Internet Protokolle kommen in der nächsten Zeit also völlig neue
Anforderungen zu.
<P>

<H2>Classless InterDomain Routing - CIDR</H2>
<P>Der Verknappung der Internet-Adressen durch die ständig steigende Benutzerzahl
wird zunächst versucht, mit dem <I>Classless Inter-Domain Routing (CIDR)</I>
entgegen zu wirken.
Durch die Vergabe von Internet-Adressen in Klassen (A,B,C,...) wird eine große Anzahl
von Adressen verschwendet. Hierbei stellt sich vor allem die Klasse B als Problem dar.
Viele Firmen nehmen ein Netz der Klasse B für sich in Anspruch, da ein Klasse A Netz
mit bis zu 16 Mio. Hosts selbst für eine sehr große Firma überdimensioniert
scheint, ein Netz der Klasse C mit 254 Hosts aber zu klein.
<P>
Ein größerer Host-Bereich für Netze der Klasse C (z. B. 10 Bit, 1022 Hosts
pro Netz) hätte das Problem der knapper werdenden IP-Adressen vermutlich gemildert.
Ein anderes Problem wäre dadurch allerdings entstanden: die Einträge der
Routing-Tabellen hätten sich um ein Vielfaches vermehrt.
<P>
Ein anderes Konzept ist das Classless Inter-Domain Routing (RFC 1519): die verbleibenden
Netze der Klasse C werden in Blöcken variabler Größe zugewiesen. Werden
beispielsweise 2000 Adressen benötigt, so können einfach acht aufeinanderfolgende
Netze der Klasse C vergeben werden. Zusätzlich werden die verbliebenen Klasse-C-Adressen
restriktiver und strukturierter vergeben (RFC 1519). Die Welt ist dabei in vier Zonen
aufgeteilt, von denen jede einen Teil des verbliebenen Klasse C Adreßraums erhält:
<P>
<CENTER>
<TABLE BORDER=1 CELLPADDING=4 BGCOLOR="#CCCCCC">
<TR><TD>194.0.0.0 - 195.255.255.255</TD><TD>Europa</TD></TR>
<TR><TD>198.0.0.0 - 199.255.255.255</TD><TD>Nordamerika</TD></TR>
<TR><TD>200.0.0.0 - 201.255.255.255</TD><TD>Mittel- und Südamerika</TD></TR>
<TR><TD>202.0.0.0 - 203.255.255.255</TD><TD>Asien und pazifischer Raum</TD></TR>
<TR><TD>204.0.0.0 - 223.255.255.255</TD><TD>Reserviert für zukünftige Nutzung</TD></TR>
</TABLE>
</CENTER>
<P>
Jede der Zonen erhält dadurch in etwa 32 Millionen Adressen zugewiesen. Vorteil bei
diesem Vorgehen ist, daß die Adressen einer Region im Prinzip zu einem Eintrag in
den Routing-Tabellen komprimiert worden sind und jeder Router, der eine Adresse
außerhalb seiner Region zugesandt bekommt diese getrost ignorieren darf.
<P>

<H3>Internet Protokoll Version 6 - IPv6 (IP Next Generation, IPnG)</H3>
Der vorrangige Grund für eine Änderung des IP-Protokolls ist auf den
begrenzten Adreßraum und das Anwachsen der Routing-Tabellen zurückzuführen.
CIDR schafft hier zwar wieder etwas Luft, dennoch ist klar absehbar, daß auch
diese Maßnahme nicht ausreicht, um die Verknappung der Adressen für eine
längere Zeit in den Griff zu bekommen. Weitere Gründe für eine
Änderung des IP-Protokolls sind die neuen Anforderungen an das Internet, denen IPv4
nicht gewachsen ist. Streaming-Verfahren wie Real-Audio oder Video-on-Demand erfordern
das Festlegen eines Mindestdurchsatzes, der nicht unterschritten werden darf. Bei IPv4
kann so ein "Quality of Service" jedoch nicht definiert - und damit auch nicht
sichergestellt - werden. Die <I>IETF (Internet Engineering Task Force)</I> begann
deshalb 1990 mit der Arbeit an einer neuen Version von IP. Die wesentlichen Ziele des
Projekts sind:
<UL>
<LI>Unterstützung von Milliarden von Hosts, auch bei ineffizienter Nutzung des Adreßraums
<LI>Reduzierung des Umfangs der Routing-Tabellen
<LI>Vereinfachung des Protokolls, damit die Router Pakete schneller abwickeln können
<LI>Höhere Sicherheit (Authentifikation und Datenschutz) als das heutige IP
<LI>Mehr Gewicht auf Dienstarten, insbesondere für Echtzeitanwendungen
<LI>Unterstützung von Multicasting durch die Möglichkeit, den Umfang zu definieren
<LI>Möglichkeit für Hosts, ohne Adreßänderung auf Reise zu gehen (Laptop)
<LI>Möglichkeit für das Protokoll, sich zukünftig weiterzuentwickeln
<LI>Unterstützung der alten und neuen Protokolle in Koexistenz für Jahre
</UL>
Im Dezember 1993 forderte die IETF mit RFC 1550 die Internet-Gemeinde dazu auf,
Vorschläge für ein neues Internet Protokoll zu machen. Auf die Anfrage
wurde eine Vielzahl von Vorschlägen eingereicht. Diese reichten von nur
geringfügigen Änderungen am bestehenden IPv4 bis zur vollständigen
Ablösung durch ein neues Protokoll. Aus diesen Vorschlägen wurde von der
IETF das <I>Simple Internet Protocol Plus (SIPP)</I> als Grundlage für die neue
IP-Version ausgewählt.
<P>
Als die Entwickler mit den Arbeiten an der neuen Version des Internet Protokolls begannen,
wurde ein Name für das Projekt bzw. das neue Protokoll benötigt. Angeregt durch
die Fernsehserie "Star Trek - Next Generation", wurde als Arbeitsname <I>IP - Next
Generation (IPnG)</I> gewählt. Schließlich bekam das neue IP eine offizielle
Versionsnummer zugewiesen: IP Version 6 oder kurz IPv6. Die Protokollnummer 5 (IPv5)
wurde bereits für ein experimentelles Protokoll verwendet.
<P>

<H3>Die Merkmale von IPv6</H3>
Viele der Merkmale von IPv4 bleiben in IPv6 erhalten. Trotzdem ist IPv6 im allgemeinen
nicht mit IPv4 kompatibel, wohl aber zu den darüberliegenden Internet-Protokollen,
insbesondere den Protokollen der Transportschicht (TCP, UDP). Die wesentlichen Merkmale
von IPv6 sind:
<UL>
<LI><B>Adreßgröße:</B> Statt bisher 32 Bit stehen nun 128 Bit
für die Adressen bereit. Theoretisch lassen sich damit 2<SUP>128</SUP>
= 3.4*10<SUP>38</SUP> Adressen vergeben.
<LI><B>Header-Format:</B> Der IPv6-Header wurde vollständig geändert. Der
Header enthält nur sieben statt bisher 13 Felder. Diese Änderung ermöglicht
die schneller Verarbeitung der Pakete im Router. Im Gegensatz zu IPv4 gibt es bei IPv6
nicht mehr nur einen Header, sondern mehrere Header. Ein Datengramm besteht
aus einem Basis-Header, sowie einem oder mehreren Zusatz-Headern, gefolgt von den Nutzdaten.
<P>
<img src="images/ipv6dgram.png">
<P>
<LI><B>Erweiterte Unterstützung von Optionen und Erweiterungen:</B> Die Erweiterung
der Optionen ist notwendig geworden, da einige der bei IPv4 notwendige Felder nun optional
sind. Darüber hinaus unterscheidet sich auch die Art, wie die Optionen dargestellt
werden. Für Router wird es damit einfacher, Optionen, die nicht für
sie bestimmt sind, zu überspringen.
<LI><B>Dienstarten:</B> IPv6 legt mehr Gewicht auf die Unterstützung von
Dienstarten. Damit kommt IPv6 den Forderungen nach einer verbesserten Unterstützung
der Übertragung von Video- und Audiodaten entgegen, z. B. durch eine Option zur
Echtzeitübertragung.
<LI><B>Sicherheit:</B> IPv6 beinhaltet nun im Protokoll selbst Mechanismen zur sicheren
Datenübertragung. Wichtige neue Merkmale von IPv6 sind hier Authentifikation,
Datenintegrität und Datenverlässlichkeit.
<LI><B>Erweiterbarkeit:</B> IPv6 ist ein erweiterbares Protokoll. Bei der Spezifikation
des Protokolls wurde nicht versucht, alle möglichen Einsatzfelder für das
Protokoll in die Spezifikation zu integrieren. Über Erweiterungs-Header kann das
Protokoll erweitert werden.
</UL>
<P>

<H3>Aufbau des IPv6-Basis-Headers</H3>
Im IPv6 wird im Vergleich zum IPv4 auf eine Checksumme verzichtet,
um den Routern die aufwendige Überprüfung - und damit Rechenzeit
- zu ersparen. Ein Übertragungsfehler muss deshalb in den höheren
Schichten erkannt werden. Der Paketkopf ist durch die Verschlankung
nur doppelt so groß, wie ein IPv4-Header.
<P>
<center><img src="images/ipv6mainheader.png"></center>
<P>
<DL>
<DT><B>Version:</B></DT>
<DD>
Mit dem Feld <I>Version</I> können Router überprüfen, um welche
Version des Protokolls es sich handelt. Für ein IPv6-Datengramm ist dieses Feld
immer 6 und für ein IPv4-Datengramm dementsprechend immer 4. Mit diesem Feld
ist es möglich für eine lange Zeit die unterschiedlichen Protokollversionen
IPv4 und IPv6 nebeneinander zu verwenden. Über die Prüfung des Feldes
Version können die Daten an das jeweils richtige "Verarbeitungsprogramm"
weitergeleitet werden.
<DT><B>Priority:</B></DT>
<DD>
Durch das Feld <I>Priority</I> (oder <I>Traffic Class</I>) kann angegeben
werden, ob ein Paket bevorzugt behandelt werden muß. Dies ist für die
Anpassung des Protokolls an die neuen Real Time Anwendungen nötig geworden.
Damit können zum Beispiel Videodaten den E-Maildaten vorgezogen werden. Bei
einem Router unter Last besteht damit die Möglichkeit der Flusskontrolle.
Pakete mit kleinerer Priorität werden verworfen und müssen wiederholt
werden.Mit den vier Bit lassen sich 16 Prioritäten angeben, wovon
1 bis 7 für "Non Real Time"- und 8 bis 15 für "Real Time"-Anwendungen
reserviert sind. Die Zahl Null gibt an, dass die Priorität des
Verkehrs nicht charakterisiert ist.
<DT><B>Flow Label</B></DT>
<DD>
Mit Hilfe des Feldes <I>Flow Label</I> können Eigenschaften des Datenflusses
zwischen Sender und Empfänger definiert werden. Das Flow
Label selbst ist nur eine Zufallszahl. Die Eigenschaften müssen
durch spezielle Protokolle oder durch den Hop-by-Hop-Header in den Routern
eingestellt werden. Eine Anwendung ist zum Beispiel, daß die Pakete eines
Flusses immer den gleichen Weg im Netz nehmen. Durch Speichern der Informationen
für das jeweilige Flow-Label, muß der Router bestimmte Berechnungen nur
für das erste Paket ausführen, und kann danach für alle Folgepakete
die Resultate verwenden. Erst die Einführung des Flow Labels ermöglicht
die Einführung von Quality-of-Service-Parametern im IP-Verkehr.
<DT><B>Payload Length</B></DT>
<DD>
Das Feld <I>Payload Length (Nutzdatenlänge)</I> gibt an, wie viele Bytes
dem IPv6-Basis-Header folgen, der IPv6-Basis-Header ist ausgeschlossen. Die
Erweiterungs-Header werden bei der Berechnung der Nutzdatenlänge mit einbezogen.
Das entsprechende Feld wird in der Protokollversion 4 mit <I>Total Length</I> bezeichnet.
Allerdings bezieht IPv4 den 20 Byte großen Header auch in die Berechnung ein,
wodurch die Bezeichnung "total length" gerechtfertigt ist.
<DT><B>Next Header</B></DT>
<DD>
Das Feld <I>Next Header</I> gibt an, welcher Erweiterungs-Header dem IPv6-Basis-Header
folgt. Jeder folgende Erweiterungs-Header beinhaltet ebenfalls ein Feld Next Header, das
auf den nachfolgenden Header verweist. Beim letzten IPv6-Header, gibt das Feld an, welches
Transportprotokoll (z.B. TCP oder UDP) folgt.
<DT><B>Hop Limit</B></DT>
<DD>
Im Feld <I>Hop Limit</I> wird festgelegt, wie lange ein Paket überleben darf.
Der Wert des Feldes wird von jedem Router vermindert. Ein Datengramm wird verworfen,
wenn das Feld den Wert Null hat. IPv4 verwendete hierzu das Feld <I>Time to Live</I>.
Die Bezeichnung bringt mehr Klarheit, da schon in IPv4 die Anzahl Hops gezählt
und nicht die Zeit gemessen wurde.
<DT><B>Source Address, Destination Address</B></DT>
<DD>
Die beiden Felder für <I>Quell-</I> und <I>Zieladresse</I> dienen zur
Identifizierung des Senders und Empfängers eines IP-Datengramms. Bei IPv6 sind
die Adressen vier mal so groß wie IPv4: 128 Bit statt 32 Bit.
</DL>
<P>
Das Feld <I>Length (Internet Header Length - IHL)</I> von IPv4 ist nicht
mehr vorhanden, da der IPv6-Basis-Header eine feste Länge von 40 Byte hat.
Das Feld <I>Protocol</I> wird durch das Feld <I>Next Header</I> ersetzt.
Alle Felder die bisher zur Fragmentierung eines IP-Datengramms benötigt wurden
(<I>Identification, Flags, Fragment Offset</I>), sind im IPv6-Basis-Header nicht
mehr vorhanden, da die Fragmentierung in IPv6 gegenüber IPv4 anders gehandhabt
wird. Alle IPv6-kompatiblen Hosts und Router müssen Pakete mit einer Größe
von 1280 Byte unterstützen. Empfängt ein Router ein zu großes Paket, so
führt er keine Fragmentierung mehr durch, sondern sendet eine Nachricht an den
Absender des Pakets zurück, in der er den sendenden Host anweist, alle weiteren
Pakete zu diesem Ziel aufzuteilen. Es wird also vom Hosts erwartet, daß er
von vornherein eine passende Paketgröße wählt. Die Steuerung der
Fragmentierung erfolgt bei IPv6 über den <I>Fragment Header</I>.
Das Feld <I>Checksum</I> ist nicht mehr vorhanden.
<P>

<H3>Erweiterungs-Header im IPv6</H3>
Bei IPv6 muß nicht mehr der ganze optionale Teil des Headers von allen Routern
verarbeitet werden, womit wiederum Rechenzeit eingespart werden kann. Diese
optionalen Header werden miteinander verkettet. Jeder optionale Header beinhaltet
die Identifikation des folgenden Header. Es besteht auch die Möglichkeit
selber Optionen zu definieren.
<P>
Derzeit sind sechs Erweiterungs-Header definiert. Alle Erweiterungs-Header sind optional.
Werden mehrere Erweiterungs-Header verwendet, so ist es erforderlich, sie in einer
festen Reihenfolge anzugeben.
<P>
<CENTER>
<TABLE ALIGN=CENTER WIDTH="80%" BORDER=1 CELLPADDING=4>
<TR>
<TH>Header</TD>
<TH>Beschreibung</TD>
</TR>
<TR>
<TD VALIGN=TOP>IPv6-Basis-Header</TD>
<TD VALIGN=TOP>Zwingend erforderlicher IPv6-Basis-Header</TD>
</TR>
<TR>
<TD VALIGN=TOP>Optionen für Teilstrecken<BR>
(Hop-by-Hop Options Header)</TD>
<TD VALIGN=TOP>Dies ist der einzige optionale Header, der von jedem Router bearbeitet
werden muß. Bis jetzt ist nur die "Jumbo Payload Option" definiert, in der die
Länge eines Paketes angegeben werden kann, das länger als 64 KByte ist.
</TD>
</TR>
<TR>
<TD VALIGN=TOP>Optionen für Ziele<BR>
(Destination Options Header)</TD>
<TD VALIGN=TOP>Zusätzliche Informationen für das Ziel</TD>
</TR>
<TR>
<TD VALIGN=TOP>Routing<BR>
(Routing Header)</TD>
<TD VALIGN=TOP>Definition einer vollständigen oder teilweisen Route.
Er wird für das Source-Routing in IPv6 verwendet.</TD>
</TR>
<TR>
<TD VALIGN=TOP>Fragmentierung<BR>
(Fragment Header)</TD>
<TD VALIGN=TOP>In IPv6 wird, wie oben beschrieben, die Fragmentierung nur
noch End to End gemacht. Die Fragmentierinformationen werden in diesem
optionalen Header abgelegt.
</TD>
</TR>
<TR>
<TD VALIGN=TOP>Authentifikation<BR>
(Authentication Header)</TD>
<TD VALIGN=TOP>Er dient der digitalen Signatur von Paketen, um die Quelle eindeutig
feststellen zu können.
</TD>
</TR>
<TR>
<TD VALIGN=TOP>Verschlüsselte Sicherheitsdaten<BR>
(Encapsulating Security Payload Header)</TD>
<TD VALIGN=TOP>Informationen über den verschlüsselten Inhalt.</TD>
</TR>
<TR>
<TD VALIGN=TOP>Optionen für Ziele<BR>
(Destination Options Header)</TD>
<TD VALIGN=TOP>Zusätzliche Informationen für das Ziel (für
Optionen, die nur vom endgültigen Ziel des Paketes verarbeitet werden
müssen).</TD>
</TR>
<TR>
<TD VALIGN=TOP>Header der höheren Schichten<BR>
(Upper Layer Header)</TD>
<TD VALIGN=TOP>Header der höheren Protokollschichten (TCP, UDP, ...)</TD>
</TR>
</TABLE>
</CENTER>
<P>

<H3>IPv6-Adressen</H3>
Die IPv6-Adressen sind zwar von 32 Bit auf 128 Bit angewachsen, trotzdem sind die
grundsätzlichen Konzepte gleich geblieben. Die Adresse wird normalerweise
Sedezimal (Hexadezimal, Basis 16) notiert und hat die allgemeine Form
<PRE>
  xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx:xxxx
</PRE>
Sie ist damit recht länglich. Um die Schreibweise zu vereinfachen,
wurden einige Regeln eingeführt:
<UL>
<LI>Führende Nullen<BR>
Die führenden Nullen können mit Nullen oder Doppelpunkten
zusammengefasst werden.
<PRE>
1234:0000:0000:0000:0000:0000:0000:1234
                  --&gt;
         1234:0:0:0:0:0:0:1234
                  --&gt;
               1234::1234
</PRE>
<P>
<LI>IPv4 kompatible Adressen haben die Form:
<PRE>
0:0:0:0:0:0:C206:AFFE
      oder
::C206:AFFE
</PRE>
Um die Lesbarkeit zu erhöhen kann man auch eine gemischt Form verwenden:
<PRE>
::196.6.175.254
</PRE>
<P>
<LI>IPv4 gemappte IPv6 Adressen haben die Form:
<PRE>
::FFFF:C206:A17E
</PRE>
<LI>Die Loopback Adresse ist neu (anstelle 127.0.0.1):
<PRE>
::1
</PRE>
</UL>
<P>

In IPv4 wurden die Adressen anfänglich in die bekannten Klassen eingeteilt.
Ein weiteres Problem bei den IPv4 Adressen ist, daß die Router keine
Hierarchie in den Adressen erkennen können. Auch IPv6 ist in der allgemeinen
Form unstrukturiert, es kann aber durch definierte Präfixe strukturiert werden.
Die allgemein strukturiert Adresse sieht danach wie folgt aus:
<P>
<center><img src="images/ipv6strukt.png"></center>
<P>
Die Strukturierung erlaubt die Einteilung der Adresse in Adresstypen. Jeder Präfix
identifiziert somit einen Adresstyp. Die bereits definierten Adresstypen und die
zugehörigen Präfixe sind:
<P>
<center>
<table border=1 cellpadding=4>
<tr><th>Adresstyp</th><th>Präfix (binär)</th></tr>
<tr>
<td valign=TOP>Reserviert für IPv4 und Loopback</td><td align=right valign=TOP>0000 0000</td></tr>
<tr><td valign=TOP> NSAP-Adressen </td><td align=right valign=TOP> 0000 001 </td></tr>
<tr><td valign=TOP> IPX-Adressen </td><td align=right valign=TOP> 0000 010 </td></tr>
<tr><td valign=TOP> Anbieterbasierte Unicast-Adresse </td><td align=right valign=TOP> 010 </td></tr>
<tr><td valign=TOP> Reserviert für geografische Unicast-Adresse </td><td align=right valign=TOP> 100 </td></tr>
<tr><td valign=TOP> Zusammenfassbare globale Adressen </td><td align=right valign=TOP> 001 </td></tr>
<tr><td valign=TOP> Standortlokale Adresse </td><td align=right valign=TOP> 1111 1110 11 </td></tr>
<tr><td valign=TOP> Multicast-Adresse </td><td align=right valign=TOP> 1111 1111 </td></tr>
</table>
</center>
<P>
Wie man in der Tabelle erkennen kann, werden die Adressen grob in die Typen
<I>Unicast</I>, <I>Multicast</I> und <I>Anycast</I> eingeteilt, deren Eigenschaften
nachfolgend kurz erklärt werden sollen.
<UL>
<LI><I>Unicast</I><BR>
Als Unicast-Adressen bezeichnet man die Adressen, die für Punkt-zu-Punkt-Verbindungen
verwendet werden. Sie werden in verschiedene Gruppen eingeteilt:
  <UL>
  <LI>Geographisch basierte Unicast-Adresse<BR>
  Für diese Adressen wurde erst der Adressbereich und der Präfix
  reserviert. Die Idee ist, dass ein hierarchisches Routing aufgrund der
  geographischen Lage - ähnlich wie beim Telefon - möglich sein
  soll.
  <LI>Anbieterbasierte Unicast-Adressen<BR>
  Dieser Adresstyp erlaubt ein hierarchisches Routing aufgrund der Adressräume
  der Anbieter. Diese Adressen werden von einem Register über ein großes
  Gebiet verwaltet. Diese Register geben die Adressen an die Anbieter weiter,
  welche ihrerseits Adressen weitergeben können. Somit ergibt sich
  eine Adress-Struktur, die wie folgt aussieht:
  <P>
  <img src="images/ipv6unicast.png">
  <p>
  Die Einführung von nationalen Registern ergibt eine Aufteilung
  der Anbieter- und Subscriber-ID in National-Register-, Anbieter- und
  Subscriber-ID.
  </UL>
<LI><I>Linklokale und standortlokale Adressen</I><BR>
Diese Adressen werden für die TCP/IP-Dienste innerhalb eines Unternehmens
genutzt. Die Linklokalen Adressen werden nicht in das Internet geroutet und haben
den folgenden Aufbau:
<P>
<img src="images/ipv6loc1.png">
<P>
Im Gegensatz dazu stehen die standortlokalen Adressen, die nur innerhalb eines
Subnetzes gültig sind und deshalb von keinem Router behandelt werden.
<P>
<img src="images/ipv6loc2.png">
<p>
<LI><I>Multicast-Adressen</I><BR>
In IPv4 wird das Rundsenden eines Paketes an mehrere Stationen durch das IGMP
(Internet Group Management Protokoll) realisiert. In IPv6 ist das Prinzip
übernommen, aber ein eigener Adresstyp definiert worden. IGMP entfällt
somit gänzlich. Das Paket für Multicast-Meldungen sieht wie folgt aus:
<P>
<img src="images/ipv6multicast.png">
<P>
Das Flag gibt an, ob die Gruppen ID temporär, oder von der IANA
zugewiesen ist. Der Scope gibt den Gültigkeitsbereich der Multicast
Adresse an. Dieser reicht vom nodelokalen bis zum globalen Bereich.
<LI><I>Anycast Adressen</I><BR>
Diese Adressen sind neu definiert worden. es können mehrere Rechner zu einer
Gruppe zusammengefasst werden und sie sind dann unter einer einzigen Adresse erreichbar.
Damit ist beispielsweise eine Lastverteilung möglich: der Rechner, der am wenigsten
belastet ist, behandelt das Paket. Die Adresse hat die folgende Struktur:
<p>
<img src="images/ipv6anycast.png">
<P>
</UL>

<H3>Sicherheit</H3>
Der Bedarf an digitalen Unterschriften oder elektronischen Zahlungsmöglichkeiten
steigt ständig. Deshalb stand bei der Spezifikation von IPv6 die Sicherheit von
Anfang an im Mittelpunkt. Für die Sicherheitsfunktionen von IPv6 ist eine
spezielle Arbeitsgruppe "IPSec" zuständig.<BR>
In IPv6 wurden Sicherheitsmechanismen für die Authentisierung und Verschlüsselung
auf IP Ebene spezifiziert. Die Verschlüsselungsfunktionen definieren Verfahren,
die das Mitlesen durch Unbefugte verhindern. Es gibt zwei unterschiedliche Ansätze.
Bei der ersten Variante werden alle Nutzdaten (Payload) verschlüsselt. Der Header
bleibt normal lesbar. Bei der anderen Variante ist es möglich, den Header
ebenfalls zu verschlüsseln. Das codierte Paket wird in ein anderes IPv6-Packet
verpackt und zu einem fixen Ziel befördert ("IP-Tunnel"). Am Ziel wird das Paket
wieder entschlüsselt und über das sichere interne Netz übertragen.
<p>
Authentisierungsmechanismen liefern den Beweis auf Unverfälschtheit
der Nachricht und identifiziert den Absender (Digitale Unterschrift).
Hier werden verschiedene kryptographische Verfahren eingesetzt.
Die Verfahren für die Verschlüsselung und die Authentisierung
können auch getrennt angewandt werden.
Verwaltung und Verteilung der Schlüssel wird nicht von IPv6 gelöst.
Das Standardverfahren für den IPv6-Authentisierungsmechanismus
ist MD5 mit 128 Bit langen Schlüsseln. IPv6 schreibt keinen
Verschlüsselungsmechanismus vor, jedes System im Internet
muß jedoch den DES mit CBD (Cipher Block Chaining) unterstützen.
<P>

<H2><A NAME="8.9">Domain Name System (DNS)</A></H2>
Es hat sich ziemlich früh herausgestellt, daß menschliche
Benutzer die numerischen IP-Adressen nicht benutzen wollen,
sondern aussagekräftige und vor allem merkbare Namen
bevorzugen. Außerdem ist es ein großer Nachteil der IP-
Adressen, daß aus ihnen keinerlei geographische Information
zu entnehmen ist. Man sieht einer Zieladresse nicht an, ob
sie in Australien oder im Nebenzimmer lokalisiert ist,
außer man kennt zufällig die gewählten Zahlen. Es wurde
daher das Domain Name System entwickelt, das den Aufbau von
Rechnernamen regelt. Es ordnet jedem (weltweit eindeutigen)
Namen eine IP-Adresse zu. Dabei gibt es einige Varianten.
Eine Maschine mit einer IP-Adresse kann mehrere Funktionen
haben und daher auch mehrere Namen, die auf diese
Funktionen hinweisen. Genauso kann eine Maschine (z. B. ein
Router) viele IP-Adressen haben aber nur einen Namen.
<P>
Beim "Domain-Name-System"  (oder kurz: DNS) handelt es sich um einen
Dienst, der zu einem Rechnernamen die zugehörige IP-Nummer
liefert und umgekehrt. Das ist in etwa mit der Funktionsweise
einer Telefonauskunft vergleichbar:
Der Kunde ruft bei einer bestimmten Telefonnummer an und fragt
nach der Rufnummer eines Teilnehmers. Nachdem er Name und Wohnort
der gesuchten Person durchgegeben hat, erhält er als Antwort die gewünschte
Nummer aus einem Verzeichnis. Genauso läuft eine DNS-Abfrage ab.
<center>
<p>
<img src="images/auskunft.png">
<p>
</center>
Gibt ein Benutzer in seinem Webbrowser zum Beispiel die Adresse
<p>
<TT>
http://www.VereinGegenZuLangeDomainnamenEV.de
</TT>
<p>

ein, dann sorgt ein Teil der Netzwerk-Software
auf seinem lokalen Rechner dafür, daß ein Name-Server nach der IP-Adresse
des Rechners <TT>www.vereingegenzulangedomainnamenev.de</TT> gefragt wird.
Dieser Softwareteil wird als <i> Resolver</i> bezeichnet und entspricht in
obigem Beispiel dem Kunden, der die Auskunft anruft.
Welche IP-Adresse dieser Server hat, muß dem Klientenrechner natürlich
bekannt sein, genauso wie der Kunde eine einzige Telefonnummer wissen muß,
nämlich die der Auskunft selbst.

Auf der Serverseite arbeitet eine Software, die als <i>"Domain-Name-Server"</i> oder
kurz <i>"Name-Server"</i> bezeichnet wird und anhand einer Datenbank
(<i>"Zone-File"</i>) die passende IP-Nummer zum Rechnernamen liefert, oder
einen anderen Name-Server fragt, wenn die Adresse unbekannt ist.
<center>
<p>
<img src="images/dns-simple.png">
<p>
</center>

DNS ist ein typisches Beispiel für einen Verzeichnisdienst. Seine Aufgaben sind:

<ul>
  <li>Strukturierung der Namen. (Domänen-Konzept)
  <li>Zuteilung und Verwaltung von Namen.
  <li>Auflösen von Namen (="Nachschlagen") in beide Richtungen (Name zu Adresse und Adresse zu Name)
  <li>Zwischenspeichern von Adressen (Caching)
  <li>Einteilung der Daten in hierarchische Ebenen
  <li>Verteilung der Daten auf verschiedene Knoten
  <li>Bereitstellung von Redundanz (Secondary-DNS, Caching-Only-Server)
</ul>
Damit das DNS funktioniert muß es Instanzen geben, die
Namen in IP-Adressen und IP-Adressen in Namen umwandeln
('auflösen') können. Diese Instanzen sind durch Programme
realisiert, die an größeren Maschinen ständig (meist im
Hintergrund) im Betrieb sind und 'Nameserver' heißen. Jeder Rechner, der an das
Internet angeschlossen wird, muß die Adresse eines oder
mehrerer Nameserver wissen, damit die Anwendungen auf
diesem Rechner mit Namen benutzt werden können. Die
Nameserver sind für bestimmte Bereiche, sogenannte
'domains' oder 'Zonen', zuständig (Institute, Organisationen, Regionen)
und haben Kontakt zu anderen Nameservern, so daß jeder Name
aufgelöst werden kann.
<p>

<h3>Domänen-Konzept</h3>
In den Anfängen des ARPA-Nets, aus  dem das Internet entstand, wurde die
Namensauflösung über eine einzige Datei erledigt. Jeder Rechner
kopierte sich Nachts per FTP diese Datei von einem  Master-Server auf die
lokale Platte. Dieses Konzept funktioniert natürlich nur, solange die
Anzahl der Namen nicht groß ist. Die benötigte Bandbreite ist proportinal
zum Quadrat der beteiligten Rechner.
<p>
B ~ N<sup>2</sup>
<p>
Als Relikt aus dieser Zeit kennt fast jedes Betriebssystem auch heute noch eine
Hosts-Datei, in der für kleine Netze Rechner/Nummern-Zuordnungen
abgelegt werden könen. (Bei Windows im Verzeichnis <TT>\WINDOWS\HOSTS</TT>,
bei Unix unter <TT>/etc/hosts</TT>, bei Novell unter
<TT>SYS:SYSTEM/ETC/HOSTS</TT>, etc.)

Die Syntax aller dieser Hosts-Dateien ist einfach. Für jeden Rechner gibt
es eine eigene Zeile mit dem Inhalt:
<pre>
IP-Nummer	Hostname Alias Alias ....
</pre>
Zum Beispiel:
<pre>
192.168.112.1    chef dumpfbacke
192.168.112.2    Snow-White
192.168.112.3    Doc
192.168.112.4    Happy
192.168.112.5    Bashful
192.168.112.6    Sneezy
192.168.112.7    Sleepy
192.168.112.7    Grumpy
192.168.112.8    Dopey
</pre>
Der Begriff <i>Alias</i> läßt sich dabei am besten durch <i>"Spitzname"</i>
(oder englisch <i>Nickname</i>) ersetzen; also ein weiterer Name für ein und den
selben Rechner.
<p>
Bei einer kleinen Menge von Rechnern ist die Namensverwaltung mit einer Datei noch
möglich; für einen so großen und ständig wechselnden Verbund wie
das Internet ist sie aber nicht geeignet. Hier ist eine dezentrale Verwaltung mit
einem eigens darauf abgestimmten Namensraum nötig.
<p>
Der Namensraum des DNS ist in sogenannte Domänen eingeteilt. Die Domänen sind
hierarchisch als Baum angeordnet,

<p>
<center>
<img src="images/dns-baum.png">
</center>
<p>
Ausgehend von der Wurzel (=<i>Root</i>) des Baumes ist der Namensraum in sogenannte
"<i>Toplevel-Domains</i>" eingeteilt. Man unterscheidet dabei zwischen zwei verschiedenen
Klassen von Toplevel-Domänen: Den generischen und den länderspezifischen.
<p>
<center>
<table border=1 cellpadding=5>
<tr><th colspan=2>Toplevel-Domänen</th></tr>
<tr><th valign="top">generisch bzw.gesponsert</th>
<td>
<table border=0 cellpadding=3 cellspacing=0 width="70%">
<tr><td width="20%">com</td><td>Kommerzielle Organisationen</td></tr>
<tr><td>edu</td><td>(education) Schulen und Hochschulen</td></tr>
<tr><td>gov</td><td>(government) Regierungsinstitutionen</td></tr>
<tr><td>mil</td><td>militärische Einrichtungen</td></tr>
<tr><td>net</td><td>Netzwerk betreffende Organisationen</td></tr>
<tr><td>org</td><td>Nichtkommerzielle Organisationen</td></tr>
<tr><td>int</td><td>Internationale Organisationen</td></tr>
<tr><td><P>arpa</td><td>und das alte ARPA-Net bzw. Rückwärts-Auflösung
von Adressen</td></tr>
</table>
<P>
Ende 2000 sind neue TLDs von der ICANN genehmigt worden:
<P>
<table border=0 cellpadding=3 cellspacing=0 width="70%">
<tr><td width="20%">aero</td><td>Luftfahrtindustrie</td></tr>
<tr><td>coop</td><td>Firmen-Kooperationen</td></tr>
<tr><td>museum</td><td>Museen</td></tr>
<tr><td>pro</td><td>Ärzte, Rechtsanwälte und andere Freiberufler</td></tr>
<tr><td>biz</td><td>Business (frei für alle)</td></tr>
<tr><td>info</td><td>Informationsanbieter (frei für alle)</td></tr>
<tr><td>asia</td><td>Anbieter aus Asien</td></tr>
<tr><td>jobs</td><td>Job-Angebote</td></tr>
<tr><td>travel</td><td>Reise-Angebote</td></tr>
<tr><td>cat</td><td>Förderung der katalanischen Sprache</td></tr>
<tr><td>mobi</td><td>WWW fü Smartphones/Tablets</td></tr>
<tr><td>tel</td><td>Darstellung von Kontaktdaten (Telnic Ltd.)</td></tr>
<tr><td>name</td><td>Private Homepages (frei für alle, aber nur
dreistufige Domains der Form &lt;Vorname&gt;.&lt;Name&gt;.name)</td></tr>
</table>
</tr>
<tr>
<th valign="top">länderspezifisch</th>
<td>Jeweils ein Länderkürzel für jedes Land, z.B.:<br>
<table border=0 cellpadding=5 cellspacing=0 width="70%">
<tr><td width="20%">by</td><td>Weissrussland</td></tr>
<tr><td>de</td><td>Deutschland</td></tr>
<tr><td>at</td><td>Östereich</td></tr>
<tr><td>fr</td><td>Frankreich</td></tr>
<tr><td>to</td><td>Tonga</td></tr>
<tr><td>tv</td><td>Tuvalu</td></tr>
</table>
</td>
</tr>
<tr>
<th valign="top">Pseudo- und reservierte Domänen</th>
<td>
<table border=0 cellpadding=3 cellspacing=0 width="70%">
<tr><td width="20%"><b>Pseudo</b></td><td></td></tr>
<tr><td width="20%">bitnet</td><td>BITNET (historisch)</td></tr>
<tr><td>csnet</td><td>für Mail-Weiterleitung ins CSNET (historisch)</td></tr>
<tr><td>local</td><td>verwendbar für private (Heim-)Domänen</td></tr>
<tr><td>root</td><td>vrsn-end-of-zone-marker-dummy-record.root</td></tr>
<tr><td>uucp</td><td>"Unix to Unix Copy" (historisch)</td></tr>
<tr><td>onion</td><td>Tor-Network intern</td></tr>
<tr><td>exit</td><td>Tor-Network intern</td></tr>
<tr><td><br><b>Reserviert</b></td><td></td></tr>
<tr><td>example</td><td>für lokalen Test/Dokumentation</td></tr>
<tr><td>invalid</td><td>für lokalen Test/Dokumentation</td></tr>
<tr><td>localhost</td><td>für lokalen Test/Dokumentation</td></tr>
<tr><td>test</td><td>für lokalen Test/Dokumentation</td></tr>
</table>
</td>
</tr>
</table>
</center>

<p>
Unterhalb der Toplevel-Domänen folgen Subdomänen, die wiederum Domänen
enthalten könen und schliesslich, als Blatt des Baumes, ein einzelner Rechner.
Der Name <TT>www.netzmafia.de</TT> ist also so zu verstehen. In der Toplevel-Domäne
<i>".de"</i> ist die Subdomain "<i>Netzmafia</i>" bekannt. Innerhalb der Subdomain
"<i>netzmafia</i>" gibt es einen Rechner namens "<i>www</i>". Analog zu unserem
Beispiel mit der Telefonauskunft, ist mit "de" das Land, mit "netzmafia" der Ort und
die Straße und mit "www" der Name eines Teilnehmers bestimmt. Die komplette Adresse
eines Rechners in der beschriebenen Notation, z.B. bezeichnet man (www.netzmafia.de</i>)
als FQDN (<i>Full-Qualified-Domain-Name</i>).
<p>
Für die Aufnahme einer Verbindung zwischen zwei Rechnern
muß in jedem Fall der Rechnername in eine zugehörige IP-
Adresse umgewandelt werden. Aus Sicherheitsaspekten ist es
manchmal wünschenswert, auch den umgekehrten Weg zu gehen,
nämlich zu einer sich meldenden Adresse den Namen und damit
die organisatorische Zugehörigkeit offenzulegen.
<P>

<H4>Komponenten des DNS</H4>
Insgesamt sind es drei Hauptkomponenten, aus denen sich das DNS zusammensetzt:
<OL>
<li> Der <B>Domain Name Space</B>, ein baumartig, hierarchisch strukturierter Namensraum
und die Resource Records. Das sind Datensätze, die den Knoten zugeordnet sind.
<li> <B>Name Server</B> sind Programme bzw. Rechner, die die Informationen über die
Struktur des Domain Name Space verwalten und aktualisieren. EinNameserver hat
normalerweise nur eine Teilsicht des Domain Name Space zu verwalten. Oft wird
auch der Rechner, auf dem das Nameserverprogramm läuft, als 'Nameserver' oder
'DNS-Server' bezeichnet.
<li> <B>Resolver</B> sind die Programme, die für den Client Anfragen an den
Nameserver stellen. Resolver sind einemNameserver zugeordnet; bei Anfragen, die er
nicht  beantworten kann (anderer Teilbereich des Domain Name Space). kann er aufgrund
von Referenzen andere Nameserver kontakten, um die Information zu erhalten.
</OL>
<P>
<center><img src="images/dns.png"></center>
<P>

Der <B>Nameserver</B> des DNS verwaltet also einzelne Zonen, die einen Knoten im DNS-Baum
und alle darunterliegenden Zweige beinhalten. Auf jeder Ebene des DNS-Baums kann es
Namesever geben, wobei jeder Nameserver seinen nächsthöheren und nächstniedrigeren Nachbarn
kennt. Aus Sicherheitsgründen gibt es für jede Zone in der Regel mindestens zwei Nameserver
(<I>primary</I> und <I>secondary</I>), wobei beide die gleiche Information halten.
Nameservereinträge können nicht nur die Zuordnung Rechnername - IP-Adresse enthalten,
sondern (neben anderem) auch weitere Namenseinträge für einen einzigen Rechner und
Angaben für Postverwaltungsrechner einer Domain (MX, mail exchange).
<P>
Basis des Nameservice bilden die "Root-Nameserver", die für die Top-Level-Domains
zuständig sind. Federführende Organistation ist hier die ICANN
(<i>=Internet Corporation for Assigned Names and Numbers </i>,
Adresse: <a href="http://www.icann.org">http://www.icann.org</a>). Gründung 1998.
ICANN beauftragt die Verwalter der Zone "." (Wurzel des DNS-Baumes) mit 13 Servern.
Bis auf die Server I (Stockholm), K (London) und  M (Tokio) stehen alle
Server in den USA.
<P>
<CENTER><img src="images/nameserver.png"></CENTER>
<P>
<TABLE BORDER=1 CELLPADDING=5 cellspacing=0 width="70%" align=center>
<TR><TH>Name</TH><TH>Typ</TH><TH>Betreiber</TH><TH>URL</TH></TR>
<TR><TD>a</TD><TD>com</TD><TD>InterNic</TD><TD>http://www.internic.org</TD></TR>
<TR><TD>b</TD><TD>edu</TD><TD>ISI</TD>     <TD>http://www.isi.edu</TD></TR>
<TR><TD>c</TD><TD>com</TD><TD>PSINet</TD>  <TD>http://www.psi.net</TD></TR>
<TR><TD>d</TD><TD>edu</TD><TD>UMD</TD>     <TD>http://www.umd.edu</TD></TR>
<TR><TD>e</TD><TD>usg</TD><TD>NASA</TD>    <TD>http://www.nasa.gov</TD></TR>
<TR><TD>f</TD><TD>com</TD><TD>ISC</TD>     <TD>http://www.isc.org</TD></TR>
<TR><TD>g</TD><TD>usg</TD><TD>DISA</TD>    <TD>http://nic.mil</TD></TR>
<TR><TD>h</TD><TD>usg</TD><TD>ARL</TD>     <TD>http://www.arl.mil</TD></TR>
<TR><TD>i</TD><TD>int</TD><TD>NordUnet</TD><TD>http://www.nordu.net</TD></TR>
<TR><TD>j</TD><TD>( &nbsp; )</TD> <TD>(TBD)</TD>   <TD>http://www.iana.org</TD></TR>
<TR><TD>k</TD><TD>int</TD><TD>RIPE</TD>    <TD>http://www.ripe.net</TD></TR>
<TR><TD>l</TD><TD>( &nbsp; )</TD> <TD>(TBD)</TD>   <TD>http://www.iana.org</TD></TR>
<TR><TD>m</TD><TD>int</TD><TD>WIDE</TD>    <TD>http://www.wide.ad.jp</TD></TR>
</TABLE>
<p>
Der Server A ist der primäre Server, alle anderen sind seine Secondaries.
Eine Liste dieser Root-Server muss jeder DNS-Server haben (Ausnahme: Cache-Only-Server).
Erzeugung der Liste mit dem Kommando:
<pre>
dig @rs.internic.net . ns > root.servers
</pre>
<p>
Die Namen, die im Internet verwendet werden müssen dabei einige Spezifikationen
erfüllen:
<ul>
<li>Die Länge eines Namensteiles (Domänen- oder Rechnername) darf maximal
63 Zeichen betragen.
<li> Die Gesamtlänge des Full-Qualified-Domain-Names darf 255 Zeichen nicht
überschreiten.
<li>Nur Buchstaben, Ziffern und "-" sind in den Namen zugelassen. Dabei muss jeder
Name mit einem Buchstaben oder einer Ziffer beginnen und enden. ("3bla-fasel" ist
zulässig, "3bla-" aber nicht.)
<li>Zwischen Groß- und Kleinschreibung wird nicht unterschieden.
<li>Die Domains "example.com" und "example.net" sind für Dokumentationen
vorgesehen und werden nicht vergeben. 
</ul>
Bei der Registrierung einer Domain unterhalb von ".de" gelten zusätzlich noch
folgende Regeln:
<ul>
<li>Der Domainname muß mindestens 3 Zeichen haben. Insgesamt gibt es in ".de"
noch 4 Domains mit nur 2 Buchstaben, die aus Besitzstands-Gründen beibehalten werden.
<li>Wegen eines weit verbreiteten Fehlers in der Named-Server-Software sind Domains
mit den gleichen Namen wie Toplevel-Einträge verboten. (Also z.B.: "at.de") Das ist
in RFC 1535 näher beschrieben.
<li>KFZ-Kennzeichen können nicht registriert werden.
</ul>
<p>
<center>
<img src="images/domains_simple.png">
</center>
<p>
Ein wichtiger Bestandteil des DNS-Konzeptes ist die Aufteilung der benötigten Datenbank
auf viele verschiedene Rechner. Da das Gesamtsystem voll funktionsfähig bleiben
muß, auch wenn ein Server ausgefallen ist, wird die Datenhaltung mit Hilfe von
Zuständigkeiten gelöst: Zu jeder Domain gibt es mindestens einen zugehörigen
Server, der verantwortlich die darin enthaltenen Subdomains oder Rechner verwaltet, oder
die Verwaltung an einen weiteren Server weiterdelegiert. Am Stamm des DNS-Baumes sitzen
dazu die "<i>Root-Server</i>", die alle Einträge ihrer jeweiligen Domain kennen.
Das heißt, daß der Root-Nameserver der Domäne ".de" einen Eintrag für
den Named-Server der Domain "netzmafia.de" besitzt. Dieser Server hat wieder eine Liste
der in "netzmafia.de" enthaltenen Rechner und Subdomains.
<p>
Die Frage eines Clients nach der IP-Nummern eines Rechners wird wie folgt abgewickelt:

<p>
<center>
<img src="images/dns-ablauf.png">
</center>
<p>

<ol>
<li>Der Client-Rechner "grumpy.zwerge.org" stellt die DNS-Anfrage nach "www.netzmafia.de" an seinen zuständigen DNS-Server. Dessen IP-Nummer muss dem Client bekannt sein.
<li>Kennt der Nameserver der Domain "zwerge.org" die Antwort nicht, so erkundigt er sich beim Root-Nameserver nach der Adresse des Nameservers von ".de"
<li>Der Root-Nameserver antwortet dem zuständigen DNS-Server der Domain "zwerge.org" mit der Adresse des Nameservers von ".de"
<li>Der Nameserver der Domain "zwerge.org" erkundigt sich beim Nameserver von ".de" nach der Adresse des Nameservers von "netzmafia.de".
<li>Der Nameserver von ".de" antwortet dem zuständigen DNS-Server der Domain "zwerge.org" mit der Adresse des Nameservers von "netzmafia.de"
<li>Der Nameserver der Domain "zwerge.org" erkundigt sich beim Nameserver von "netzmafia.de" nach der Adresse des Rechners "www.netzmafia.de".
<li>Der Nameserver von "netzmafia.de" antwortet dem zuständigen DNS-Server der Domain "zwerge.org" mit der Adresse des Rechners von "www.netzmafia.de".
<li>Der DNS-Server von "zwerge.org" liefert die IP-Nummer an den anfragenden Client. Damit ist die DNS-Abfrage abgehandelt.
</ol>
<P>

<H3>DNS-Typen</H3>

Man unterscheidet folgende DNS-Typen
<ul>
<li>Cache-Only
  <ul>
    <li>Besitzt keine eigenen Tabellen mit Rechnernamen (Zone-Files).
    <li>Alle Anfragen werden an einen übergeordneten Server weitergegeben.
    <li>Adressen werden zwischengespeichert.
    <li>Zweck: Z.B. Entlastung einer Providerleitung
    <li>Sehr einfach einzurichten.
  </ul>
<li>Secondary-DNS
  <ul>
    <li>Besitzt eigene Tabellen, die er vom Primary-DNS kopiert.
    <li>Die Tabellen können aber nicht verändert werden.
    <li>Zweck: Lastteilung, Backup
    <li>Einfach einzurichten.
  </ul>
<li>Primary-DNS
  <ul>
    <li>Besitzt eigene Tabellen für eine oder mehrere Zonen.
    <li>Tabellen können lokal verändert werden.
    <li>Server ist "<i>authoritative</i>" für seine Zone.
    <li>Relativ hoher Aufwand für Einrichtung und Pflege.
  </ul>
</ul>
<p>


<H3>DNS Resource Records</H3>
Im Standardfall generiert ein DNS-Server seine interne Datenbank
aus einer Textdatei, der sogenannten "Zonen-Datei". Damit er
funktioniert, müssen bestimmte Einträge korrekt eingetragen
worden sein. An dieser Stelle sollen nur ein paar grundlegende
Eigenschaften der wichtigsten Typen von Resource Records betrachtet
werden. Es gibt verschiedene Record-Typen:
<ul>
<li>SOA-Records (Source of Authority) enthalten die technischen Angaben für
die gesamte Zone sowie einige Steuerdaten für die Zusammenarbeit der
Nameserver untereinander. SOA-Records sind weiter unten genauer erklärt.
<li>NS-Records (Name Server) verweisen auf die Nameserver, die für eine Zone
authoritativ sind. Auf den eigenen Namen zeigende NS-Records dienen der
Plausibilitätsprüfung; NS-Records für eine Subdomain weisen darauf
hin, dass die Informationen für die Subdomain auf einem anderen
Nameserver zu finden sind (Delegation).
<li>A-Records (Address) verknüpfen einen Domainnamen mit einer IP-Adresse.
Um IPv4- und IPv6-Adressen zu unterscheiden, wird seit einiger Zeit für
IPv4 der A-Record und für IPv6 der AAAA-Record verwendet.
<li>PTR-Records (Pointer) verknüpfen eine IP-Adresse "rückwärts"
mit einem Domainnamen.
<li>CNAME-Records Canonical Name) definieren einen Domainnamen als Alias für
einen anderen. Es gibt also für jedes System einen A-Record und ggf. noch beliebig
viele CNAME-Records.
<li>MX-Records (Mail Exchanger) definieren, bei welchen Rechnern Mail für eine
Domain eingeliefert werden soll. Auf diese Weise sind geneische Mailadressen wie
z.B. "plate@fhm.edu" möglich.
<li>TXT-Records (Text) enthalten beliebige alphanumerische Informationen zu
einem Domainnamen.
</ul>

<H4>Aufbau der Zonendatei</H4>
Beispiel des Primary DNS "<i>aella.serverzwerge.de</i>":
<pre>
; Zonendatei fuer die Domaene serverzwerge.de
;
$TTL 1D
@       in      SOA     aella.serverzwerge.de.  dnsadmin.aella.serverzwerge.de. (
                2002051505        ; Seriennummer
                10800   ; Refresh : 3 Stunden
                3600    ; Retry   : 1 Stunde
                604800  ; Expire  : 1 Woche
                86400)  ; Min. TTL: 1 Tag
                NS              aella.serverzwerge.de.
                MX              10 aella.serverzwerge.de.
                MX              50 mail.irgendeinprovider.de.

aella           A       10.23.200.100
snowwhite       A       10.23.200.17
doc             A       10.23.200.18
happy           A       10.23.200.19
bashful         A       10.23.200.20
sneezy          A       10.23.200.21
sleepy          A       10.23.200.22
grumpy          A       10.23.200.23
dopey           A       10.23.200.24
                HINFO   "Hexium 7.5" "Linux"

beispiel        CNAME   aella
</pre>

<h4>Der SOA-Record</h4>
Jede Zone muss einen SOA-Record (Start of Authority) enthalten. Dort
sind wichtige Informationen über die Zone abgelegt. Hier ein Beispiel:
</p>
<pre>
$TTL 1D
@       in      SOA     aella.serverzwerge.de.  dnsadmin.aella.serverzwerge.de. (
                2002051505        ; Seriennummer
                10800   ; Refresh : 3 Stunden
                3600    ; Retry   : 1 Stunde
                604800  ; Expire  : 1 Woche
                86400)  ; Min. TTL: 1 Tag
</pre>
Das Semikolon leitet Kommentare ein, die natürlich nicht vorhanden
sein müssen.
<ul>
<li>Das erste Feld im SOA-Record benennt den primary master server.
Dies ist der Server, der die endgültige Autorität über den Inhalt der
Zone ist. Dort ist das Zonefile selbst abgelegt.
<li>Das zweite Feld des SOA-Records nennt die Mailbox der für die Zone
verantwortlichen Person. Das @-Zeichen der E-Mail-Adresse  wird hier durch einen Punkt
ersetzt. Links vom @ stehende Punkte müssen als \. notiert werden, um eine
eindeutige Zuordnung für den Punkt zu erreichen, der für den @ steht.
<li>Die Seriennummer spielt eine wichtige Rolle im Zusammenspiel
zwischen Master-DNS und Slave-DNS: Slaves führen nur dann einen Zonentransfer
durch, wenn die vom Master übermittelte Seriennummer größer ist als
die der lokal gehaltenen Zone. Sie wird meist nach dem Schema yyyymmddnn gebildet:
yyyy = Jahr (4-stellig), mm = Monat (2-stellig), dd = Tag (2-stellig) und nn die
Viertelstunde (2-stellig) des aktuellen Tags.
<li>Der Refresh-Wert legt fest, wie häufig ein Slave beim Master
nachfragt, ob sich die Zone verändert hat.
<li>Der Retry-Wert legt fest, wie häufig ein Slave einen fehlgeschlagenen
Zonentransfer wiederholt, bis er aufgibt.
<li>Der Expire-Wert legt fest, wie lange ein Slave seine Kopie einer
Zone noch als gültig ansieht, wenn er den Master nicht erreichen kann.
<li>Der Minimum-TTL-Wert legt fest, wie lange eine negative Antwort vom
Client zwischengespeichert werden darf. Er ist einer der beiden
wichtigsten Timer in einer Zonendatei (TTL = Time To Live).
<li>Der Eintrag in der $TTL-Zeile oberhalb des SOA-Records  legt fest,
welche Lebensdauer die Resource Records des Zonefiles in den Caches nicht
authoritativer Nameserver haben sollen.
</ul>
Um die Last auf den für eine Zone authoritativen Nameservern zu
verringern, speichern die von den Internetbenutzern verwendeten
Forwarder die Auskünfte, die sie von den authoritativen Nameservern
erhalten haben, für eine bestimmte Zeit zwischen. Der für die Zone
zuständige Administrator kann das Caching der Forwarder in manchen
Grenzen beeinflussen.
<p>
Wird eine Nameserver-Anfrage positiv beantwortet, übermittelt der
authoritative Nameserver zusammen mit dem angefragten Resource Record
die gewünschte Lebenszeit des Eintrags in Form der TTL. Ist im
Zonefile für den Resource Record keine TTL angegeben, so übermittelt
der authoritative Nameserver den mit $TTL im Zonefile gesetzten
Defaultwert.
Der Forwarder übermittelt die Antwort weiter an die Quelle der Anfrage
und speichert die Antwort für die übermittelte Zeitdauer zwischen, so
dass weitere Anfragen nach dem gleichen Resource Record innerhalb
dieser Zeitdauer ohne erneuten Zugriff auf den authoritativen Server
beantwortet werden können.
<p>
Bevor man zeitkritische Änderungen an einer Zone vornimmt (z.B. Umzug
eines Web- oder Mailservers auf eine andere IP-Adresse), ist zu
empfehlen, zuerst einen oder beide TTL-Werte herunterzusetzen. Dies
sollte mindestens einen TTL-Zeitraum vor der eigentlichen Änderung
geschehen, damit die kürzere TTL sich herumgesprochen hat. Nachdem die
Änderung erfolgreich durchgeführt wurde, kann die TTL wieder
heraufgesetzt werden.
<p>
<h4>Der MX-Record</h4>
Nimmt eine Domain am E-Mailverkehr teil, so wird einer oder mehrere MX-Records
in die Zone eingetragen. MX-Records haben zusätzlich zu ihrem Ziel eine
Prioritätsangabe. soll eine E-Mail an die Domain zugestellt werden,
versucht der absendende Mailserver zuerst den MX-Record niedrigster Priorität.
Kann er die E-Mail dort nicht ausliefern, versucht er der Reihe nach die
MX-Records höherer Priorität.
<p>
Gibt es für einen Domainnamen keinen MX-Record, sondern nur einen
A-Record, wird die Mail an diesen zugestellt. Dieses Verhalten ist
historisch bedingt und nicht mehr sinnvoll. Trotzdem wird es
immer noch so gehandhabt. Soll eine Domain nicht am E-Mailverkehr
teilnehmen, so ist es sinnvoll, einen MX-Record auf ein System zu
setzen, das für den Domainnamen eingehende E-Mail mit einem
permanenten Fehler ablehnt.
<p>

<h2><A NAME="8.10">Zero Configuration Networking</A></h2>
Nicht nur Computer, sondern immer mehr andere Komponenten müssen an das 
lokale Netz angeschlossen werden. Gleichzeitig gibt es gerade bei der 
Heimvernetzung mehr und mehr User ohne jegiche Kenntnisse über IP-Adressen,
Netzmaske, Gatway-Adresse usw. Gibt es im LAN einen DHCP-Server, kann der 
die Aufgabe übernehmen und die Clients holen sich von dort ihre
Daten. Als DHCP-Server arbeitet heute schon jeder DSL-Router und auch
manche WLAN-Access-Points können DHCP. 
<p>
Für LANs ohne DHCP-Server gibt es auch eine recht einfache Lösung zum
automatischen Konfigurieren der Netzwerkadressen. Bei IPv4 ist der Block
169.254.0.0/16 für die so genannten <b>Link Local Addresses</b> (IPv4LL)
reserviert, bei IPv6 ist es der Adressbereich fe80::/10 und das
Verfahren nennt sich <b>Stateless Automatic Autoconfiguration</b> (SLAAC) 
(siehe auch RFCs 3927 und 4862) bzw. <b>Automatic Private IP Adressing</b> 
(APIPA). Um an eine IP-Adresse zu kommen, wählt sich das Gerät eine 
zufällige Adresse aus diesem Bereich unter Zuhilfenahme seiner MAC-Adresse 
zusammen mit einem Zufallsgenerator. Dann stellt es durch ARP-Tests sicher, dass 
diese nicht bereits vergeben ist. Auf diese Weise können sich mehrere 
Geräte zu einem Ad-Hoc-Netz vereinigen.  
Die Netzmaske bei IPv4 lautet demnach 255.255.0.0, wobei die ersten und 
letzten 256 Adressen nicht verwendet werden dürfen.
<p>
Jedes Gerät macht seine so erworbene Adresse allen anderen per
ARP-Announcement im Abstand von zwei Sekunden bekannt. Hierbei verwendet
er als Absender- und Empfänger-IP die eben erworbene Adresse. Das Gerät muss 
aber weiterhin auf Adresskonflikte achten, die durch andere Rechner verursacht 
werden. Dies erkennt er, wenn ARP-Pakete mit seiner Adresse als Absenderadresse
von anderen Teilnehmern eintreffen. Hat das Gerät offene TCP-Verbindungen
und wurden noch keine kollidierenden ARP-Pakete empfangen (nur ein ARP-Probe),
sendet es ein klarstellendes ARP-Announcement. In allen anderen Fällen wird 
es sich eine neue Adresse berechnen.
<p>
Damit sind zwar alle Rechner eine IP-Adresse, aber noch keinen aussagekräftigen 
Namen. Für einige Geräte einen DNS-Server aufzusetzen wäre overkill. Abhilfe
schafft hier der Multicast DNS (MDNS, <A href="http://www.multicastdns.org">
www.multicastdns.org</a>). Er arbeitet ähnlich wie der "nbormale" DNS, nur
eben über Multicast. Jedes Gerät hat DNS-Records gespeichert und tritt der 
Multicast-Gruppe bei. Zur Namensauflösung schickt ein Gerät seine Anfrage
an die IPv4-Multicastadresse 224.0.0.251 (bei IPv6: ff02::fb). Ein Rechner mit
dem passenden Eintrag liefert dann die Antwort. Bei MDNS haben alle Systeme
die Top-Level-Domain ".local".
<p>
Es gibt sogar noch eine Erweiterung, DNS Service Discovery (DNS-SD, <A 
href="http://www.dns-sd.org">www.dns-sd.org</a>). Mittels DNS-SD werden 
Informationen über angebotene Dienste unter Verwendung der bestehenden 
DNS-Typen wie SRV, TXT oder PTR publiziert. Alle diese Möglichkeiten sind
unter <b>Zeroconf Netwirking</b> spezifiziert (<a href="http://www.zeroconf.org">
www.zeroconf.org</a>). Bei Apple ist die Implementierung unter dem Namen
"Bonjour" erfolgt und auch für Windows-Rechner erhältlich, die Open-Source-Variante 
heißt "Avahi" (<a href="http://www.avahi.org">www.avahi.org</a>).
<p>


<H2><A NAME="8.11">Netzwerkkonfiguration am Beispiel Linux</A></H2>
Eigentlich ist es egal, welches Betriebssystem als Beispiel genommen wird -
die Netzkonfiguration ist in etwa immer gleich. Auch viele der unten
erwähnten Dateien finden sich z. B. bei Windows. Linux dient
deshalb als Beispiel, weil man hier nicht nur irgendwelche Fenster anklickt,
sondern sehen kann, wie mit ein paar Kommandos das Netzwerkinterface eingebunden
wird und welche Effekte auf welche Art und Weise erzielt werden.
Die wichtigsten Dateien, Bezeichnungen und Anwendungen:
<p><ul>
<li><tt>/etc/HOSTNAME</tt> oder <tt>/etc/hostname</tt>
<li><tt>/etc/hosts</tt>
<li><tt>/etc/networks</tt>
<li><tt>/etc/host.conf</tt>
<li><tt>/etc/resolv.conf</tt>
<li><tt>/etc/nsswitch.conf</tt>
<li><b>ifconfig</b>
<li><b>route</b>
<li><b>ip</b>
<li><b>netstat</b>
<li><b>ping</b>
<li><b>traceroute</b>
</ul>

Die Netzwerkkonfiguration läuft im Normalbetrieb immer automatisch beim
Systemstart ab. Init-Scripts übernehmen die Konfiguration der
Schnittstellen, das Anlegen der Routen und vieles mehr. Trotzdem ist das
Wissen um die manuelle Konfiguration wichtig, erstens für Problemlösungen
und zweitens, weil damit auf die Schnelle auch eine Umkonfiguration von
Netzwerkkarten oder ein experimenteller Aufbau möglich ist.
<P>

Auf den (Hardware-)Treiber des Netzwerk-Interface wird aus diesem Grund nicht
eingegangen. Um festzustellen, ob überhaupt ein Treiber geladen wurde,
genügt das Kommando
<pre>
dmesg | more
</pre>
das alle Boot-Meldungen auflistet. Darin findet man auch die Meldungen zur
Netzwerkkarte, z.B.:
<pre>
...

8139cp 10/100 PCI Ethernet driver v0.0.6 (Nov 19, 2001)
8139cp: pci dev 00:0f.0 (id 10ec:8139 rev 10) is not an 8139C+ compatible chip
8139cp: Try the "8139too" driver instead.
8139too Fast Ethernet driver 0.9.24
PCI: Found IRQ 9 for device 00:0f.0
eth0: RealTek RTL8139 Fast Ethernet at 0xe081af00, 00:00:e8:76:2f:ea, IRQ 9
eth0:  Identified 8139 chip type 'RTL-8139A'

...
</pre>
Aus dieser Meldung ist auch die MAC-Adresse des Netzwerk-Interface ablesbar
(im Beispiel: 00:00:e8:76:2f:ea).
<p>
Im Folgenden werden die wichtigsten Konfigurationsdateien für das Netz
besprochen, wobei viele der Dateien - eventuell leicht modifiziert oder
mit ähnlichem Nanen - auch bei Windows zu finden sind. Bei Linux
findet man diese Daten traditionsgemäß im Verzeichnis <i>/etc</i>.
<P>

<h3>Setzen des Hostnamens</h3>
Die Netzwerksoftware verläßen sich darauf, daß der Name der
Maschine einen sinnvollen Wert hat. Er wird im Normalfall während
des Boot-Vorgangs mit dem Befehl <i>hostname</i> gesetzt. Um den
Hostnamen auf name zu setzen, geben Sie folgendes ein:
<pre>
hostname <i>name</i>
</pre>
Es ist üblich, nur den Host-Namen ohne jede Domain-Angabe zu verwenden.
<p>

<H3>/etc/hosts</H3>
In dieser Datei werden die Systeme des Netzwerks mit ihrem Systemnamen und
die dazu gehörenden Internet-Adressen aufgelistet.
Auch, wenn man im normalen Betrieb DNS einsetzt, sollte man einen Teil der
Rechnernamen in <i>/etc/hosts</i> eintragen. Oft möchte man nämlich auch während
des Bootens, wenn noch keine Netzwerkschnittstellen aktiv sind, symbolische
Namen verwenden.
<p>
Um sicherzustellen, daß alle Programme ausschließlich <i>/etc/hosts</i> verwenden,
um die Adresse eines Systems zu suchen, müssen Sie ggf. die Datei <i>/etc/nsswitch.conf</i>
editieren. Interessant ist die Zeile, die mit "hosts:" beginnt. Dort sollte "files dns" stehen,
was bedeutet, daß erst in der lokalen Datei <i>/etc/hosts</i> nachgesehen und dann erst
ein Nameserver kontaktiert wird. Typischerweise sieht die Datei im Ausschnitt so aus:
<pre>
# /etc/nsswitch.conf
#
...
hosts:          files dns
networks:       files
...

</pre>
Auf diese Datei wird weiter unten noch genauer eingegangen.
<P>
Die Datei <i>hosts</i> enthält einen Eintrag pro Zeile, bestehend aus der IP-Adresse,
dem Hostnamen und einer optionalen Liste von Aliasen für den Hostnamen. Die Felder
sind durch Leerzeichen oder Tabulatoren voneinander getrennt, und das Adreßfeld muß
in Spalte eins beginnen. Ein Doppelkreuz (#) leitet immer einen Kommentar ein.
<p>
Namen können entweder mit voller Domainangabe (Full Qualified Domain Name, FQDN)
oder relativ zur lokalen Domain sein. So ist das System sowohl unter seinem offiziellen
als auch unter dem kürzeren lokalen Namen bekannt. Man kann in der Datei auch die
Namen und IP-Adressen beliebiger anderer Rechner eintragen. Immer notwendig ist der
Eintrag für den Rechner selbst, "<tt>127.0.0.1 localhost</tt>",
denn sonst funktionieren gewisse Dienste (z.B. lpd) nicht.
<P>
Für alle folgenden Beispiele werden für die Rechnernamen Schneewittchen und die
sieben Zwerge (in der englischen Fassung von Walt Disney) verwendet. Damit keine
Kollision mit real existierenden Internet-Domains auftreten, kann man als
Domainnamen beispielsweise "<TT>zwerge.local</TT>" nehmen. Als Netz verwenden
wir das private B-Netz <tt>172.20.y.x</tt> - und davon sogar nur ein C-Subnetz,
<tt>172.20.20.x</tt>.
<p>
Das folgende Beispiel zeigt, wie die Datei <i>/etc/hosts</i> im Zwergenwald
aussehen könnte.
<pre>
#
# Hostdatei fuer Snowwhite and Friends
#
# IP            FQDN                        Aliase
127.0.0.1       localhost

# die Zwerge
10.27.210.17    snowwhite.zwerge.local    snowwhite
10.27.210.18    doc.zwerge.local          doc
10.27.210.19    happy.zwerge.local        happy
10.27.210.20    bashful.zwerge.local      bashful
10.27.210.21    sneezy.zwerge.local       sneezy
10.27.210.22    sleepy.zwerge.local       sleepy
10.27.210.23    grumpy.zwerge.local       grumpy
10.27.210.24    dopey.zwerge.local        dopey
...
</pre>

Nach der Internet-Adresse wird der "offizielle" Name des Systems angegeben, gefolgt von
Alias-Namen für dieses System. Wird als Argument für ein Netzwerk-Kommando ein Name
angegeben, so wird in dieser Datei die zugehörige Internet-Adresse ermittelt. Erst
über die Adresse wird eine Verbindung zum Zielsystem aufgebaut. Die Datei <TT>/etc/hosts</TT>
wird jedoch auch für den umgekehrten Vorgang benutzt. Mit einem
IP-Datagram wird nur die Internet-Adresse des sendenden Systems mitgeschickt. Soll
nun der zugehörige Name ermittelt werden, so geschieht dies ebenfalls mittels dieser
Datei. Das Resultat ist jedoch immer der "offizielle" Name des Systems. Deshalb ist
darauf zu achten, daß stets dieser Name verwendet werden muß, wenn ein Rechnername
in weiteren Konfigurationsdateien eingetragen wird.
<P>
Jetzt wissen Sie auch, daß der Eintrag "<tt>127.0.0.1 www.microsoft.com</tt>"
in der <i>/etc/hosts</I> beispielsweise zu komischen Effekten führen würde
(welchen?).
<p>

<H3>/etc/networks</H3>
Genau wie für IP-Adressen möchte man manchmal auch symbolische Namen für
Netzwerknummern verwenden. Aus diesem Grunde gibt es parallel zu <i>/etc/hosts</i> die
Datei <i>/etc/networks</i>, die Netzwerknamen auf Netzwerknummern abbildet. Diese
Datei wird nicht unbedingt benötigt.  Im Zwergenwald würden z.B. folgende
<i>networks</i>-Datei installiert:
<pre>
# /etc/networks
zwergenwald      172.20.20.0
</pre>
Beachten Sie, daß die Namen in <i>networks</i> nicht mit den Hostnamen in der Datei
<i>hosts</i> übereinstimmen und kollidieren, da manche Programme ansonsten seltsame
Resultate produzieren.
<p>

<H3>/etc/protocols</H3>
In dieser Datei sind die Protokollnamen und Protokollnummern der Transportprotokolle
eingetragen, die das System unterstützt. Dank dieser Datei kann man in vielen
Programmen den symbolischen Namen eines Protokolls anstelle der Nummer angeben.
Jede Zeile der Datei enthält den Namen des Transportprotokolls, die
Protokollnummer und den Aliasnamen des Protokolls, zum Beispiel:
<PRE>
ip      0     IP         # internet protocol, pseudo protocol number
icmp    1     ICMP       # internet control message protocol
igmp    2     IGMP       # Internet Group Management
ggp     3     GGP        # gateway-gateway protocol
ipencap 4     IP-ENCAP   # IP encapsulated in IP
tcp     6     TCP        # transmission control protocol
egp     8     EGP        # exterior gateway protocol
udp     17    UDP        # user datagram protocol
...
</PRE>
<P>

<H3>/etc/services</H3>
In dieser Datei werden die Namen von Netzwerkdiensten sowie die zugehörigen
Portnummern und Protokollnamen gespeichert Dank dieser Datei kann man in vielen
Programmen den symbolischen Namen eines Dienstes anstelle der Nummer angeben.
Beispiel:
<PRE>
...
ftp       21  tcp
ssh       22  tcp
telnet    23  tcp
smtp      25  tcp
whois     43  tcp
domain    53  tcp
gopher    70  tcp
finger    79  tcp
www       80  tcp
www       80  udp
...
</PRE>
<P>

<H3>/etc/nsswitch.conf</H3>
Diese Datei wird auch als "Resolver-Bibliothek" bezeichnet. Der Begriff <i>Resolver</i>
bezieht sich nicht auf ein spezielles Programm, sondern auf  eine Sammlung
von Funktionen, die bei Linux zur Standard-C-Bibliothek gehören. Ihre
wichtigsten Routinen sind <i>gethostbyname(2)</i> und <i>gethostbyaddr(2)</i>,
die alle zu einem Namen gehörenden IP-Adressen zurückliefern und umgekehrt.
über die Datei <i>/etc/nsswitch.conf</i> können Sie einstellen, ob Sie die
gewünschten Informationen in <i>/etc/hosts</i> nachschlagen, DNS-Server befragen
oder die <i>hosts</i>-Datenbank des Network Information Service (NIS) benutzen wollen.
<p>
In der Datei <i>/etc/nsswitch.conf</i> kann der Systemadministrator eine Vielzahl
verschiedener Datenbanken konfigurieren. Wir besprechen hier nur diejenigen
Optionen, die sich auf die Auflösung von Host- und Netzwerk-IP-Adressen beziehen.
Optionen in <i>/etc/nsswitch.conf</i> müssen in getrennten Zeilen erscheinen, wobei
die Argumente durch Leerzeichen oder Tabulatorzeichen voneinander getrennt sein
müssen. Ein Doppelkreuz (#) leitet einen Kommentar ein, der sich bis zum
Zeilenende erstreckt. Jede Zeile beschreibt einen bestimmten Dienst, z.B. die
Auflösung von Hostnamen. Das erste Feld jeder Zeile gibt den Namen der Datenbank
an und endet mit einem Doppelpunkt. Der Rest jeder Zeile enthält Optionen,
die die Art des Zugriffs auf die betreffende Datenbank regeln. Die folgenden
Optionen sind verfügbar:
<P>
<table border=1 cellpadding=3 cellspacing=0 width="80%">
<tr><td><tt>dns</tt></td><td>
Verwendet das Domain Name System (DNS) zur Auflösung der Adresse. Das macht
allerdings nur Sinn bei der Auflösung von Hostadressen, nicht von Netzadressen.
Der Mechanismus benutzt die Datei <i>/etc/resolv.conf</i>.
</td></tr>
<tr><td><tt>files</tt></td><td>
Durchsucht eine lokale Datei nach den Host- oder Netznamen und ihren zugehörigen
IP-Adressen. Diese Option verwendet die traditionellen Dateien <i>/etc/hosts</i>
und <i>/etc/networks</i>.
</td></tr>
<tr><td><tt>nis</tt> oder <tt>nisplus</tt></td><td>
Verwendet das Network Information System (NIS) zur Auflösung einer Host- oder
Netzadresse.
</td></tr>
</table>
<p>
In der Reihenfolge, in der die Dienste angegeben sind, werden sie auch abgefragt,
wenn ein Name aufgelöst werden soll. Anspruch genommen, in der sie aufgelistet sind.
Diese Liste befindet sich in der Datei <i>/etc/nsswitch.conf</i> in dem Abschnitt,
in dem die Beschreibung der Dienste erfolgt. Die Dienste werden von links nach rechts
abgefragt, und die Suche wird standardmäßig beendet, wenn ein Wert (oder Name)
erfolgreich aufgelöst wurde. Zum Beispiel:
<pre>
# /etc/nsswitch.conf
#
hosts:          dns files
networks:       files
</pre>
Dieses Beispiel veranlaßt das System, Hosts zuerst im DNS zu suchen und wenn dort
nichts gefunden wird, die Suche in der Datei <i>/etc/hosts</i> fortzusetzen. Um
Netzwerknamen aufzulösen, wird ausschließlich die Datei <i>/etc/networks</i>
benutzt.
<p>
Sie können das Suchverhalten noch genauer kontrollieren, indem Sie zusätzlich
Aktionen (action items) angeben, die festlegen, welche Aktion nach dem jeweils letzten
Namensauflösungsversuch durchgeführt werden soll. Auf diese Erweiterungen wird
an dieser Stelle nicht weiter eingegangen.
<p>

<H3>/etc/resolv.conf</H3>
Wenn Sie die Resolver-Bibliothek für die Verwendung von DNS konfigurieren,
müssen Sie ihr auch mitteilen, welche Server sie benutzen soll. Dafür
gibt es eine separate Datei namens <i>/etc/resolv.conf</i>. Fehlt diese Datei
oder ist sie leer, nimmt der Resolver an, daß sich der Name-Server auf
Ihrem lokalen Host befindet.
Um einen Name-Server auf Ihrem lokalen Host laufen zu lassen, müssen Sie
ihn separat einrichten. Normalerweise verwendet man einen bereits vorhandenen
Name-Server. Bei einer Dialup-Verbindung ins Internet wird für gewöhnlich der
Name-Server des Providers in der Datei <i>/etc/resolv.conf</i> eintragen.
<p>
Die wichtigste Option in <i>/etc/resolv.conf</i> ist daher <i>nameserver</i>, welche
die Adresse eines Name-Servers angibt. Wenn Sie die Option mehrmals angeben,
werden die Server in der angegebenen Reihenfolge verwendet. Deshalb sollten Sie
unbedingt den zuverlässigsten Server an erster Stelle eintragen. Wenn Sie
keinen Name-Server eintragen, nimmt der Resolver an, daß einer auf der lokalen
Maschine läuft. Gegenwärtig werden bis zu drei <i>nameserver</i>-Einträge
in <i>/etc/resolv.conf</i> unterstützt.
<p>
Zwei weitere Befehle, <i>domain</i> und <i>search</i>, geben Domainnamen an,
die der Resolver an einen Namen anhängt, wenn die zugehörige Adresse beim ersten
Versuch nicht gefunden wird. Mit <i>domain</i> können Sie eine Default-Domain
angeben, die immer dann angehängt werden soll, wenn ein Name nicht aufgelöst
werden konnte. Wird dem Resolver z.B. der Name "<i>sleepy</i>" übergeben, findet
dieser den Namen "<i>sleepy<b>.</b></i>" nicht im DNS, da es eine solche Top-Level-Domain
nicht gibt. Wird "<i>zwerge.local</i>" als Standarddomäne angegeben, wiederholt der
Resolver seine Anfrage und hängt diese Standarddomäne an den Hostnamen an.
Die Abfrage nach "<i>sleepy.zwerge.local</i>" ist nun erfolgreich (natürlich
nur, wenn es einen Nameserver gibt).
<p>
Mit der Option <i>search</i> kann eine Suchliste angegeben werden, gewissermaßen
eine Verallgemeinerung der <i>domain</i>-Anweisung. Während bei <i>domain</i>
nur eine einzelne Domain angeben werden darf, akzeptiert <i>search</i> eine
ganze Liste davon, deren Einträge alle der Reihe nach durchprobiert werden,
bis ein gültiger DNS-Eintrag gefunden wird. Die einzelnen Namen der Liste
müssen durch Leerzeichen oder Tabulatoren voneinander getrennt werden.
<p>
Die Befehle <i>search</i> und <i>domain</i> schließen einander aus und dürfen
höchstens einmal auftauchen. Wenn keiner der beiden Befehle angegeben ist, versucht
der Resolver, die Default-Domain mit Hilfe der Systemfunktion <i>getdomainname(2)</i>
aus dem lokalen Hostnamen zu raten. Hat der Hostname keinen Domain-Teil, wird als
Default-Domain die Root-Domain (<i>.</i>) angenommen.
<p>
Werfen Sie einen Blick auf die Datei <i>resolv.conf</i> des Zwergenwaldes:
<pre>
# /etc/resolv.conf
# Unsere Domain
domain         zwerge.local
#
# Wir benutzen "doc" als zentralen Name-Server:
nameserver     172.20.20.1
</pre>
Wenn Sie in dieser Konfiguration die Adresse von "<i>dopey</i>" suchen, wird der
Resolver erst versuchen, "<i>dopey<b>.</b></i>" nachzuschlagen, und wenn das
fehlschlägt, "<i>dopey.zwerge.local</i>".
<p>

<H3>Netzwerk-Konfiguration für IP</H3>
Zur Konfiguration der Ethernet-Schnittstellen und Initialisierung der Routing-Tabelle
sind zwei Befehle von besonderer Bedeutung, nämlich <i>ifconfig</i> (Interface-Konfiguration)
und <i>route</i>.
<p>

<H4>Schnittstellenkonfiguration mit dem <TT>ifconfig</TT>-Kommando</H4>
Das Starten von TCP/IP erfolgt (unter Unix) durch Shell-Skripte, die je nach
Unix-Derivat anders heißen und sich an ganz unterschiedlichen Stellen des jeweiligen
Dateisystems befinden können (Bei Linux beispielsweise im Verzeichnis <i>/etc/init.d</i>.
So unterschiedlich die Shell-Skripte auch sein mögen, die Initialisierung
der Netzwerksoftware erfolgt in jedem Falle durch das <i>ifconfig</i>-Kommando. Hier
wird auch die Initialisierung der Netzwerkschnittstellen vorgenommen. Dabei gibt es
folgende Arten von Schnittstellen:
<UL>
<LI> das Loopback-Interface,
<LI> Broadcast-Interfaces und
<LI> Point-to-Point-Interfaces.
</UL>
Das Loopback-Interface ist eine spezielle Schnittstelle, die zum lokalen System
zurückgeführt. Dies bedeutet, daß alle Daten, die durch das Loopback-Interface
geschickt werden, wieder im lokalen System empfangen werden, Dieser Mechanismus
erlaubt eine Kommunikation von lokalen Prozessen über TCP/IP und wird insbesondere
von TCP/IP-Verwaltungsprozessen, aber auch von anderen Diensten genutzt (so z.B. bei
Datenbanken). Die Standard-Internet-Adresse der Loopback-Schnittstelle ist 127.0.0.1
und sollte, obwohl es theoretisch möglich ist, nicht verändert werden.
<P>
<i>ifconfig</i> dient dazu, eine Schnittstelle für die Netzwerkschicht des Kernels sichtbar
zu machen. Das beinhaltet die Zuweisung einer IP-Adresse und verschiedener anderer Parameter
sowie die Aktivierung des Interface, damit der Kernel die IP-Pakete über diese
Schnittstelle senden und empfangen kann. Die einfachste Art, es aufzurufen, ist:
<pre>
ifconfig &lt;interface&gt; &lt;ip-addresse&gt; netmask &lt;maske&gt;
</pre>
Der Befehl weist "interface" die Adresse "ip-adresse" zu und aktiviert es. Alle anderen
Parameter werden auf Standardwerte gesetzt. Fehlt die Netzmaske (<TT>netmask &lt;maske&gt;</TT>),
wird sie aus der Netzwerkklasse der Adresse abgeleitet; für ein Klasse-B-Netz wäre
das <i>255.255.0.0</i>. Oftmals besteht das Kommando aber zumindest auf der Netzmaske
als Parameter. Später dazu mehr.
<p>
Initialisiert wird das Loopback-Interface durch das Kommando:
<PRE>
ifconfig lo 127.0.0.1
</PRE>
Sogenannte "Broadcast-Interfaces" sind die üblichen Schnittstellen zu lokalen Netzwerken,
über die mehrere Systeme erreichbar sind, und über die Broadcasts, also Nachrichten
an alle, verschickt werden. Es handelt sich dabei um Schnittstellen zu Ethernet und TokenRing.
Neben der Internet-Adresse werden bei der Initiatisierung des Broadcast-Interfaces auch
die Netzmaske und die Broadcast-Adresse angegeben:
<P>
<TT>ifconfig eth0 192.168.0.1 netmask 255.255.255.0 broadcast 192.168.0.255</TT>
<P>
Neben den Broadcast-Schnittstellen gibt es noch die sogenannten
Point-to-Point-Schnittstellen. Sie sind dadurch gekennzeichnet, daß man nur über sie
ein anderes System erreichen kann. Beispiele sind SLIP (Serial Line IP) und das
Point-to-Point-Protokoll PPP, die Verbindungen über die serielle Schnittstelle oder
per Modem/ISDN-Adapter WAN-Verbindungen zulassen. Die Initialisierung einer
Point-to-Point-Schnittstelle hat z.B. die folgende Form:
<P>
<TT>ifconfig ppp0 192.168.1.1 192.168.1.2 netmask 255.255.255.240</TT>
<P>
So eine PPP-Verbindung bildet ein eigenständiges Netzwerk. Sollen mehrere Verbindungen
kombiniert werden, so muß eine Unterteilung in Subnetze erfolgen. Das heißt, daß eine
entsprechende Netzmaske gewählt werden muß.
<P>

<i>ifconfig</i> kennt eine ganze Reihe von Optionen. Der allgemeine Programmaufruf lautet:
<pre>
ifconfig interface [address [parameters]]
</pre>
<i>interface</i> ist der Name der zu konfigurierenden Schnittstelle, und
<i>address</i> ist die IP-Adresse, die ihr zugewiesen werden soll. Sie
kann entweder als dotted quad angegeben werden oder als Name,
den <i>ifconfig</i> in <i>/etc/hosts</i> nachschlägt.
<p>
Ein Aufruf nur mit dem Interface-Namen gibt die Konfiguration des
Interface aus. Wird es ganz ohne Parameter aufgerufen, zeigt es alle
bisher konfigurierten Schnittstellen an; die Option <b>-a</b> erzwingt
zusätzlich die Anzeige der inaktiven. Beispiel:
<pre>
# ifconfig eth0
eth0      Link encap 10Mbps Ethernet  HWaddr 00:00:C0:90:B3:42
          inet addr 172.20.20.2 Bcast 172.20.20.255 Mask 255.255.255.0
          UP BROADCAST RUNNING  MTU 1500  Metric 0
          RX packets 3136 errors 217 dropped 7 overrun 26
          TX packets 1752 errors 25 dropped 0 overrun 0

</pre>
MTU gibt die maximale Blockgröße an.
Die Metrik wird von einigen Betriebssystemen verwendet, um die Kosten einer
Route zu berechnen. Linux benutzt diesen Wert bisher nicht, definiert ihn
aber trotzdem aus Gründen der Kompatibilität.
Die Zeilen <tt>RX</tt> und <tt>TX</tt> zeigen an, wie viele Pakete empfangen
(RX - <i>receive</i>) bzw. gesendet wurden (TX - <i>transmit</i>), wie viele
Fehler dabei auftraten, wie viele Pakete verworfen wurden (dropped) und wie
viele wegen eines überlaufs (overrun) verlorengingen. Ein überlauf beim Empfänger
tritt dann auf, wenn Pakete schneller hereinkommen, als der Kernel die Interrupts
bedienen kann.
<p>
Die folgende Liste zeigt die Parameter, die <i>ifconfig</i> versteht; die Namen
der zugehörigen Flags stehen in Klammern. Optionen, die eine bestimmte Eigenschaft
des Interface aktivieren, können mit vorangestelltem Minuszeichen (-) auch benutzt
werden, um ihn wieder auszuschalten.
<p>
<table border=1 cellpadding=3 cellspacing=1 width="90%">
<tr><td><tt>up</tt></td><td>
Aktiviert ein Interface für die IP-Schicht des Kernels. Sie wird impliziert, wenn
auf der Kommandozeile eine Adresse angegeben ist. Sie kann auch dazu benutzt werden,
ein Interface zu reaktivieren, wenn es mit der <tt>down</tt>-Option temporär
deaktiviert wurde. Entspricht den Flags <i>UP</i> und <i>RUNNING</i>.
</td></tr>
<tr><td><tt>down</tt></td><td>
Markiert eine Schnittstelle als inaktiv, d.h. unzugänglich für die Netzwerkschicht.
Dadurch wird jeglicher IP-Transport durch die Schnittstelle unterbunden. Beachten
Sie, daß dadurch automatisch alle Routing-Einträge gelöscht werden, die diese
Schnittstelle verwenden.
</td></tr>

<tr><td><tt>netmask</tt>&nbsp;Maske</td><td>
Weist des Interface eine Subnetzmaske zu. Sie kann entweder als eine
32-Bit-Hexadezimalzahl (mit führender 0x) oder als dotted quad
(Beispiel: 255.255.255.0) angegeben werden.
</td></tr>
<tr><td><tt>pointopoint</tt>&nbsp;Adresse</td><td>
Wird für Punkt-zu-Punkt-Verbindungen benutzt, die nur zwei Hosts miteinander
verbinden. Sie wird beispielsweise für die Konfiguration von SLIP- und
PLIP-Schnittstellen benötigt und teilt dem Kernel die IP-Adresse des
anderen Systems mit. Falls eine Punkt-zu-Punkt-Adresse gesetzt wurde,
zeigt <i>ifconfig</i> das <i>POINTOPOINT</i>-Flag an ("pointopoint" wird
wirklich so geschrieben).
</td></tr>
<tr><td><tt>broadcast</tt>&nbsp;Adresse</td><td>
Die Broadcast-Adresse wird normalerweise aus der Netzwerknummer gebildet,
indem alle Bits des Hostanteils auf eins gesetzt werden. Einige IP-Implementierungen
verwenden dagegen eine Broadcast-Adresse, bei der die Bits des Hostteils auf null
gesetzt sind. Die Option <b>broadcast</b> dient dazu, Ihre Konfiguration an eine derartige
Umgebung anzupassen. Wenn dem Interface eine Broadcast-Adresse zugeordnet wurde,
gibt <i>ifconfig</i> das Flag <i>BROADCAST</i> aus.
</td></tr>
<tr><td><tt>metric</tt>&nbsp;Wert</td><td>
Dem Routing-Tabellen-Eintrag des Interface einen Metrikwert zuordnen. Dieser Wert
wird beispielsweise vom <i>Routing Information Protocol</i> (RIP) berücksichtigt, wenn
es Routing-Tabellen für Ihr Netz erstellt. Die Default-Metrik, die <i>ifconfig</i>
einem Interface zuweist, ist 0. Wenn Sie das Routing in Ihrem Netz nicht mit RIP
regeln, benötigen Sie diese Option nicht; aber auch sonst wird die Option
selten benutzt.
</td></tr>
<tr><td><tt>mtu</tt>&nbsp;Bytes</td><td>
Setzen der <i>Maximum Transmission Unit</i> (MTU), d.h. die maximale Anzahl von
Bytes, die das Interface in einer Transaktion behandeln kann. Für Ethernets liegt
der Defaultwert bei 1500; für SLIP beträgt er 296.
</td></tr>
<tr><td><tt>arp</tt></td><td>
Kann nur für Broadcast-fähige Netz wie Ethernet verwendet werden. Ermöglicht
die Benutzung von ARP zur Zuordnung von IP-Adressen zu physikalischen Adressen.
Für Broadcast-Netze wird sie per Voreinstellung eingeschaltet. Ist ARP
abgeschaltet, zeigt <i>ifconfig</i> das <b>NOARP</b>-Flag an.
<tt>-arp</tt> schaltet ARP explizit aus.
</td></tr>
<tr><td><tt>promisc</tt></td><td>
Versetzt die Schnittstelle in den promiscous mode. Auf Broadcast-Netzen hat
das zur Folge, daß die Schnittstelle alle Pakete unabhängig davon empfängt,
ob sie für einen anderen Host bestimmt sind oder nicht. Dadurch kann man den
Netzwerkverkehr mit Paketfiltern wie <i>tcpdump</i> analysieren.
<tt>-promisc</tt> schaltet den Modus ab.
</td></tr>

<tr><td><tt>allmulti</tt></td><td>
Multicast-Adressen sind wie Ethernet-Broadcast-Adressen, mit der Einschränkung,
daß sie nicht automatisch jeden möglichen Adressaten berücksichtigen, sondern
nur solche, die ausdrücklich zum Empfang vorgesehen (programmiert) sind. Sie
eignen sich besonders für Anwendungen wie Ethernet-basierte Videokonferenzen
oder Audioübertragungen übers Netz, die nur an Interessierte gerichtet sind.
<tt>-allmulti</tt> schaltet Multicast-Adressen ab.
</td></tr>
</table>
<p>

<h4>Das route-Kommmando</h4>
<i>route</i> erlaubt es Ihnen, Routen in die Routing-Tabelle des Kernels einzutragen oder
aus ihr zu entfernen. Es kann aufgerufen werden als:
<pre>
route [add|del] [-net|-host] &lt;target&gt; [dev &lt;if&gt;]
</pre>
Dabei bestimmen die Argumente <b>add</b> bzw. <b>del</b>, ob die Route zu <i>target</i>
eingetragen bzw. aus <i>target</i> entfernt wird. Die Optionen <b>-net</b> und <b>-host</b>
teilen dem route-Kommando mit, ob target ein Netzwerk oder ein Hostrechner ist
(letzteres wird angenommen, wenn Sie hier nichts angeben). Das Argument <i><b>dev </b>if</i> ist optional
und erlaubt Ihnen die Angabe einer Netzwerkschnittstelle, an die die Route gerichtet werden soll.
Wenn Sie dem Kernel keine Informationen darüber geben, versucht er selbst, ein sinnvolles Argument
herauszufinden.
<p>

<h4>Den Rechner konfigurieren</h4>
Das allererste Interface, die aktiviert werden muß, ist das Loopback-Interface:
<pre>
ifconfig lo 127.0.0.1
</pre>
<p>
Manchmal wird anstelle der IP-Adresse auch der Name <i>localhost</i> verwendet. Der Befehl
<i>ifconfig</i> sucht diesen Namen in der Datei <i>/etc/hosts</i>, wo er als Hostname für
<i>127.0.0.1</i> definiert sein muß.
<p>
Zur Anzeige der Konfiguration eines Interface rufen Sie <i>ifconfig</i> mit dem Namen
des Interface auf. Ganz ohne Parameter wird die Konfiguration aller Interfaces gezeigt:
<pre>
ifconfig lo
lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          UP LOOPBACK RUNNING  MTU:3924  Metric:1
          RX packets:0 errors:0 dropped:0 overruns:0 frame:0
          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0
          Collisions:0
</pre>
<p>
Nun fehlt noch ein Eintrag in der Routing-Tabelle, der festlegt, daß dieses Interface als
Route für das Zielsystem <i>127.0.0.1</i> dient. Dazu geben Sie folgendes ein:
<pre>
route add 127.0.0.1
</pre>
Es kann auch hier wieder anstelle der IP-Adresse der Namen <i>localhost</i> verwendet werden
(sofern er in <i>/etc/hosts</i> eingetragen ist).
<p>
Es wäre auch möglich, das Netz von <i>localhost</i> einzutragen:
<pre>
route add -net 127.0.0.0
</pre>
Als nächstes wird mit dem Programm <i>ping</i> getestet, ob alles einwandfrei funktioniert:
<PRE>
ping localhost
PING localhost (127.0.0.1): 56 data bytes
64 bytes from 127.0.0.1: icmp_seq=0 ttl=255 time=0.4 ms
64 bytes from 127.0.0.1: icmp_seq=1 ttl=255 time=0.4 ms
64 bytes from 127.0.0.1: icmp_seq=2 ttl=255 time=0.4 ms
^C
--- localhost ping statistics ---

3 packets transmitted, 3 packets received, 0% packet loss
round-trip min/avg/max = 0.4/0.4/0.4 ms
</pre>
Pakete an <i>127.0.0.1</i> werden also korrekt ausgeliefert und es erfolgt sofort eine Antwort.
Das beweist, daß die erste Netzwerkschnittstelle erfolgreich konfiguriert wurde.
<p>
Die bisher beschriebenen Schritte reichen aus, um Netzwerk-Programme auf einem alleinstehenden
Rechner zu benutzen. Die oben angegebenen Zeilen müssen in das Netzwerk-Initialisierungsskript
eingetragen werden, damit sie beim Systemstart ausgeführt werden. In der Regel wird zumindest
die Konfiguration von "lo" beim Installieren des Systems bereits erledigt. Zur Einstimmung
war das obige aber keine schlechte Übung. Nun sollte zum Beispiel <i>telnet localhost</i>
eine <i>telnet</i>-Verbindung aufbauen und Ihnen den Login-Prompt Ihres Systems geben.
<p>
Die Konfiguration von Ethernet-Schnittstellen geht fast genauso vonstatten wie eben. Man
braucht nur ein paar Parameter mehr, um auch Subnetze verwenden zu können.
<p>
Im Zwergenwald wird vom Klasse-B-Netz nur ein C-Subnetz verwendet. Um
dies dem Interface mitzuteilen, sieht der <i>ifconfig</i>-Aufruf so aus:
<pre>
ifconfig eth0 172.20.20.2 netmask 255.255.255.0
</pre>
oder unter Verwendung des Namens aus <i>/etc/hosts</I>:
<pre>
ifconfig eth0 doc netmask 255.255.255.0
</pre>
Dies weist des Interface <i>eth0</i> die IP-Adresse von <i>doc</i> (<i>172.20.20.2</i>) zu.
Hätte man die Netzmaske weggelassen, wäre sie von <i>ifconfig</i> aus der Netzklasse der
Adresse abgeleitet worden, was den inkorrekten Wert von <i>255.255.0.0</i> ergeben hätte.
Ein schneller Test ergibt jetzt:
<pre>
ifconfig eth0
eth0      Link encap 10Mps Ethernet HWaddr  00:00:C0:90:B3:42
          inet addr 172.20.20.2 Bcast 172.20.20.255 Mask 255.255.255.0
          UP BROADCAST RUNNING  MTU 1500  Metric 1
          RX packets 0 errors 0 dropped 0 overrun 0
          TX packets 0 errors 0 dropped 0 overrun 0
</pre>
<i>ifconfig</i> hat die Broadcast-Adresse (im <tt>Bcast</tt>-Feld angezeigt) automatisch auf
den passenden Wert gesetzt, nämlich die Netzwerknummer mit einem Hostteil, bei dem alle
Bits auf eins gesetzt sind. Außerdem wurde die maximale übertragungseinheit (MTU = <i>Maximum
Transmission Unit</i>, die maximale Größe der IP-Pakete) auf das Ethernet-spezifische Maximum
von 1.500 Bytes eingestellt.
<p>
Wie bereits bei der Loopback-Schnittstelle muß noch eine Route eingetragen werden. Für den
Zwergenwald gilt:
<pre>
route add -net 172.20.20.0
</pre>
Damit ist eine Route definiert, die alle Pakete, die ans Netz 172.20.20.0
gerichtet sind an die Ethernetkarte schickt. Das weiß das System, weil die
Ethernetkarte ja die Adresse 172.20.20.2 hat, also die gleiche
Netzadresse. Dieser Befehl ist bei modernen Versionen von <b>ifconfig</b>
unnötig geworden, weil diese Route eben automatisch bei der Konfiguration
angelegt wird.
<P>
Vielleicht haben Sie bemerkt, daß die Angabe des Interface fehlt. Der Kernel prüft alle bisher
konfigurierten Interfaces und vergleicht das Zielnetz (in unserem Fall <i>172.20.20.0</i>) mit
der Netznummer der Interface-Adresse, d.h. dem bitweisen UND der Interface-Adresse und der
Netzmaske. Die einzige Schnittstelle, bei der diese beiden Werte übereinstimmen, ist <i>eth0</i>.
<p>
Die Option <b>-net</b> ist nötig, da <i>route</i> sowohl Routen zu Netzwerken
als auch zu einzelnen Hosts einrichten kann. Wenn man <i>route</i> eine IP-Adresse
übergibt, versucht das Kommando festzustellen, ob es sich dabei um eine Host- oder Netzadresse
handelt, indem es den Hostteil betrachtet. Ist der Hostteil null, wird angenommen, daß es sich um
eine Netz-Adresse handelt, andernfalls ist es eine Hostadresse. Deshalb würde <i>route</i> in
unserem Beispiel davon ausgehen, daß <tt>172.20.20.0</tt> eine Hostadresse ist (Netz:
<tt>172.20.0.0</tt>, Host: <tt>...20.0</tt>). Da ein Subnetz verwendet wird, braucht das
<i>route-</i>Kommando den Parameter "-net".
<p>
Unter Verwendung des Eintrags in <i>/etc/networks</i> wird das Kommando einfacher:
<pre>
route add zwergenwald
</pre>
<p>
Nun sollte man überprüfen, ob das Ethernet tatsächlich arbeitet. Wählen Sie irgendeine
bereits konfigurierte Maschine auf Ihrem lokalen Ethernet, z.B. <i>grumpy</i>, und
geben Sie folgenden Befehl ein:
<pre>
# ping grumpy
PING grumpy: 64 byte packets
64 bytes from 172.20.20.1: icmp_seq=0. time=10. ms
64 bytes from 172.20.20.1: icmp_seq=1. time=7. ms
64 bytes from 172.20.20.1: icmp_seq=2. time=8. ms
^C

----doc.zwerge.local PING Statistics----

4 packets transmitted, 4 packets received, 0 packets lost
</pre>

Wenn <i>ping</i> keinerlei Antwort bekommt, sollten Sie die Schnittstellenkonfiguration
mit <i>netstat</i> überprüfen. Die Paketstatistiken, die <i>ifconfig</i> ausgibt, geben
an, ob überhaupt Pakete über das Interface übertragen wurden. Zusätzlich sollten Sie
auf beiden Maschinen mit <i>route</i> die Routing-Informationen überprüfen. Wenn
Sie <i>route</i> ohne weitere Parameter aufrufen, gibt es die Routing-Tabellen aus.
Die Option <i>-n</i> sorgt dafür, daß es Adressen numerisch anstelle der
symbolischen Hostnamen darstellt:
<pre>
route -n
Kernel routing table
Destination  Gateway  Genmask         Flags Metric Ref Use    Iface
127.0.0.1    *        255.255.255.255 UH    1      0   112    lo
172.20.20.0   *       255.255.255.0   U     1      0    10    eth0
</pre>
<p>

Die Spalte "Flags" enthält eine Liste von Flags für jedes Interface. <i>U</i> ist
für aktive Schnittstellen immer gesetzt. Ein Flag <i>H</i> in dieser Spalte besagt,
daß die Zieladresse einen einzelnen Host bezeichnet. Wenn eine eingetragene Route
benutzt wird, ändert sich der Wert im <i>Use</i>-Feld ständig.
<P>
Bisher wurde eine Maschine auf einem isolierten Ethernet eingerichtet (z.B. in
einem Heimnetz). Der Regelfall ist allerdings, daß mehrere Netze durch Gateways
miteinander verbunden sind (man will ja auch "nach draußen"). Diese Gateways
verbinden zwei oder mehrere Ethernets miteinander, oder sie stellen das Tor zum
Internet bereit. Um einen Gateway zu nutzen, muß der Netzwerkschicht zusätzliche
Routing-Informationen zur Verfügung stehen.
</p>
<p>
Zum Beispiel sind die Ethernets des Zwergenwaldes und des Feenreichs durch solch
ein Gateway miteinander verbunden, nämlich <i>doc</i>, der bereits konfiguriert
sei. Auf allen Maschinen des Zwergenwaldes muß nur noch eine weitere Route
eingetragen werden, die angibt, daß alle Maschinen im Netzwerk der Feen über
<i>doc</i> erreichbar sind. Der entsprechende Aufruf von <i>route</i> sieht so aus
(sofern <tt>feenreich</tt> in <i>/etc/networks</i> eingetragen wurde):
<pre>
route add feenreich gw doc
</pre>
Dabei gibt <i>gw</i> an, daß das folgende Argument ein Gateway bezeichnet.
Natürlich muß jedes System im Feen-Netz, zu dem Sie Verbindung aufnehmen wollen,
einen analogen Routing-Eintrag für das Zwergen-Netz haben. Sonst könnten Sie
nur Daten vom Zwergen-Netz an das Feen-Netz senden, die Rechner im Feen-Netz
wären aber zu keiner Antwort fähig.
<p>
Das war nun ein Gateway, das Pakete zwischen zwei isolierten Netzen befördert.
Nehmen Sie nun an, daß <i>doc</i> außerdem eine Verbindung ins Internet hat.
Dann wäre es wünschenswert, daß Pakete für <i>beliebige</i> Zieladressen, die
nicht im Zwergen-Netz liegen, an <i>doc</i> weitergereicht werden. Das erreicht
man, indem <i>doc</i> zum Default-Gateway wird:
<pre>
route add default gw doc                 oder
route add default gw 172.20.20.1         bei Angabe der IP-Adresse
</pre>
Die Netzwerkadresse <i>default</i> ist eine Abkürzung für <i>0.0.0.0</i>, die
Default-Route. Sie paßt zu jeder Zieladresse und wird immer dann benutzt, wenn
keine andere eingetragene Route paßt.
<p>
Es ist ziemlich einfach, eine Maschine als Gateway einzurichten. Nehmen wir an,
wir befänden uns wieder auf <i>doc</i>, der mit zwei Ethernet-Karten ausgestattet
ist, die jeweils mit einem der beiden Netze verbunden sind. Man muß nur beide
Schnittstellen getrennt konfigurieren und ihnen eine Adresse auf dem jeweiligen
Subnetz zuzuweisen. Dabei ist es recht nützlich, zusätzlich zum offiziellen
Hostnamen <i>doc</i> zwei Namen für die beiden Schnittstellen in
<i>/etc/hosts</i> zu definieren:
<pre>
172.20.20.1      doc.zwerge.local    doc   doc-if1
172.20.21.1      doc-if2
</pre>
<p>
Mit diesen Einträgen lautet die Befehlsreihenfolge für die Einrichtung der
beiden Interfaces:
<pre>
ifconfig eth0 doc-if1 ...
route add zwergenwald
ifconfig eth1 doc-if2 ...
route add feenreich
</pre>
Damit Pakete überhaupt zwischen den verschiedenen Netzwerkschnittstellen vermittelt
werden, bedarf es in neueren Kerneln des Kommandos
<pre>
echo '1' > /proc/sys/net/ipv4/ip_forward
</pre>
Wenn es dann nicht funktioniert, überprüfen Sie, ob Ihr Kernel mit Unterstützung
für IP-Forwarding übersetzt wurde.
<P>
Sie brauchen nicht einmal eine zweite Netzwerkkarte, denn es gibt sogenannte "Device-Aliase".
Dies sind virtuelle Geräte, die mit der gleichen physischen Hardware verbunden sind, jedoch
gleichzeitig aktiviert werden können, um unterschiedliche IP-Adressen zu haben. Sie werden
normalerweise mit dem Gerätennahmen gefolgt von einem Doppelpunkt und einer Zahl dargestellt
(zum Beispiel <i>eth0:1</i>). Wenn Sie einen Alias verwenden, können weder das Interface
noch der Alias zur Verwendung von DHCP konfiguriert werden. <i>eth0:1</i> ist der erste Alias
für <i>eth0</i>. Der zweite Alias hätte den Namen <i>eth0:2</i>, usw. Die Befehle
um beide Netze über eine Netzwerkkarte zu routen, würden lauten:
<pre>
ifconfig eth0 doc-if1 ...
route add zwergenwald
ifconfig eth0:1 doc-if2 ...
route add feenreich
</pre>
<P>
Die Fehlermeldungen des route-Kommandos sind relativ kryptisch. Bei Linux kann - im Gegensatz zu
anderen Unixen - die Metrik-Angabe entfallen. Man kann mehrere Routen zu einem Ziel (mit identischer
Netzmaske) eingeben, sofern jeweils ein anderer Gateway angegeben wird.
<P>
<H4>Fehlermeldungen des route-Kommandos:</H4>
<ul>
<li><b>SIODELRT</b> ist eine Fehlermeldung beim Löschen einer Route (<b>DEL</b>eting a <b>R</b>ou<b>T</b>e)
<li><b>SIOADDRT</b> ist eine Fehlermeldung beim Anlegen einer Route (<b>ADD</b>ing a <b>R</b>ou<b>T</b>e)
</ul>
<DL>
<P><DT><i>SIOCADDRT: Network is unreachable</i>
<DD>
<TT>route add default gw 1.2.3.4</TT><br>
Die angebene Adresse gehört nicht zum eigenen Netzwerk und so kann der Rechner keine
Pakete dorthin weiterleiten.

<P><DT><i>SIOCADDRT: File exists</i>
<DD>Die angegebene Route existiert bereits.

<P><DT><i>SIOCADDRT: No such device</i>
<DD>Es wurde das Schlüsselwort <i>gw</i> vor der Default-Gateway-Adresse vergessen; also nicht:<br>
<TT>route add -net 10.2.2.76/24  10.1.1.22</TT><BR>
sondern:<br>
<TT>route add -net 10.2.2.76/24  gw 10.1.1.22</TT>

<P><DT><i>SIOCDELRT No such process</i>
<DD>Versuch, eine Route zu löschen, die nicht existiert.

<P><DT><i>SIOCADDRT: Operation not supported by device</i>
<DD>Es wurde das Schlüsselwort <i>gw</i> oder die Gateway-Adresse vergessen; also nicht:<br>
<TT>route add -net 10.0.0.0/8 10.1.1.254</TT> oder<br>
<TT>route add -net 172.23.24.128/25</TT><br>
sondern:<br>
<TT>route add -net 10.0.0.0/8 gw  10.1.1.254</TT> oder<br>
<TT>route add -net 172.23.24.128/25 gw 10.1.1.22</TT>

<P><DT><i>SIOCADDRT: Operation not permitted</i>
<DD>Sie arbeiten nicht mit <i>root</i>-Berechtigung.

<P><DT><i>SIOCADDRT: Invalid argument</i>
<DD>Falsche Kommandosyntax (z.B. vergessene Netzmaske); also nicht:<br>
<TT>route add -net 10.2.2.0 gw 10.1.1.254</TT> oder<br>
<TT>route del -net 172.23.0.0</TT><br>
sondern:<br>
<TT>route add -net 10.2.2.0 netmask 255.255.255.0 gw 10.1.1.254</TT> oder<br>
<TT>route add -net 10.2.2.0/24 gw 10.1.1.254</TT> bzw.<br>
<TT>route del -net 172.23.0.0/16</TT> oder<br>
<TT>route del -net 172.23.0.0 netmask 255.255.0.0</TT>

<P><DT><i>route: netmask doesn't match route address</i>
<DD>Die Netzmaske passt nicht zur Host- und Gateway-Adresse.

<P><DT><i>route: netmask 00ffffff doesn't make sense with host route</i>
<DD>Meist wurde der Parameter <i>-net</i> vergessen. Das Kommando nimmt
dann an, dass man eine Host-Route angeben will. Oder man hat bei einer
Host-Route eine Netzmaske angegeben.

<P><DT><i><i>addr</i>: Unknown host</i>
<DD>Meist wurde eine falsche Netzmaske angegebn, die das Kommando falsch
interpretiert.

<P><DT><i>route: bogus netmask 255.255.255.25</i>
<DD>Die Netzmaske ist falsch angegeben worden (z.B. '25' oder '2555' statt '255').
</DL>
<p>
Anmerkung: Die Syntax des route-Kommandos variiert von System zu System.
<P>

<h4>Linux Netzwerk-Konfiguration mit <tt>ip</tt></h4>
Das Kommando <tt>ip</tt> ersetzt die bisherigen Kommandos <tt>ifconfig</tt> und <tt>route</tt>:
<ul><li><tt>ip address &lt;parameter&gt;</tt> richtet die Netzwerkschnittstellen ein (ersetzt <tt>ifconfig</tt>),</li>
<li><tt>ip route &lt;parameter&gt;</tt> richtet das Routing ein (ersetzt <tt>route</tt>),</li>
<li><tt>ip rule &lt;parameter&gt;</tt> richtet Policy Routing ein (erweitertes Routing in Linux) und</li>
<li><tt>ip neigh &lt;parameter&gt;</tt>: Verwaltet die ARP-Tabelle (ersetzt das Kommando <tt>arp</tt>).</li>
</ul>
<p>
Der <tt>ip</tt>-Aufruf zeigt wie <tt>ifconfig</tt>, <tt>route</tt> und <tt>arp</tt> den aktuellen Zustand an. 
Der Befehl horcht auf folgende Syntax:
<pre>
ip [Optionen] Objekt [Kommando [Argumente]]
</pre>
Nicht umsonst ist die  "IP Command Reference" mehr als 60 Seiten dick (<a href="http://linux-ip.net/gl/ip-cref/">
http://linux-ip.net/gl/ip-cref/</a>).

<tt>ip</tt> kann auch komplexe Vorgänge erledigen, weshalb man beispielsweise auch kein IP-Aliasing mehr 
verwenden muss, um einer Schnittstelle mehrere IP-Adressen zuzuweisen. Statt mit "eth0" eth0:1" zu hantieren 
weisen Sie zwei IP-Adressen an eth0 folgendermaßen zu:
<pre>
ip address add 129.187.206.140/24 dev eth0
ip address add 129.187.206.148/24 dev eth0
</pre>
Man kann auch einen Alias zuweisen, um die Abwärtskompatibilität zu den alten Tools zu erhalten:
<pre>
ip address add 129.187.206.140/24 dev eth0
ip address add 129.187.206.148/24 dev eth0 label eth0:1
</pre>

Es folgt ein Beispiel für die Ausgabe der IP-Adressen mit dem Befehl <tt>ip address show</tt>:
<pre>
1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 16436 qdisc noqueue state UNKNOWN
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
    inet6 ::1/128 scope host
       valid_lft forever preferred_lft forever
2: eth0: &lt;BROADCAST,MULTICAST,UP,LOWER_UP&gt; mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:0e:0c:07:e7:72 brd ff:ff:ff:ff:ff:ff
    inet 129.187.206.140/24 brd 129.187.206.255 scope global eth0
    inet 129.187.206.148/24 brd 129.187.206.255 scope global secondary eth0:1
    inet 129.187.206.149/24 brd 129.187.206.255 scope global secondary eth0:2
    inet 129.187.206.152/24 brd 129.187.206.255 scope global secondary eth0:3
    inet 129.187.206.153/24 brd 129.187.206.255 scope global secondary eth0:4
    inet 129.187.206.154/24 brd 129.187.206.255 scope global secondary eth0:5
    inet 129.187.206.156/24 brd 129.187.206.255 scope global secondary eth0:6
    inet 129.187.206.157/24 brd 129.187.206.255 scope global secondary eth0:7
    inet 129.187.206.158/24 brd 129.187.206.255 scope global secondary eth0:8
    inet6 fe80::20e:cff:fe07:e772/64 scope link
       valid_lft forever preferred_lft forever
</pre>
zugewiesene Adressen lassen sich auch ganz einfach löschen:
<pre>
ip address del 129.187.206.157/24 dev eth0
ip address del 129.187.206.158/24 dev eth0
</pre>

Zusätzlich erlaubt es <tt>ip</tt>, den Namen der Netzwerkkarte selbst zu ändern. Das sollte man 
aber nur bei deaktivierten Karten machen, da unerwartete Effekte auftreten, wenn der Name einer 
aktivierten und benutzten Karte geändert wird. Um »eth0« in »test0« umzubenennen, genügen die 
folgenden Zeilen:
<pre>
ip link set dev eth0 down
ip link set dev eth0 name test0
ip link set dev test0 up
</pre>
<p>
Manchmal sind die Fehlermeldungen von <tt>ip</tt> etwas irreführend, zum Beispiel:
<pre>
ip address add 129.187.206.159/24 dev eth0 label eth0:1
RTNETLINK answers: File exists
</pre>
Die Fehlermeldung bedeutet, dass eine Adresse oder Route zu einer bereits konfigurierten 
Schnittstelle hinzugefügt wurde - einen entsprechende Datei gibt es nicht.
<p>
Der Befehl <tt>ip</tt> erlaubt auch fortgeschrittenes Routing wie z. B. Policy-Routing. 
Die Routen können mit folgendem Kommando angezeigt werden:
<pre>
ip route show
129.187.206.0/24 dev eth0  proto kernel  scope link  src 129.187.206.140
default via 129.187.206.254 dev eth0
</pre>
Die erste Zeile ist eine Regel, die aussagt, dass alles nach 129.187.206.0 über 129.187.206.140 versandt 
werden muss (das ist ja auch die "Basisadresse" für eth0 im obigen Beispiel).
Die zweite Zeile ist die Regel für die Defaultroute. Der Host 129.187.206.254 stellt dabei den Gateway dar.
<p>
Angelegt werden die Routen mittels <tt>ip route add</tt> und dann der Angabe die praktisch
der Ausgabe von <tt>ip route show</tt> entspricht:
<pre>
ip route add 127.0.0.0/8 dev lo scope link
ip route add 129.187.206.0/24 dev eth0 proto kernel scope link src 129.187.206.140
ip route add default via 129.187.206.254 dev eth0
</pre>
Oft reicht für die zweite Zeile auch schon <tt>ip route add 129.187.206.0/24 dev eth0 scope link</tt>.
Nachfolgend weitere Beispiele, wie Routing mit <tt>ip route</tt> konfiguriert werden kann:
<ul>
<li>Einrichten der Standard-Route auf 129.187.206.254 als Gateway:
<br /><tt>ip route add default via 129.187.206.254 dev eth0</tt>

<li>Schicken der Pakete in das Netz 192.168.150.0 über die zweite Netzwerkschnittstelle eth1:
<br /><tt>ip route add 192.168.150.0/24 dev eth1</tt>

<li>Schicken dder Pakete des Subnetzes 192.168.200.0/24 über ein Gateway:
<br /><tt>ip route add 192.168.200.0/24 via 192.168.150.1</tt>

<li>Löschen der vorherigen Route aus der Routing-Tabelle:
<br /><tt>ip route del 192.168.200.0/24</tt>
</ul>
<p>


<h4>Offene Ports und Anwendungen finden mit netstat</h4>
Ein offener Port im Status "Listen" ist ein potientielles Einfallstor
für Eindringlinge. Auch Trojaner installieren gerne "Backdoors" und
öffnen dazu einen freien Port. Daher ist es sehr zu empfehlen, sich
von Zeit zu Zeit die offenen Ports seiner Systeme anzusehen.
<p>
Für eine Kontrolle der offenen Ports ruft man "netstat&nbsp;-nlp" auf.
</p>

<pre>
netstat -npl
Proto Recv-Q Send-Q Local Address        Foreign Address   State   PID/Program name
tcp        0      0 72.139.238.24:80     0.0.0.0:*         LISTEN  25671/apache
tcp        0      0 72.139.238.24:21     0.0.0.0:*         LISTEN  16417/ftpd
tcp        0      0 72.139.238.24:22     0.0.0.0:*         LISTEN  1345/sshd
tcp        0      0 72.139.238.24:25     0.0.0.0:*         LISTEN  26007/exim4
tcp        0      0 72.139.238.24:443    0.0.0.0:*         LISTEN  1022/apache-ssl
</pre>

<p>
Das System zeigt mit diesen Parameter nur Ports im Status "Listen" an.
Zusätzlich wird in der letzten Spalte die Prozessnummer und der Name
des zuständigen Dämons angezeigt. Alternativ kann unter Linux auch das
Kommando "lsof" benutzt werden. Mit dem Aufruf
<pre>
lsof -i | grep -e LISTEN
</pre>
wird ebenfalls eine Liste der Ports im Status "Listen" angezeigt.
<p>

<h4>Einsatz von nmap</h4>
Zur Kontrolle der offenen Ports eines Host über das Netzwerk benötigt
man einen Portscanner, z.B. nmap von Fyodor. Der Portscanner nmap kennt
eine Unmenge von Optionen. Für einen ersten Scan nach offenen TCP-Ports
wird lediglich der Parameter "-sT" und die IP-Adresse des Zielsystems
benötigt. Damit scannt nmap alle well know TCP-Ports (1-1024) und alle
Ports aus der Datei etc/services.

<pre>
nmap -sT 192.168.1.1

Starting nmap 3.20 ( www.insecure.org/nmap/ ) at 2004-10-16 23:17 CEST
Interesting ports on Router (192.168.1.1):
(The 1610 ports scanned but not shown below are in state: closed)
Port       State       Service
80/tcp     open        http

Nmap run completed -- 1 IP address (1 host up) scanned in 6.533 seconds
</pre>

Der hier untersuchte IP-Host bietet einen Dienst an: HTTP auf TCP-Port 80.
Auf der Maschine läuft also höchstwarscheinlich ein Webserver. Um alle TCP-Ports
von 1 bis 65535 zu untersuchen ruft man nmap mit den Optionen "-sT -p 1-65535" auf.
Mit der Option "-sU" sucht nmap nach offenen UDP-Ports. UDP-Scanning ist allerdings
oftmals sehr langsam. Ursache hierfür ist eine Begrenzung der Anzahl der ICMP-Meldungen
die ein Host pro Zeiteinheit versendet. Viele Systeme begrenzen die ICMP-Meldungen nach
RFC 1812. nmap erkennt dieses Verhalten und arbeitet entsprechen langsamer um keine
Meldungen zu verlieren.
<p>

<h4>tcpdump</h4>
Wenn Probleme in einem Netz auftauchen, so kann mit Hilfe des Programms
"tcpdump" jedes einzelne Paket des Netzes protokolliert und analysiert
werden. Dazu wird die Netzwerkkarte in den <i>promisquous-mode</i>
geschaltet.
"tcpdump" zeigt jetzt die empfangenen Paket-Header an und ermöglicht so
eine Diagnose der aufgetretenen Fehler. Die Anwendung ist ziemlich
kompliziert und würde den Rahmen dieses Kapitels sprengen. Es genügt, zu
wissen, daß es dieses Programm gibt und daß es folgendermaßen aufgerufen
wird.
<ul><b>tcpdump</b> <tt>-i</tt> <i>Interface</i></ul>
Damit werden alle Pakete des genannten Interfaces abgehört. Das Interface
wird mit seinem symbolischen Namen angegeben, also beispielsweise
<i>eth0</i>.
<p>
<b>tcpdump</b> hat eine eigene Art Abfragesprache, die Befehle ermöglicht
wie
<pre>
  tcpdump host blackhole
</pre>
Zeigt nur Pakete an den oder vom Rechner blackhole.
<pre>
  tcpdump host doc and grumpy
</pre>
Zeigt nur Pakete, die zwischen den Rechnern doc und grumpy ausgetauscht werden.
<P>


<H3>Die ARP-Tabelle</H3>
Bei einigen Netzproblemen kann es aufschlußreich sein, einen Blick auf
die ARP-Tabelle des Kernels zu werfen oder sie sogar zu verändern.
Die Kommandozeilenoptionen von ARP lauten:
<pre>
arp [-v] [-t hwtype] -a [hostname]
arp [-v] [-t hwtype] -s hostname hwaddr
</pre>
Alle hostname-Argumente können als symbolische Hostnamen oder als IP-Adressen angegeben werden.
<p>
Der erste Aufruf gibt den ARP-Eintrag für die angegebene IP-Adresse bzw. Hostnamen aus.
Fehlt <i>hostname</i>, werden Informationen über alle bekannten Hosts ausgegeben.
Zum Beispiel ergibt die Ausgabe von <i>arp</i> auf <i>www.netzmafia.de</i> etwa folgendes:
<pre>
arp
Address                  HWtype  HWaddress           Flags Mask  Iface
129.187.206.254          ether   00:04:DE:FE:78:00   C           eth0
ns.e-technik.fh-muenche  ether   00:07:E9:24:EC:15   C           eth0
proxy1.e-technik.fh-mue  ether   00:07:E9:24:EC:15   C           eth0
web1.e-technik.fh-muenc  ether   00:07:E9:24:EB:F5   C           eth0
</pre>
Die Ausgabe kann mit der <b>-t</b>-Option auch auf bestimmte Hardwaretypen beschränkt werden.
Als Argument geben Sie <i>ether</i>, <i>ax25</i> oder <i>pronet</i> an, was für 10 Mbps Ethernet,
AMPR AX.25 und IEEE 802.5 Token Ring steht.
<p>
Die Option <b>-s</b> dient dazu, die Hardwareadresse von <i>hostname</i> manuell in die
ARP-Tabelle einzutragen. Das Argument <i>hwaddr</i> spezifiziert die Hardwareadresse,
die normalerweise als Ethernet-Adresse aus sechs Byte in hexadezimaler Notation angegeben ist.
Sie können solche Adressen auch bei anderen Hardwaretypen verwenden, wenn Sie zusätzlich die
Option <b>-t</b> angeben.
Die Festverdrahtung von Hardwareadressen im ARP-Cache ist eine drastische Maßnahme, um Maschinen
aus Ihrem Ethernet daran zu hindern, sich als jemand anderes auszugeben.
<p>
Wenn Sie <i>arp</i> mit der Option <b>-d</b> aufrufen, entfernt es alle Einträge für einen bestimmten
Host. Es kann dazu benutzt werden, das Interface anzuweisen, eine bereits angeforderte Hardwareadresse
einer IP-Adresse nochmals anzufordern, und ist besonders dann nützlich, wenn ein fehlerhaft konfiguriertes
System falsche ARP-Informationen sendet (natürlich muß zuerst das fehlerhafte System erneut konfiguriert
werden).
<p>


<CENTER><TABLE BORDER=0 WIDTH="100%">
<TR>
<TD ALIGN=LEFT VALIGN=BOTTOM><img src="images/left.png" BORDER=0> <A HREF="twisted.html">Zum vorhergehenden Abschnitt</A></TD>
<TD ALIGN=CENTER VALIGN=BOTTOM><img src="images/up.png" BORDER=0> <A HREF="index.html">Zum Inhaltsverzeichnis</A></TD>
<TD ALIGN=RIGHT VALIGN=BOTTOM><img src="images/right.png" BORDER=0> <A HREF="netz9.html">Zum nächsten Abschnitt</A></TD>
</TR></TABLE></CENTER>
<P><HR>
<h6><i>Copyright &copy; Hochschule München, FK 04, Prof. Jürgen Plate</i><br>
Letzte Aktualisierung: <SCRIPT LANGUAGE="JavaScript">document.write(document.lastModified);</SCRIPT></I></H6>
</BODY>
</HTML>